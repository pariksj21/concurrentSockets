// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/strtok3/lib/stream/Errors.js
class EndOfStreamError extends Error {
  constructor() {
    super(defaultMessages);
    this.name = "EndOfStreamError";
  }
}

class AbortError extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
}
var defaultMessages;
var init_Errors = __esm(() => {
  defaultMessages = "End-Of-Stream";
});

// node_modules/strtok3/lib/stream/Deferred.js
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
}
var init_Deferred = __esm(() => {
});

// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
class StreamReader extends AbstractStreamReader {
  constructor(s) {
    super();
    this.s = s;
    this.deferred = null;
    if (!s.read || !s.once) {
      throw new Error("Expected an instance of stream.Readable");
    }
    this.s.once("end", () => {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.resolve(0);
      }
    });
    this.s.once("error", (err) => this.reject(err));
    this.s.once("close", () => this.abort());
  }
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    const readBuffer = this.s.read(buffer.length);
    if (readBuffer) {
      buffer.set(readBuffer);
      return readBuffer.length;
    }
    const request = {
      buffer,
      mayBeLess,
      deferred: new Deferred
    };
    this.deferred = request.deferred;
    this.s.once("readable", () => {
      this.readDeferred(request);
    });
    return request.deferred.promise;
  }
  readDeferred(request) {
    const readBuffer = this.s.read(request.buffer.length);
    if (readBuffer) {
      request.buffer.set(readBuffer);
      request.deferred.resolve(readBuffer.length);
      this.deferred = null;
    } else {
      this.s.once("readable", () => {
        this.readDeferred(request);
      });
    }
  }
  reject(err) {
    this.interrupted = true;
    if (this.deferred) {
      this.deferred.reject(err);
      this.deferred = null;
    }
  }
  async abort() {
    this.reject(new AbortError);
  }
  async close() {
    return this.abort();
  }
}
var init_StreamReader = __esm(() => {
  init_Errors();
  init_Deferred();
  init_AbstractStreamReader();
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
class WebStreamReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
  }
  async abort() {
    return this.close();
  }
  async close() {
    this.reader.releaseLock();
  }
}
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
class WebStreamByobReader extends WebStreamReader {
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
    if (result.done) {
      this.endOfStream = result.done;
    }
    if (result.value) {
      buffer.set(result.value);
      return result.value.length;
    }
    return 0;
  }
}
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
class WebStreamDefaultReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
    this.buffer = null;
  }
  writeChunk(target, chunk) {
    const written = Math.min(chunk.length, target.length);
    target.set(chunk.subarray(0, written));
    if (written < chunk.length) {
      this.buffer = chunk.subarray(written);
    } else {
      this.buffer = null;
    }
    return written;
  }
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    let totalBytesRead = 0;
    if (this.buffer) {
      totalBytesRead += this.writeChunk(buffer, this.buffer);
    }
    while (totalBytesRead < buffer.length && !this.endOfStream) {
      const result = await this.reader.read();
      if (result.done) {
        this.endOfStream = true;
        break;
      }
      if (result.value) {
        totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
      }
    }
    if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
      throw new EndOfStreamError;
    }
    return totalBytesRead;
  }
  abort() {
    this.interrupted = true;
    return this.reader.cancel();
  }
  async close() {
    await this.abort();
    this.reader.releaseLock();
  }
}
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error23) {
    if (error23 instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error23;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
class ReadStreamTokenizer extends AbstractTokenizer {
  constructor(streamReader, options) {
    super(options);
    this.streamReader = streamReader;
    this.fileInfo = options?.fileInfo ?? {};
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    }
    if (skipBytes < 0) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
        uint8Array.set(skipBuffer.subarray(skipBytes));
        return bytesRead - skipBytes;
      }
      if (skipBytes < 0) {
        throw new Error("Cannot peek from a negative offset in a stream");
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      } catch (err) {
        if (options?.mayBeLess && err instanceof EndOfStreamError) {
          return 0;
        }
        throw err;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
    }
    return bytesRead;
  }
  async ignore(length) {
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
  abort() {
    return this.streamReader.abort();
  }
  async close() {
    return this.streamReader.close();
  }
  supportsRandomAccess() {
    return false;
  }
}
var maxBufferSize;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  maxBufferSize = 256000;
});

// node_modules/strtok3/lib/BufferTokenizer.js
class BufferTokenizer extends AbstractTokenizer {
  constructor(uint8Array, options) {
    super(options);
    this.uint8Array = uint8Array;
    this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
  }
  async readBuffer(uint8Array, options) {
    if (options?.position) {
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new EndOfStreamError;
    }
    uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
    return bytes2read;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(position) {
    this.position = position;
  }
}
var init_BufferTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/BlobTokenizer.js
var init_BlobTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/core.js
function fromStream(stream6, options) {
  const streamReader = new StreamReader(stream6);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await streamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_stream();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_BlobTokenizer();
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import {open as fsOpen} from "fs/promises";

class FileTokenizer extends AbstractTokenizer {
  static async fromFile(sourceFilePath) {
    const fileHandle = await fsOpen(sourceFilePath, "r");
    const stat = await fileHandle.stat();
    return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
  }
  constructor(fileHandle, options) {
    super(options);
    this.fileHandle = fileHandle;
    this.fileInfo = options.fileInfo;
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    this.position = normOptions.position;
    if (normOptions.length === 0)
      return 0;
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    this.position += res.bytesRead;
    if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async close() {
    await this.fileHandle.close();
    return super.close();
  }
  setPosition(position) {
    this.position = position;
  }
  supportsRandomAccess() {
    return true;
  }
}
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
});

// node_modules/strtok3/lib/index.js
import {stat as fsStat} from "fs/promises";
async function fromStream2(stream7, options) {
  const rst = fromStream(stream7, options);
  if (stream7.path) {
    const stat = await fsStat(stream7.path);
    rst.fileInfo.path = stream7.path;
    rst.fileInfo.size = stat.size;
  }
  return rst;
}
var fromFile;
var init_lib = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/token-types/lib/index.js
class StringType2 {
  constructor(len, encoding) {
    this.len = len;
    if (encoding && encoding.toLowerCase() === "windows-1252") {
      this.decoder = StringType2.decodeWindows1252;
    } else {
      const textDecoder = new TextDecoder(encoding);
      this.decoder = (bytes) => textDecoder.decode(bytes);
    }
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return this.decoder(bytes);
  }
  static decodeWindows1252(bytes) {
    let result = "";
    for (let i = 0;i < bytes.length; i++) {
      const byte = bytes[i];
      result += byte < 128 || byte >= 160 ? String.fromCharCode(byte) : StringType2.win1252Map[byte - 128];
    }
    return result;
  }
}
var dv, UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib2 = __esm(() => {
  init_ieee754();
  dv = function(array3) {
    return new DataView(array3.buffer, array3.byteOffset);
  };
  UINT8 = {
    len: 1,
    get(array3, offset) {
      return dv(array3).getUint8(offset);
    },
    put(array3, offset, value21) {
      dv(array3).setUint8(offset, value21);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array3, offset) {
      return dv(array3).getUint16(offset, true);
    },
    put(array3, offset, value21) {
      dv(array3).setUint16(offset, value21, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array3, offset) {
      return dv(array3).getUint16(offset);
    },
    put(array3, offset, value21) {
      dv(array3).setUint16(offset, value21);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array3, offset) {
      return dv(array3).getUint32(offset, true);
    },
    put(array3, offset, value21) {
      dv(array3).setUint32(offset, value21, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array3, offset) {
      return dv(array3).getUint32(offset);
    },
    put(array3, offset, value21) {
      dv(array3).setUint32(offset, value21);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array3, offset) {
      return dv(array3).getInt32(offset);
    },
    put(array3, offset, value21) {
      dv(array3).setInt32(offset, value21);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array3, offset) {
      return dv(array3).getBigUint64(offset, true);
    },
    put(array3, offset, value21) {
      dv(array3).setBigUint64(offset, value21, true);
      return offset + 8;
    }
  };
  StringType2.win1252Map = "\u20AC\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\u017D\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\u017E\u0178";
});

// node_modules/fflate/esm/index.mjs
import {createRequire} from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap, flt, i, i, i, i, fdt, i, flrm, fdrm, max, bits, bits16, shft, slc, ec, err, inflt, et, gzs, gzl, zls, td, tds;
var init_esm = __esm(() => {
  require2 = createRequire("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  freb = function(eb, start) {
    var b = new u16(31);
    for (var i = 0;i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    var r = new i32(b[30]);
    for (var i = 1;i < 30; ++i) {
      for (var j = b[i];j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return { b, r };
  };
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  hMap = function(cd, mb, r) {
    var s = cd.length;
    var i = 0;
    var l = new u16(mb);
    for (;i < s; ++i) {
      if (cd[i])
        ++l[cd[i] - 1];
    }
    var le = new u16(mb);
    for (i = 1;i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i = 0;i < s; ++i) {
        if (cd[i]) {
          var sv = i << 4 | cd[i];
          var r_1 = mb - cd[i];
          var v = le[cd[i] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0;i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
        }
      }
    }
    return co;
  };
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = hMap(flt, 9, 1);
  fdrm = hMap(fdt, 5, 1);
  max = function(a) {
    var m = a[0];
    for (var i = 1;i < a.length; ++i) {
      if (a[i] > m)
        m = a[i];
    }
    return m;
  };
  bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    return new u8(v.subarray(s, e));
  };
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type54 = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type54) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type54 == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type54 == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i = 0;i < hcLen; ++i) {
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i = 0;i < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (;; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i = sym - 257, b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (;bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (;bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  et = new u8(0);
  gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
      err(6, "invalid gzip data");
    var flg = d[3];
    var st = 10;
    if (flg & 4)
      st += (d[10] | d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
      ;
    return st + (flg & 2);
  };
  gzl = function(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
  };
  zls = function(d, dict) {
    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
      err(6, "invalid zlib data");
    if ((d[1] >> 5 & 1) == +!dict)
      err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
    return (d[1] >> 3 & 4) + 2;
  };
  td = typeof TextDecoder != "undefined" && new TextDecoder;
  tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse4 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type54 = (match[2] || "ms").toLowerCase();
    switch (type54) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type54 = typeof val;
    if (type54 === "string" && val.length > 0) {
      return parse4(val);
    } else if (type54 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash5 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash5 = (hash5 << 5) - hash5 + namespace.charCodeAt(i);
        hash5 |= 0;
      }
      return createDebug.colors[Math.abs(hash5) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error23) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error23) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error23) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error23) {
      return "[UnexpectedJSONParseError]: " + error23.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = import.meta.require("tty");
  var util = import.meta.require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{ throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error23) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib2();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array3) {
      const flags = UINT16_LE.get(array3, 6);
      return {
        signature: UINT32_LE.get(array3, 0),
        compressedSize: UINT32_LE.get(array3, 8),
        uncompressedSize: UINT32_LE.get(array3, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array3) {
      const flags = UINT16_LE.get(array3, 6);
      return {
        signature: UINT32_LE.get(array3, 0),
        minVersion: UINT16_LE.get(array3, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array3, 8),
        compressedSize: UINT32_LE.get(array3, 18),
        uncompressedSize: UINT32_LE.get(array3, 22),
        filenameLength: UINT16_LE.get(array3, 26),
        extraFieldLength: UINT16_LE.get(array3, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array3) {
      return {
        signature: UINT32_LE.get(array3, 0),
        nrOfThisDisk: UINT16_LE.get(array3, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array3, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array3, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array3, 10),
        sizeOfCd: UINT32_LE.get(array3, 12),
        offsetOfStartOfCd: UINT32_LE.get(array3, 16),
        zipFileCommentLength: UINT16_LE.get(array3, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array3) {
      const flags = UINT16_LE.get(array3, 8);
      return {
        signature: UINT32_LE.get(array3, 0),
        minVersion: UINT16_LE.get(array3, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array3, 10),
        compressedSize: UINT32_LE.get(array3, 20),
        uncompressedSize: UINT32_LE.get(array3, 24),
        filenameLength: UINT16_LE.get(array3, 28),
        extraFieldLength: UINT16_LE.get(array3, 30),
        fileCommentLength: UINT16_LE.get(array3, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array3, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i = buffer.length - 4;i >= 0; i--) {
      if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType2(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType2(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
var import_debug, signatureToArray, indexOf, mergeArrays, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib3 = __esm(() => {
  init_lib2();
  init_esm();
  import_debug = __toESM(require_src(), 1);
  init_ZipToken();
  signatureToArray = function(signature) {
    const signatureBytes = new Uint8Array(UINT32_LE.len);
    UINT32_LE.put(signatureBytes, 0, signature);
    return signatureBytes;
  };
  indexOf = function(buffer, portion) {
    const bufferLength = buffer.length;
    const portionLength = portion.length;
    if (portionLength > bufferLength)
      return -1;
    for (let i = 0;i <= bufferLength - portionLength; i++) {
      let found = true;
      for (let j = 0;j < portionLength; j++) {
        if (buffer[i + j] !== portion[j]) {
          found = false;
          break;
        }
      }
      if (found) {
        return i;
      }
    }
    return -1;
  };
  mergeArrays = function(chunks) {
    const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
    const mergedArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      mergedArray.set(chunk, offset);
      offset += chunk.length;
    }
    return mergedArray;
  };
  debug = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string5) {
  return [...string5].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
  init_lib2();
  uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
  return new FileTypeParser(options).fromBlob(blob);
}
async function fileTypeFromTokenizer(tokenizer, options) {
  return new FileTypeParser(options).fromTokenizer(tokenizer);
}

class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream7) {
    const tokenizer = await fromWebStream(stream7, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream7, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream7.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error23) {
          if (!(error23 instanceof EndOfStreamError)) {
            throw error23;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream7.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type54 = new Uint8Array(8);
      await tokenizer.readBuffer(type54);
      if (_check(type54, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type54, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type54, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type54, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type54, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type54, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType2(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType2(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string5 = await tokenizer.readToken(new StringType2(13, "ascii"));
      if (string5 === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && ["\n", "\r", "\t", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType2(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType2(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type54 = await tokenizer.readToken(new StringType2(4, "ascii"));
      switch (type54) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {
        }
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \0")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type54 = this.scanMpeg(depth);
        if (type54) {
          return type54;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var getFileTypeFromMimeType, _check, reasonableDetectionSizeInBytes, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib2();
  init_core();
  init_lib3();
  init_uint8array_extras();
  init_util();
  init_supported();
  getFileTypeFromMimeType = function(mimeType) {
    mimeType = mimeType.toLowerCase();
    switch (mimeType) {
      case "application/epub+zip":
        return {
          ext: "epub",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.text":
        return {
          ext: "odt",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.text-template":
        return {
          ext: "ott",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.spreadsheet":
        return {
          ext: "ods",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.spreadsheet-template":
        return {
          ext: "ots",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.presentation":
        return {
          ext: "odp",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.presentation-template":
        return {
          ext: "otp",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.graphics":
        return {
          ext: "odg",
          mime: mimeType
        };
      case "application/vnd.oasis.opendocument.graphics-template":
        return {
          ext: "otg",
          mime: mimeType
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
        return {
          ext: "ppsx",
          mime: mimeType
        };
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
        return {
          ext: "xlsx",
          mime: mimeType
        };
      case "application/vnd.ms-excel.sheet.macroenabled":
        return {
          ext: "xlsm",
          mime: "application/vnd.ms-excel.sheet.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
        return {
          ext: "xltx",
          mime: mimeType
        };
      case "application/vnd.ms-excel.template.macroenabled":
        return {
          ext: "xltm",
          mime: "application/vnd.ms-excel.template.macroenabled.12"
        };
      case "application/vnd.ms-powerpoint.slideshow.macroenabled":
        return {
          ext: "ppsm",
          mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        return {
          ext: "docx",
          mime: mimeType
        };
      case "application/vnd.ms-word.document.macroenabled":
        return {
          ext: "docm",
          mime: "application/vnd.ms-word.document.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
        return {
          ext: "dotx",
          mime: mimeType
        };
      case "application/vnd.ms-word.template.macroenabledtemplate":
        return {
          ext: "dotm",
          mime: "application/vnd.ms-word.template.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.template":
        return {
          ext: "potx",
          mime: mimeType
        };
      case "application/vnd.ms-powerpoint.template.macroenabled":
        return {
          ext: "potm",
          mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
        };
      case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
        return {
          ext: "pptx",
          mime: mimeType
        };
      case "application/vnd.ms-powerpoint.presentation.macroenabled":
        return {
          ext: "pptm",
          mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
        };
      case "application/vnd.ms-visio.drawing":
        return {
          ext: "vsdx",
          mime: "application/vnd.visio"
        };
      case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
        return {
          ext: "3mf",
          mime: "model/3mf"
        };
      default:
    }
  };
  _check = function(buffer, headers, options) {
    options = {
      offset: 0,
      ...options
    };
    for (const [index, header] of headers.entries()) {
      if (options.mask) {
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
    return true;
  };
  reasonableDetectionSizeInBytes = 4100;
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
  supportedMimeTypes: () => {
    {
      return supportedMimeTypes;
    }
  },
  supportedExtensions: () => {
    {
      return supportedExtensions;
    }
  },
  fileTypeStream: () => {
    {
      return fileTypeStream;
    }
  },
  fileTypeFromTokenizer: () => {
    {
      return fileTypeFromTokenizer;
    }
  },
  fileTypeFromStream: () => {
    {
      return fileTypeFromStream;
    }
  },
  fileTypeFromFile: () => {
    {
      return fileTypeFromFile;
    }
  },
  fileTypeFromBuffer: () => {
    {
      return fileTypeFromBuffer;
    }
  },
  fileTypeFromBlob: () => {
    {
      return fileTypeFromBlob;
    }
  },
  FileTypeParser: () => {
    {
      return FileTypeParser2;
    }
  }
});
import {ReadableStream as WebReadableStream} from "stream/web";
import {pipeline, PassThrough, Readable} from "stream";
async function fileTypeFromFile(path, options) {
  return new FileTypeParser2(options).fromFile(path, options);
}
async function fileTypeFromStream(stream7, options) {
  return new FileTypeParser2(options).fromStream(stream7);
}
async function fileTypeStream(readableStream, options = {}) {
  return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}

class FileTypeParser2 extends FileTypeParser {
  async fromStream(stream7) {
    const tokenizer = await (stream7 instanceof WebReadableStream ? fromWebStream(stream7, this.tokenizerOptions) : fromStream2(stream7, this.tokenizerOptions));
    try {
      return await super.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async fromFile(path) {
    const tokenizer = await fromFile(path);
    try {
      return await super.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(readableStream, options = {}) {
    if (!(readableStream instanceof Readable)) {
      return super.toDetectionStream(readableStream, options);
    }
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    return new Promise((resolve, reject) => {
      readableStream.on("error", reject);
      readableStream.once("readable", () => {
        (async () => {
          try {
            const pass = new PassThrough;
            const outputStream = pipeline ? pipeline(readableStream, pass, () => {
            }) : readableStream.pipe(pass);
            const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
            try {
              pass.fileType = await this.fromBuffer(chunk);
            } catch (error23) {
              if (error23 instanceof EndOfStreamError) {
                pass.fileType = undefined;
              } else {
                reject(error23);
              }
            }
            resolve(outputStream);
          } catch (error23) {
            reject(error23);
          }
        })();
      });
    });
  }
}
var init_file_type = __esm(() => {
  init_lib();
  init_core2();
});

// node_modules/clone/clone.js
var require_clone = __commonJS((exports, module) => {
  var clone11 = function() {
    function _instanceof(obj, type54) {
      return type54 != null && obj instanceof type54;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_2) {
      nativeMap = function() {
      };
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_2) {
      nativeSet = function() {
      };
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_2) {
      nativePromise = function() {
      };
    }
    function clone12(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 === 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap;
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet;
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function(resolve, reject) {
            parent2.then(function(value26) {
              resolve(_clone(value26, depth2 - 1));
            }, function(err2) {
              reject(_clone(err2, depth2 - 1));
            });
          });
        } else if (clone12.__isArray(parent2)) {
          child = [];
        } else if (clone12.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (clone12.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function(value26, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value26, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function(value26) {
            var entryChild = _clone(value26, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols67 = Object.getOwnPropertySymbols(parent2);
          for (var i = 0;i < symbols67.length; i++) {
            var symbol2 = symbols67[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol2);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol2] = _clone(parent2[symbol2], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol2, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i = 0;i < allPropertyNames.length; i++) {
            var propertyName = allPropertyNames[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone12.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
      var c = function() {
      };
      c.prototype = parent;
      return new c;
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone12.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone12.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone12.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone12.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = "";
      if (re.global)
        flags += "g";
      if (re.ignoreCase)
        flags += "i";
      if (re.multiline)
        flags += "m";
      return flags;
    }
    clone12.__getRegExpFlags = __getRegExpFlags;
    return clone12;
  }();
  if (typeof module === "object" && exports) {
    module.exports = clone11;
  }
});

// node_modules/node-cache/lib/node_cache.js
var require_node_cache = __commonJS((exports, module) => {
  (function() {
    var EventEmitter, NodeCache, clone11, splice = [].splice, boundMethodCheck = function(instance, Constructor2) {
      if (!(instance instanceof Constructor2)) {
        throw new Error("Bound instance method accessed before binding");
      }
    }, indexOf2 = [].indexOf;
    clone11 = require_clone();
    EventEmitter = import.meta.require("events").EventEmitter;
    module.exports = NodeCache = function() {

      class NodeCache2 extends EventEmitter {
        constructor(options = {}) {
          super();
          this.get = this.get.bind(this);
          this.mget = this.mget.bind(this);
          this.set = this.set.bind(this);
          this.mset = this.mset.bind(this);
          this.del = this.del.bind(this);
          this.take = this.take.bind(this);
          this.ttl = this.ttl.bind(this);
          this.getTtl = this.getTtl.bind(this);
          this.keys = this.keys.bind(this);
          this.has = this.has.bind(this);
          this.getStats = this.getStats.bind(this);
          this.flushAll = this.flushAll.bind(this);
          this.flushStats = this.flushStats.bind(this);
          this.close = this.close.bind(this);
          this._checkData = this._checkData.bind(this);
          this._check = this._check.bind(this);
          this._isInvalidKey = this._isInvalidKey.bind(this);
          this._wrap = this._wrap.bind(this);
          this._getValLength = this._getValLength.bind(this);
          this._error = this._error.bind(this);
          this._initErrors = this._initErrors.bind(this);
          this.options = options;
          this._initErrors();
          this.data = {};
          this.options = Object.assign({
            forceString: false,
            objectValueSize: 80,
            promiseValueSize: 80,
            arrayValueSize: 40,
            stdTTL: 0,
            checkperiod: 600,
            useClones: true,
            deleteOnExpire: true,
            enableLegacyCallbacks: false,
            maxKeys: -1
          }, this.options);
          if (this.options.enableLegacyCallbacks) {
            console.warn("WARNING! node-cache legacy callback support will drop in v6.x");
            ["get", "mget", "set", "del", "ttl", "getTtl", "keys", "has"].forEach((methodKey) => {
              var oldMethod;
              oldMethod = this[methodKey];
              this[methodKey] = function(...args) {
                var cb, err2, ref6, res;
                ref6 = args, [...args] = ref6, [cb] = splice.call(args, -1);
                if (typeof cb === "function") {
                  try {
                    res = oldMethod(...args);
                    cb(null, res);
                  } catch (error1) {
                    err2 = error1;
                    cb(err2);
                  }
                } else {
                  return oldMethod(...args, cb);
                }
              };
            });
          }
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.validKeyTypes = ["string", "number"];
          this._checkData();
          return;
        }
        get(key) {
          var _ret, err2;
          boundMethodCheck(this, NodeCache2);
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            this.stats.hits++;
            _ret = this._unwrap(this.data[key]);
            return _ret;
          } else {
            this.stats.misses++;
            return;
          }
        }
        mget(keys) {
          var _err, err2, i, key, len, oRet;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            _err = this._error("EKEYSTYPE");
            throw _err;
          }
          oRet = {};
          for (i = 0, len = keys.length;i < len; i++) {
            key = keys[i];
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              this.stats.hits++;
              oRet[key] = this._unwrap(this.data[key]);
            } else {
              this.stats.misses++;
            }
          }
          return oRet;
        }
        set(key, value26, ttl) {
          var _err, err2, existent;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          if (this.options.forceString && false === "string") {
            value26 = JSON.stringify(value26);
          }
          if (ttl == null) {
            ttl = this.options.stdTTL;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          existent = false;
          if (this.data[key]) {
            existent = true;
            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
          }
          this.data[key] = this._wrap(value26, ttl);
          this.stats.vsize += this._getValLength(value26);
          if (!existent) {
            this.stats.ksize += this._getKeyLength(key);
            this.stats.keys++;
          }
          this.emit("set", key, value26);
          return true;
        }
        mset(keyValueSet) {
          var _err, err2, i, j, key, keyValuePair, len, len1, ttl, val;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          for (i = 0, len = keyValueSet.length;i < len; i++) {
            keyValuePair = keyValueSet[i];
            ({ key, val, ttl } = keyValuePair);
            if (ttl && typeof ttl !== "number") {
              _err = this._error("ETTLTYPE");
              throw _err;
            }
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
          }
          for (j = 0, len1 = keyValueSet.length;j < len1; j++) {
            keyValuePair = keyValueSet[j];
            ({ key, val, ttl } = keyValuePair);
            this.set(key, val, ttl);
          }
          return true;
        }
        del(keys) {
          var delCount, err2, i, key, len, oldVal;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            keys = [keys];
          }
          delCount = 0;
          for (i = 0, len = keys.length;i < len; i++) {
            key = keys[i];
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
            if (this.data[key] != null) {
              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
              this.stats.ksize -= this._getKeyLength(key);
              this.stats.keys--;
              delCount++;
              oldVal = this.data[key];
              delete this.data[key];
              this.emit("del", key, oldVal.v);
            }
          }
          return delCount;
        }
        take(key) {
          var _ret;
          boundMethodCheck(this, NodeCache2);
          _ret = this.get(key);
          if (_ret != null) {
            this.del(key);
          }
          return _ret;
        }
        ttl(key, ttl) {
          var err2;
          boundMethodCheck(this, NodeCache2);
          ttl || (ttl = this.options.stdTTL);
          if (!key) {
            return false;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            if (ttl >= 0) {
              this.data[key] = this._wrap(this.data[key].v, ttl, false);
            } else {
              this.del(key);
            }
            return true;
          } else {
            return false;
          }
        }
        getTtl(key) {
          var _ttl, err2;
          boundMethodCheck(this, NodeCache2);
          if (!key) {
            return;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            _ttl = this.data[key].t;
            return _ttl;
          } else {
            return;
          }
        }
        keys() {
          var _keys;
          boundMethodCheck(this, NodeCache2);
          _keys = Object.keys(this.data);
          return _keys;
        }
        has(key) {
          var _exists;
          boundMethodCheck(this, NodeCache2);
          _exists = this.data[key] != null && this._check(key, this.data[key]);
          return _exists;
        }
        getStats() {
          boundMethodCheck(this, NodeCache2);
          return this.stats;
        }
        flushAll(_startPeriod = true) {
          boundMethodCheck(this, NodeCache2);
          this.data = {};
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this._killCheckPeriod();
          this._checkData(_startPeriod);
          this.emit("flush");
        }
        flushStats() {
          boundMethodCheck(this, NodeCache2);
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.emit("flush_stats");
        }
        close() {
          boundMethodCheck(this, NodeCache2);
          this._killCheckPeriod();
        }
        _checkData(startPeriod = true) {
          var key, ref6, value26;
          boundMethodCheck(this, NodeCache2);
          ref6 = this.data;
          for (key in ref6) {
            value26 = ref6[key];
            this._check(key, value26);
          }
          if (startPeriod && this.options.checkperiod > 0) {
            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);
            if (this.checkTimeout != null && this.checkTimeout.unref != null) {
              this.checkTimeout.unref();
            }
          }
        }
        _killCheckPeriod() {
          if (this.checkTimeout != null) {
            return clearTimeout(this.checkTimeout);
          }
        }
        _check(key, data) {
          var _retval;
          boundMethodCheck(this, NodeCache2);
          _retval = true;
          if (data.t !== 0 && data.t < Date.now()) {
            if (this.options.deleteOnExpire) {
              _retval = false;
              this.del(key);
            }
            this.emit("expired", key, this._unwrap(data));
          }
          return _retval;
        }
        _isInvalidKey(key) {
          var ref6;
          boundMethodCheck(this, NodeCache2);
          if (ref6 = typeof key, indexOf2.call(this.validKeyTypes, ref6) < 0) {
            return this._error("EKEYTYPE", {
              type: typeof key
            });
          }
        }
        _wrap(value26, ttl, asClone = true) {
          var livetime, now, oReturn, ttlMultiplicator;
          boundMethodCheck(this, NodeCache2);
          if (!this.options.useClones) {
            asClone = false;
          }
          now = Date.now();
          livetime = 0;
          ttlMultiplicator = 1000;
          if (ttl === 0) {
            livetime = 0;
          } else if (ttl) {
            livetime = now + ttl * ttlMultiplicator;
          } else {
            if (this.options.stdTTL === 0) {
              livetime = this.options.stdTTL;
            } else {
              livetime = now + this.options.stdTTL * ttlMultiplicator;
            }
          }
          return oReturn = {
            t: livetime,
            v: asClone ? clone11(value26) : value26
          };
        }
        _unwrap(value26, asClone = true) {
          if (!this.options.useClones) {
            asClone = false;
          }
          if (value26.v != null) {
            if (asClone) {
              return clone11(value26.v);
            } else {
              return value26.v;
            }
          }
          return null;
        }
        _getKeyLength(key) {
          return key.toString().length;
        }
        _getValLength(value26) {
          boundMethodCheck(this, NodeCache2);
          if (typeof value26 === "string") {
            return value26.length;
          } else if (this.options.forceString) {
            return JSON.stringify(value26).length;
          } else if (Array.isArray(value26)) {
            return this.options.arrayValueSize * value26.length;
          } else if (typeof value26 === "number") {
            return 8;
          } else if (typeof (value26 != null ? value26.then : undefined) === "function") {
            return this.options.promiseValueSize;
          } else if (typeof Buffer !== "undefined" && Buffer !== null ? Buffer.isBuffer(value26) : undefined) {
            return value26.length;
          } else if (value26 != null && typeof value26 === "object") {
            return this.options.objectValueSize * Object.keys(value26).length;
          } else if (typeof value26 === "boolean") {
            return 8;
          } else {
            return 0;
          }
        }
        _error(type54, data = {}) {
          var error23;
          boundMethodCheck(this, NodeCache2);
          error23 = new Error;
          error23.name = type54;
          error23.errorcode = type54;
          error23.message = this.ERRORS[type54] != null ? this.ERRORS[type54](data) : "-";
          error23.data = data;
          return error23;
        }
        _initErrors() {
          var _errMsg, _errT, ref6;
          boundMethodCheck(this, NodeCache2);
          this.ERRORS = {};
          ref6 = this._ERRORS;
          for (_errT in ref6) {
            _errMsg = ref6[_errT];
            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);
          }
        }
        createErrorMessage(errMsg) {
          return function(args) {
            return errMsg.replace("__key", args.type);
          };
        }
      }
      NodeCache2.prototype._ERRORS = {
        ENOTFOUND: "Key `__key` not found",
        ECACHEFULL: "Cache max keys amount exceeded",
        EKEYTYPE: "The key argument has to be of type `string` or `number`. Found: `__key`",
        EKEYSTYPE: "The keys argument has to be an array.",
        ETTLTYPE: "The ttl argument has to be a number."
      };
      return NodeCache2;
    }.call(this);
  }).call(exports);
});

// node_modules/node-cache/index.js
var require_node_cache2 = __commonJS((exports, module) => {
  (function() {
    var exports2;
    exports2 = module.exports = require_node_cache();
    exports2.version = "5.1.2";
  }).call(exports);
});

// node_modules/logform/format.js
var require_format = __commonJS((exports, module) => {
  class InvalidFormatError extends Error {
    constructor(formatFn) {
      super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}\n`);
      Error.captureStackTrace(this, InvalidFormatError);
    }
  }
  module.exports = (formatFn) => {
    if (formatFn.length > 2) {
      throw new InvalidFormatError(formatFn);
    }
    function Format2(options = {}) {
      this.options = options;
    }
    Format2.prototype.transform = formatFn;
    function createFormatWrap(opts) {
      return new Format2(opts);
    }
    createFormatWrap.Format = Format2;
    return createFormatWrap;
  };
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles = {};
  module["exports"] = styles;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv || [];
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(stream7) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream7 && !stream7.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env3) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env3;
      }) || env3.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env3) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env3) {
      var version = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env3.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env3.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env3) {
      return 1;
    }
    if (env3.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream7) {
    var level = supportsColor(stream7);
    return translateLevel(level);
  };
  var os = import.meta.require("os");
  var hasFlag = require_has_flag();
  var env3 = process.env;
  var forceColor = undefined;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env3) {
    forceColor = env3.FORCE_COLOR.length === 0 || parseInt(env3.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i) {
        bool = i === character;
      });
      return bool;
    }
    function heComes(text2, options2) {
      var result = "";
      var counts;
      var l;
      options2 = options2 || {};
      options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
      options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
      options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
      options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (isChar(l)) {
          continue;
        }
        result = result + text2[l];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options2.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index = arr[d];
          for (var i = 0;i <= counts[index]; i++) {
            if (options2[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options);
  };
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      if (letter === " ")
        return letter;
      switch (i % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i++ % rainbowColors.length]](letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var build = function(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util2.inspect(arg);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    while (i--) {
      var code = ansiStyles[nestedStyles[i]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  };
  var init = function() {
    var ret2 = {};
    Object.keys(styles).forEach(function(name) {
      ret2[name] = {
        get: function() {
          return build([name]);
        }
      };
    });
    return ret2;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util2 = import.meta.require("util");
  var ansiStyles = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles[style];
    if (!styleMap && style in colors) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles = function() {
    var ret2 = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret2[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret2;
  }();
  var proto = defineProps(function colors() {
  }, styles);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller\'s) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + \'/../themes/generic-logging.js\'); The new syntax looks like colors.setTheme(require(__dirname + \'/../themes/generic-logging.js\'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i in theme[style2]) {
              out = colors[theme[style2][i]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var sequencer = function sequencer(map4, str) {
    var exploded = str.split("");
    exploded = exploded.map(map4);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america()(colors);
  colors.maps.zebra = require_zebra()(colors);
  colors.maps.rainbow = require_rainbow()(colors);
  colors.maps.random = require_random()(colors);
  for (map3 in colors.maps) {
    (function(map4) {
      colors[map4] = function(str) {
        return sequencer(colors.maps[map4], str);
      };
    })(map3);
  }
  var map3;
  defineProps(colors, init());
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
  };
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
  };
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS((exports) => {
  exports.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
  };
  exports.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
  };
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "cli", {
    value: require_cli()
  });
  Object.defineProperty(exports, "npm", {
    value: require_npm()
  });
  Object.defineProperty(exports, "syslog", {
    value: require_syslog()
  });
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS((exports) => {
  Object.defineProperty(exports, "LEVEL", {
    value: Symbol.for("level")
  });
  Object.defineProperty(exports, "MESSAGE", {
    value: Symbol.for("message")
  });
  Object.defineProperty(exports, "SPLAT", {
    value: Symbol.for("splat")
  });
  Object.defineProperty(exports, "configs", {
    value: require_config()
  });
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var { LEVEL, MESSAGE } = require_triple_beam();
  colors.enabled = true;
  var hasSpace = /\s+/;

  class Colorizer {
    constructor(opts = {}) {
      if (opts.colors) {
        this.addColors(opts.colors);
      }
      this.options = opts;
    }
    static addColors(clrs) {
      const nextColors = Object.keys(clrs).reduce((acc, level) => {
        acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
        return acc;
      }, {});
      Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
      return Colorizer.allColors;
    }
    addColors(clrs) {
      return Colorizer.addColors(clrs);
    }
    colorize(lookup, level, message) {
      if (typeof message === "undefined") {
        message = level;
      }
      if (!Array.isArray(Colorizer.allColors[lookup])) {
        return colors[Colorizer.allColors[lookup]](message);
      }
      for (let i = 0, len = Colorizer.allColors[lookup].length;i < len; i++) {
        message = colors[Colorizer.allColors[lookup][i]](message);
      }
      return message;
    }
    transform(info, opts) {
      if (opts.all && typeof info[MESSAGE] === "string") {
        info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
      }
      if (opts.level || opts.all || !opts.message) {
        info.level = this.colorize(info[LEVEL], info.level);
      }
      if (opts.all || opts.message) {
        info.message = this.colorize(info[LEVEL], info.level, info.message);
      }
      return info;
    }
  }
  module.exports = (opts) => new Colorizer(opts);
  module.exports.Colorizer = module.exports.Format = Colorizer;
});

// node_modules/logform/levels.js
var require_levels = __commonJS((exports, module) => {
  var { Colorizer } = require_colorize();
  module.exports = (config) => {
    Colorizer.addColors(config.colors || config);
    return config;
  };
});

// node_modules/logform/align.js
var require_align = __commonJS((exports, module) => {
  var format = require_format();
  module.exports = format((info) => {
    info.message = `\t${info.message}`;
    return info;
  });
});

// node_modules/logform/errors.js
var require_errors = __commonJS((exports, module) => {
  var format = require_format();
  var { LEVEL, MESSAGE } = require_triple_beam();
  module.exports = format((einfo, { stack, cause }) => {
    if (einfo instanceof Error) {
      const info = Object.assign({}, einfo, {
        level: einfo.level,
        [LEVEL]: einfo[LEVEL] || einfo.level,
        message: einfo.message,
        [MESSAGE]: einfo[MESSAGE] || einfo.message
      });
      if (stack)
        info.stack = einfo.stack;
      if (cause)
        info.cause = einfo.cause;
      return info;
    }
    if (!(einfo.message instanceof Error))
      return einfo;
    const err2 = einfo.message;
    Object.assign(einfo, err2);
    einfo.message = err2.message;
    einfo[MESSAGE] = err2.message;
    if (stack)
      einfo.stack = err2.stack;
    if (cause)
      einfo.cause = err2.cause;
    return einfo;
  });
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS((exports, module) => {
  var { configs, LEVEL, MESSAGE } = require_triple_beam();

  class Padder {
    constructor(opts = { levels: configs.npm.levels }) {
      this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
      this.options = opts;
    }
    static getLongestLevel(levels) {
      const lvls = Object.keys(levels).map((level) => level.length);
      return Math.max(...lvls);
    }
    static paddingForLevel(level, filler, maxLength) {
      const targetLen = maxLength + 1 - level.length;
      const rep = Math.floor(targetLen / filler.length);
      const padding = `${filler}${filler.repeat(rep)}`;
      return padding.slice(0, targetLen);
    }
    static paddingForLevels(levels, filler = " ") {
      const maxLength = Padder.getLongestLevel(levels);
      return Object.keys(levels).reduce((acc, level) => {
        acc[level] = Padder.paddingForLevel(level, filler, maxLength);
        return acc;
      }, {});
    }
    transform(info, opts) {
      info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
      if (info[MESSAGE]) {
        info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
      }
      return info;
    }
  }
  module.exports = (opts) => new Padder(opts);
  module.exports.Padder = module.exports.Format = Padder;
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS((exports, module) => {
  var { Colorizer } = require_colorize();
  var { Padder } = require_pad_levels();
  var { configs, MESSAGE } = require_triple_beam();

  class CliFormat {
    constructor(opts = {}) {
      if (!opts.levels) {
        opts.levels = configs.cli.levels;
      }
      this.colorizer = new Colorizer(opts);
      this.padder = new Padder(opts);
      this.options = opts;
    }
    transform(info, opts) {
      this.colorizer.transform(this.padder.transform(info, opts), opts);
      info[MESSAGE] = `${info.level}:${info.message}`;
      return info;
    }
  }
  module.exports = (opts) => new CliFormat(opts);
  module.exports.Format = CliFormat;
});

// node_modules/logform/combine.js
var require_combine = __commonJS((exports, module) => {
  var cascade = function(formats) {
    if (!formats.every(isValidFormat)) {
      return;
    }
    return (info) => {
      let obj = info;
      for (let i = 0;i < formats.length; i++) {
        obj = formats[i].transform(obj, formats[i].options);
        if (!obj) {
          return false;
        }
      }
      return obj;
    };
  };
  var isValidFormat = function(fmt) {
    if (typeof fmt.transform !== "function") {
      throw new Error([
        "No transform function found on format. Did you create a format instance?",
        "const myFormat = format(formatFn);",
        "const instance = myFormat();"
      ].join("\n"));
    }
    return true;
  };
  var format = require_format();
  module.exports = (...formats) => {
    const combinedFormat = format(cascade(formats));
    const instance = combinedFormat();
    instance.Format = combinedFormat.Format;
    return instance;
  };
  module.exports.cascade = cascade;
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var strEscape = function(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  };
  var sort = function(array3, comparator) {
    if (array3.length > 200 || comparator) {
      return array3.sort(comparator);
    }
    for (let i = 1;i < array3.length; i++) {
      const currentValue = array3[i];
      let position = i;
      while (position !== 0 && array3[position - 1] > currentValue) {
        array3[position] = array3[position - 1];
        position--;
      }
      array3[position] = currentValue;
    }
    return array3;
  };
  var isTypedArrayWithEntries = function(value26) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value26) !== undefined && value26.length !== 0;
  };
  var stringifyTypedArray = function(array3, separator, maximumBreadth) {
    if (array3.length < maximumBreadth) {
      maximumBreadth = array3.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array3[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array3[i]}`;
    }
    return res;
  };
  var getCircularValueOption = function(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  };
  var getDeterministicOption = function(options) {
    let value26;
    if (hasOwnProperty.call(options, "deterministic")) {
      value26 = options.deterministic;
      if (typeof value26 !== "boolean" && typeof value26 !== "function") {
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      }
    }
    return value26 === undefined ? true : value26;
  };
  var getBooleanOption = function(options, key) {
    let value26;
    if (hasOwnProperty.call(options, key)) {
      value26 = options[key];
      if (typeof value26 !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value26 === undefined ? true : value26;
  };
  var getPositiveIntegerOption = function(options, key) {
    let value26;
    if (hasOwnProperty.call(options, key)) {
      value26 = options[key];
      if (typeof value26 !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value26)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value26 < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value26 === undefined ? Infinity : value26;
  };
  var getItemCount = function(number5) {
    if (number5 === 1) {
      return "1 item";
    }
    return `${number5} items`;
  };
  var getUniqueReplacerSet = function(replacerArray) {
    const replacerSet = new Set;
    for (const value26 of replacerArray) {
      if (typeof value26 === "string" || typeof value26 === "number") {
        replacerSet.add(String(value26));
      }
    }
    return replacerSet;
  };
  var getStrictOption = function(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value26 = options.strict;
      if (typeof value26 !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value26) {
        return (value27) => {
          let message = `Object can not safely be stringified. Received type ${typeof value27}`;
          if (typeof value27 !== "function")
            message += ` (${value27.toString()})`;
          throw new Error(message);
        };
      }
    }
  };
  var configure = function(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint3 = getBooleanOption(options, "bigint");
    const deterministic = getDeterministicOption(options);
    const comparator = typeof deterministic === "function" ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value26 = parent[key];
      if (typeof value26 === "object" && value26 !== null && typeof value26.toJSON === "function") {
        value26 = value26.toJSON(key);
      }
      value26 = replacer.call(parent, key, value26);
      switch (typeof value26) {
        case "string":
          return strEscape(value26);
        case "object": {
          if (value26 === null) {
            return "null";
          }
          if (stack.indexOf(value26) !== -1) {
            return circularValue;
          }
          let res = "";
          let join2 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value26)) {
            if (value26.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value26);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value26.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value26, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyFnReplacer(String(i), value26, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value26.length - 1 > maximumBreadth) {
              const removedKeys = value26.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value26);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value26)) {
            keys = sort(keys, comparator);
          }
          stack.push(value26);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value26, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value26) ? String(value26) : fail ? fail(value26) : "null";
        case "boolean":
          return value26 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint3) {
            return String(value26);
          }
        default:
          return fail ? fail(value26) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value26, stack, replacer, spacer, indentation) {
      if (typeof value26 === "object" && value26 !== null && typeof value26.toJSON === "function") {
        value26 = value26.toJSON(key);
      }
      switch (typeof value26) {
        case "string":
          return strEscape(value26);
        case "object": {
          if (value26 === null) {
            return "null";
          }
          if (stack.indexOf(value26) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join2 = ",";
          if (Array.isArray(value26)) {
            if (value26.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value26);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value26.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value26[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyArrayReplacer(String(i), value26[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value26.length - 1 > maximumBreadth) {
              const removedKeys = value26.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value26);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value26[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value26) ? String(value26) : fail ? fail(value26) : "null";
        case "boolean":
          return value26 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint3) {
            return String(value26);
          }
        default:
          return fail ? fail(value26) : undefined;
      }
    }
    function stringifyIndent(key, value26, stack, spacer, indentation) {
      switch (typeof value26) {
        case "string":
          return strEscape(value26);
        case "object": {
          if (value26 === null) {
            return "null";
          }
          if (typeof value26.toJSON === "function") {
            value26 = value26.toJSON(key);
            if (typeof value26 !== "object") {
              return stringifyIndent(key, value26, stack, spacer, indentation);
            }
            if (value26 === null) {
              return "null";
            }
          }
          if (stack.indexOf(value26) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value26)) {
            if (value26.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value26);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join3 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value26.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value26[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join3;
            }
            const tmp = stringifyIndent(String(i), value26[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value26.length - 1 > maximumBreadth) {
              const removedKeys = value26.length - maximumBreadth - 1;
              res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value26);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join2 = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value26)) {
            res += stringifyTypedArray(value26, join2, maximumBreadth);
            keys = keys.slice(value26.length);
            maximumPropertiesToStringify -= value26.length;
            separator = join2;
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value26);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value26[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value26) ? String(value26) : fail ? fail(value26) : "null";
        case "boolean":
          return value26 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint3) {
            return String(value26);
          }
        default:
          return fail ? fail(value26) : undefined;
      }
    }
    function stringifySimple(key, value26, stack) {
      switch (typeof value26) {
        case "string":
          return strEscape(value26);
        case "object": {
          if (value26 === null) {
            return "null";
          }
          if (typeof value26.toJSON === "function") {
            value26 = value26.toJSON(key);
            if (typeof value26 !== "object") {
              return stringifySimple(key, value26, stack);
            }
            if (value26 === null) {
              return "null";
            }
          }
          if (stack.indexOf(value26) !== -1) {
            return circularValue;
          }
          let res = "";
          const hasLength = value26.length !== undefined;
          if (hasLength && Array.isArray(value26)) {
            if (value26.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value26);
            const maximumValuesToStringify = Math.min(value26.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value26[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value26[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value26.length - 1 > maximumBreadth) {
              const removedKeys = value26.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value26);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (hasLength && isTypedArrayWithEntries(value26)) {
            res += stringifyTypedArray(value26, ",", maximumBreadth);
            keys = keys.slice(value26.length);
            maximumPropertiesToStringify -= value26.length;
            separator = ",";
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value26);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value26[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value26) ? String(value26) : fail ? fail(value26) : "null";
        case "boolean":
          return value26 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint3) {
            return String(value26);
          }
        default:
          return fail ? fail(value26) : undefined;
      }
    }
    function stringify2(value26, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value26 }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value26, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value26, [], spacer, "");
        }
      }
      return stringifySimple("", value26, []);
    }
    return stringify2;
  };
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// node_modules/logform/json.js
var require_json = __commonJS((exports, module) => {
  var replacer = function(key, value26) {
    if (typeof value26 === "bigint")
      return value26.toString();
    return value26;
  };
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  var stringify = require_safe_stable_stringify();
  module.exports = format((info, opts) => {
    const jsonStringify = stringify.configure(opts);
    info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
    return info;
  });
});

// node_modules/logform/label.js
var require_label = __commonJS((exports, module) => {
  var format = require_format();
  module.exports = format((info, opts) => {
    if (opts.message) {
      info.message = `[${opts.label}] ${info.message}`;
      return info;
    }
    info.label = opts.label;
    return info;
  });
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS((exports, module) => {
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format((info) => {
    const logstash = {};
    if (info.message) {
      logstash["@message"] = info.message;
      delete info.message;
    }
    if (info.timestamp) {
      logstash["@timestamp"] = info.timestamp;
      delete info.timestamp;
    }
    logstash["@fields"] = info;
    info[MESSAGE] = jsonStringify(logstash);
    return info;
  });
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS((exports, module) => {
  var fillExcept = function(info, fillExceptKeys, metadataKey) {
    const savedKeys = fillExceptKeys.reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    const metadata = Object.keys(info).reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    Object.assign(info, savedKeys, {
      [metadataKey]: metadata
    });
    return info;
  };
  var fillWith = function(info, fillWithKeys, metadataKey) {
    info[metadataKey] = fillWithKeys.reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    return info;
  };
  var format = require_format();
  module.exports = format((info, opts = {}) => {
    let metadataKey = "metadata";
    if (opts.key) {
      metadataKey = opts.key;
    }
    let fillExceptKeys = [];
    if (!opts.fillExcept && !opts.fillWith) {
      fillExceptKeys.push("level");
      fillExceptKeys.push("message");
    }
    if (opts.fillExcept) {
      fillExceptKeys = opts.fillExcept;
    }
    if (fillExceptKeys.length > 0) {
      return fillExcept(info, fillExceptKeys, metadataKey);
    }
    if (opts.fillWith) {
      return fillWith(info, opts.fillWith, metadataKey);
    }
    return info;
  });
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS((exports, module) => {
  var format = require_format();
  var ms = require_ms();
  module.exports = format((info) => {
    const curr = +new Date;
    exports.diff = curr - (exports.prevTime || curr);
    exports.prevTime = curr;
    info.ms = `+${ms(exports.diff)}`;
    return info;
  });
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS((exports, module) => {
  var inspect = import.meta.require("util").inspect;
  var format = require_format();
  var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
  module.exports = format((info, opts = {}) => {
    const stripped = Object.assign({}, info);
    delete stripped[LEVEL];
    delete stripped[MESSAGE];
    delete stripped[SPLAT];
    info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
    return info;
  });
});

// node_modules/logform/printf.js
var require_printf = __commonJS((exports, module) => {
  var { MESSAGE } = require_triple_beam();

  class Printf {
    constructor(templateFn) {
      this.template = templateFn;
    }
    transform(info) {
      info[MESSAGE] = this.template(info);
      return info;
    }
  }
  module.exports = (opts) => new Printf(opts);
  module.exports.Printf = module.exports.Format = Printf;
});

// node_modules/logform/simple.js
var require_simple = __commonJS((exports, module) => {
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format((info) => {
    const stringifiedRest = jsonStringify(Object.assign({}, info, {
      level: undefined,
      message: undefined,
      splat: undefined
    }));
    const padding = info.padding && info.padding[info.level] || "";
    if (stringifiedRest !== "{}") {
      info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
    } else {
      info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
    }
    return info;
  });
});

// node_modules/logform/splat.js
var require_splat = __commonJS((exports, module) => {
  var util2 = import.meta.require("util");
  var { SPLAT } = require_triple_beam();
  var formatRegExp = /%[scdjifoO%]/g;
  var escapedPercent = /%%/g;

  class Splatter {
    constructor(opts) {
      this.options = opts;
    }
    _splat(info, tokens) {
      const msg = info.message;
      const splat = info[SPLAT] || info.splat || [];
      const percents = msg.match(escapedPercent);
      const escapes = percents && percents.length || 0;
      const expectedSplat = tokens.length - escapes;
      const extraSplat = expectedSplat - splat.length;
      const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
      const metalen = metas.length;
      if (metalen) {
        for (let i = 0;i < metalen; i++) {
          Object.assign(info, metas[i]);
        }
      }
      info.message = util2.format(msg, ...splat);
      return info;
    }
    transform(info) {
      const msg = info.message;
      const splat = info[SPLAT] || info.splat;
      if (!splat || !splat.length) {
        return info;
      }
      const tokens = msg && msg.match && msg.match(formatRegExp);
      if (!tokens && (splat || splat.length)) {
        const metas = splat.length > 1 ? splat.splice(0) : splat;
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0;i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        return info;
      }
      if (tokens) {
        return this._splat(info, tokens);
      }
      return info;
    }
  }
  module.exports = (opts) => new Splatter(opts);
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
  })(exports, function(exports2) {
    var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    var twoDigitsOptional = "\\d\\d?";
    var twoDigits = "\\d\\d";
    var threeDigits = "\\d{3}";
    var fourDigits = "\\d{4}";
    var word = "[^\\s]+";
    var literal13 = /\[([^]*?)\]/gm;
    function shorten(arr, sLen) {
      var newArr = [];
      for (var i = 0, len = arr.length;i < len; i++) {
        newArr.push(arr[i].substr(0, sLen));
      }
      return newArr;
    }
    var monthUpdate = function(arrName) {
      return function(v, i18n) {
        var lowerCaseArr = i18n[arrName].map(function(v2) {
          return v2.toLowerCase();
        });
        var index = lowerCaseArr.indexOf(v.toLowerCase());
        if (index > -1) {
          return index;
        }
        return null;
      };
    };
    function assign(origObj) {
      var args = [];
      for (var _i = 1;_i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      for (var _a2 = 0, args_1 = args;_a2 < args_1.length; _a2++) {
        var obj = args_1[_a2];
        for (var key in obj) {
          origObj[key] = obj[key];
        }
      }
      return origObj;
    }
    var dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    var monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthNamesShort = shorten(monthNames, 3);
    var dayNamesShort = shorten(dayNames, 3);
    var defaultI18n = {
      dayNamesShort,
      dayNames,
      monthNamesShort,
      monthNames,
      amPm: ["am", "pm"],
      DoFn: function(dayOfMonth) {
        return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
      }
    };
    var globalI18n = assign({}, defaultI18n);
    var setGlobalDateI18n = function(i18n) {
      return globalI18n = assign(globalI18n, i18n);
    };
    var regexEscape = function(str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    };
    var pad = function(val, len) {
      if (len === undefined) {
        len = 2;
      }
      val = String(val);
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    };
    var formatFlags = {
      D: function(dateObj) {
        return String(dateObj.getDate());
      },
      DD: function(dateObj) {
        return pad(dateObj.getDate());
      },
      Do: function(dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
      },
      d: function(dateObj) {
        return String(dateObj.getDay());
      },
      dd: function(dateObj) {
        return pad(dateObj.getDay());
      },
      ddd: function(dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function(dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
      },
      M: function(dateObj) {
        return String(dateObj.getMonth() + 1);
      },
      MM: function(dateObj) {
        return pad(dateObj.getMonth() + 1);
      },
      MMM: function(dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function(dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function(dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function(dateObj) {
        return pad(dateObj.getFullYear(), 4);
      },
      h: function(dateObj) {
        return String(dateObj.getHours() % 12 || 12);
      },
      hh: function(dateObj) {
        return pad(dateObj.getHours() % 12 || 12);
      },
      H: function(dateObj) {
        return String(dateObj.getHours());
      },
      HH: function(dateObj) {
        return pad(dateObj.getHours());
      },
      m: function(dateObj) {
        return String(dateObj.getMinutes());
      },
      mm: function(dateObj) {
        return pad(dateObj.getMinutes());
      },
      s: function(dateObj) {
        return String(dateObj.getSeconds());
      },
      ss: function(dateObj) {
        return pad(dateObj.getSeconds());
      },
      S: function(dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function(dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function(dateObj) {
        return pad(dateObj.getMilliseconds(), 3);
      },
      a: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
      },
      ZZ: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
      },
      Z: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
      }
    };
    var monthParse = function(v) {
      return +v - 1;
    };
    var emptyDigits = [null, twoDigitsOptional];
    var emptyWord = [null, word];
    var amPm = [
      "isPm",
      word,
      function(v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
          return 0;
        } else if (val === i18n.amPm[1]) {
          return 1;
        }
        return null;
      }
    ];
    var timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function(v) {
        var parts = (v + "").match(/([+-]|\d\d)/gi);
        if (parts) {
          var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
          return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
      }
    ];
    var parseFlags = {
      D: ["day", twoDigitsOptional],
      DD: ["day", twoDigits],
      Do: ["day", twoDigitsOptional + word, function(v) {
        return parseInt(v, 10);
      }],
      M: ["month", twoDigitsOptional, monthParse],
      MM: ["month", twoDigits, monthParse],
      YY: [
        "year",
        twoDigits,
        function(v) {
          var now = new Date;
          var cent = +("" + now.getFullYear()).substr(0, 2);
          return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
      ],
      h: ["hour", twoDigitsOptional, undefined, "isPm"],
      hh: ["hour", twoDigits, undefined, "isPm"],
      H: ["hour", twoDigitsOptional],
      HH: ["hour", twoDigits],
      m: ["minute", twoDigitsOptional],
      mm: ["minute", twoDigits],
      s: ["second", twoDigitsOptional],
      ss: ["second", twoDigits],
      YYYY: ["year", fourDigits],
      S: ["millisecond", "\\d", function(v) {
        return +v * 100;
      }],
      SS: ["millisecond", twoDigits, function(v) {
        return +v * 10;
      }],
      SSS: ["millisecond", threeDigits],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: ["month", word, monthUpdate("monthNamesShort")],
      MMMM: ["month", word, monthUpdate("monthNames")],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
    };
    var globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
    };
    var setGlobalDateMasks = function(masks) {
      return assign(globalMasks, masks);
    };
    var format = function(dateObj, mask, i18n) {
      if (mask === undefined) {
        mask = globalMasks["default"];
      }
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      mask = mask.replace(literal13, function($0, $1) {
        literals.push($1);
        return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      mask = mask.replace(token, function($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      return mask.replace(/@@@/g, function() {
        return literals.shift();
      });
    };
    function parse4(dateStr, format2, i18n) {
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof format2 !== "string") {
        throw new Error("Invalid format in fecha parse");
      }
      format2 = globalMasks[format2] || format2;
      if (dateStr.length > 1000) {
        return null;
      }
      var today = new Date;
      var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
      };
      var parseInfo = [];
      var literals = [];
      var newFormat = format2.replace(literal13, function($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
      });
      var specifiedFields = {};
      var requiredFields = {};
      newFormat = regexEscape(newFormat).replace(token, function($0) {
        var info = parseFlags[$0];
        var field2 = info[0], regex2 = info[1], requiredField = info[3];
        if (specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " specified twice in format");
        }
        specifiedFields[field2] = true;
        if (requiredField) {
          requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex2 + ")";
      });
      Object.keys(requiredFields).forEach(function(field2) {
        if (!specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " is required in specified format");
        }
      });
      newFormat = newFormat.replace(/@@@/g, function() {
        return literals.shift();
      });
      var matches = dateStr.match(new RegExp(newFormat, "i"));
      if (!matches) {
        return null;
      }
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      for (var i = 1;i < matches.length; i++) {
        var _a2 = parseInfo[i - 1], field = _a2[0], parser = _a2[2];
        var value26 = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
        if (value26 == null) {
          return null;
        }
        dateInfo[field] = value26;
      }
      if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
      } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
      }
      var dateTZ;
      if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
          ["month", "getMonth"],
          ["day", "getDate"],
          ["hour", "getHours"],
          ["minute", "getMinutes"],
          ["second", "getSeconds"]
        ];
        for (var i = 0, len = validateFields.length;i < len; i++) {
          if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
            return null;
          }
        }
      } else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
          return null;
        }
      }
      return dateTZ;
    }
    var fecha = {
      format,
      parse: parse4,
      defaultI18n,
      setGlobalDateI18n,
      setGlobalDateMasks
    };
    exports2.assign = assign;
    exports2.default = fecha;
    exports2.format = format;
    exports2.parse = parse4;
    exports2.defaultI18n = defaultI18n;
    exports2.setGlobalDateI18n = setGlobalDateI18n;
    exports2.setGlobalDateMasks = setGlobalDateMasks;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/logform/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  var fecha = require_fecha_umd();
  var format = require_format();
  module.exports = format((info, opts = {}) => {
    if (opts.format) {
      info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date, opts.format);
    }
    if (!info.timestamp) {
      info.timestamp = new Date().toISOString();
    }
    if (opts.alias) {
      info[opts.alias] = info.timestamp;
    }
    return info;
  });
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  module.exports = format((info, opts) => {
    if (opts.level !== false) {
      info.level = colors.strip(info.level);
    }
    if (opts.message !== false) {
      info.message = colors.strip(String(info.message));
    }
    if (opts.raw !== false && info[MESSAGE]) {
      info[MESSAGE] = colors.strip(String(info[MESSAGE]));
    }
    return info;
  });
});

// node_modules/logform/index.js
var require_logform = __commonJS((exports) => {
  var exposeFormat = function(name, requireFormat) {
    Object.defineProperty(format, name, {
      get() {
        return requireFormat();
      },
      configurable: true
    });
  };
  var format = exports.format = require_format();
  exports.levels = require_levels();
  exposeFormat("align", function() {
    return require_align();
  });
  exposeFormat("errors", function() {
    return require_errors();
  });
  exposeFormat("cli", function() {
    return require_cli2();
  });
  exposeFormat("combine", function() {
    return require_combine();
  });
  exposeFormat("colorize", function() {
    return require_colorize();
  });
  exposeFormat("json", function() {
    return require_json();
  });
  exposeFormat("label", function() {
    return require_label();
  });
  exposeFormat("logstash", function() {
    return require_logstash();
  });
  exposeFormat("metadata", function() {
    return require_metadata();
  });
  exposeFormat("ms", function() {
    return require_ms2();
  });
  exposeFormat("padLevels", function() {
    return require_pad_levels();
  });
  exposeFormat("prettyPrint", function() {
    return require_pretty_print();
  });
  exposeFormat("printf", function() {
    return require_printf();
  });
  exposeFormat("simple", function() {
    return require_simple();
  });
  exposeFormat("splat", function() {
    return require_splat();
  });
  exposeFormat("timestamp", function() {
    return require_timestamp();
  });
  exposeFormat("uncolorize", function() {
    return require_uncolorize();
  });
});

// node_modules/winston/lib/winston/common.js
var require_common2 = __commonJS((exports) => {
  var { format } = import.meta.require("util");
  exports.warn = {
    deprecated(prop) {
      return () => {
        throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
      };
    },
    useFormat(prop) {
      return () => {
        throw new Error([
          format("{ %s } was removed in winston@3.0.0.", prop),
          "Use a custom winston.format = winston.format(function) instead."
        ].join("\n"));
      };
    },
    forFunctions(obj, type54, props) {
      props.forEach((prop) => {
        obj[prop] = exports.warn[type54](prop);
      });
    },
    forProperties(obj, type54, props) {
      props.forEach((prop) => {
        const notice = exports.warn[type54](prop);
        Object.defineProperty(obj, prop, {
          get: notice,
          set: notice
        });
      });
    }
  };
});

// node_modules/winston/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "winston",
    description: "A logger for just about everything.",
    version: "3.17.0",
    author: "Charlie Robbins <charlie.robbins@gmail.com>",
    maintainers: [
      "David Hyde <dabh@alumni.stanford.edu>"
    ],
    repository: {
      type: "git",
      url: "https://github.com/winstonjs/winston.git"
    },
    keywords: [
      "winston",
      "logger",
      "logging",
      "logs",
      "sysadmin",
      "bunyan",
      "pino",
      "loglevel",
      "tools",
      "json",
      "stream"
    ],
    dependencies: {
      "@dabh/diagnostics": "^2.0.2",
      "@colors/colors": "^1.6.0",
      async: "^3.2.3",
      "is-stream": "^2.0.0",
      logform: "^2.7.0",
      "one-time": "^1.0.0",
      "readable-stream": "^3.4.0",
      "safe-stable-stringify": "^2.3.1",
      "stack-trace": "0.0.x",
      "triple-beam": "^1.3.0",
      "winston-transport": "^4.9.0"
    },
    devDependencies: {
      "@babel/cli": "^7.23.9",
      "@babel/core": "^7.24.0",
      "@babel/preset-env": "^7.24.0",
      "@dabh/eslint-config-populist": "^4.4.0",
      "@types/node": "^20.11.24",
      "abstract-winston-transport": "^0.5.1",
      assume: "^2.2.0",
      "cross-spawn-async": "^2.2.5",
      eslint: "^8.57.0",
      hock: "^1.4.1",
      mocha: "^10.3.0",
      nyc: "^17.1.0",
      rimraf: "5.0.1",
      split2: "^4.1.0",
      "std-mocks": "^2.0.0",
      through2: "^4.0.2",
      "winston-compat": "^0.1.5"
    },
    main: "./lib/winston.js",
    browser: "./dist/winston",
    types: "./index.d.ts",
    scripts: {
      lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
      test: "rimraf test/fixtures/logs/* && mocha",
      "test:coverage": "nyc npm run test:unit",
      "test:unit": "mocha test/unit",
      "test:integration": "mocha test/integration",
      build: "rimraf dist && babel lib -d dist",
      prepublishOnly: "npm run build"
    },
    engines: {
      node: ">= 12.0.0"
    },
    license: "MIT"
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = import.meta.require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var _normalizeEncoding = function(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  };
  var normalizeEncoding = function(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  };
  var StringDecoder = function(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  };
  var utf8CheckByte = function(byte2) {
    if (byte2 <= 127)
      return 0;
    else if (byte2 >> 5 === 6)
      return 2;
    else if (byte2 >> 4 === 14)
      return 3;
    else if (byte2 >> 3 === 30)
      return 4;
    return byte2 >> 6 === 2 ? -1 : -2;
  };
  var utf8CheckIncomplete = function(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  };
  var utf8CheckExtraBytes = function(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  };
  var utf8FillLast = function(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  var utf8Text = function(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  };
  var utf8End = function(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "\uFFFD";
    return r;
  };
  var utf16Text = function(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  };
  var utf16End = function(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  };
  var base64Text = function(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  };
  var base64End = function(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  };
  var simpleWrite = function(buf) {
    return buf.toString(this.encoding);
  };
  var simpleEnd = function(buf) {
    return buf && buf.length ? this.write(buf) : "";
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  exports.StringDecoder = StringDecoder;
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var ownKeys = function(object12, enumerableOnly) {
    var keys = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols67 = Object.getOwnPropertySymbols(object12);
      enumerableOnly && (symbols67 = symbols67.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
      })), keys.push.apply(keys, symbols67);
    }
    return keys;
  };
  var _objectSpread = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  };
  var _defineProperty = function(obj, key, value26) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value26, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value26;
    }
    return obj;
  };
  var _classCallCheck = function(instance, Constructor2) {
    if (!(instance instanceof Constructor2)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var _defineProperties = function(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  };
  var _createClass = function(Constructor2, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor2.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor2, staticProps);
    Object.defineProperty(Constructor2, "prototype", { writable: false });
    return Constructor2;
  };
  var _toPropertyKey = function(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var copyBuffer = function(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  };
  var _require = import.meta.require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = import.meta.require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next)
          ret2 += s + p.data;
        return ret2;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret2;
        if (n < this.head.data.length) {
          ret2 = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret2 = this.shift();
        } else {
          ret2 = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret2;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret2 = p.data;
        n -= ret2.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret2 += str;
          else
            ret2 += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret2;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret2 = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret2);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret2, ret2.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret2;
      }
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var destroy = function(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err3);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err3);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  };
  var emitErrorAndCloseNT = function(self2, err2) {
    emitErrorNT(self2, err2);
    emitCloseNT(self2);
  };
  var emitCloseNT = function(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  };
  var undestroy = function() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  };
  var emitErrorNT = function(self2, err2) {
    self2.emit("error", err2);
  };
  var errorOrDestroy = function(stream7, err2) {
    var rState = stream7._readableState;
    var wState = stream7._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream7.destroy(err2);
    else
      stream7.emit("error", err2);
  };
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var createErrorType = function(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  };
  var oneOf = function(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  };
  var startsWith = function(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
  var endsWith = function(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  };
  var includes = function(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  };
  var codes = {};
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value26) {
    return 'The value "' + value26 + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type54 = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type54} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var highWaterMarkFrom = function(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  };
  var getHighWaterMark = function(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  };
  var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util2 = import.meta.require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module.exports = util2.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util2;
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var once = function(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  };
  var noop = function() {
  };
  var isRequest = function(stream7) {
    return stream7.setHeader && typeof stream7.abort === "function";
  };
  var eos = function(stream7, opts, callback) {
    if (typeof opts === "function")
      return eos(stream7, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream7.readable;
    var writable = opts.writable || opts.writable !== false && stream7.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream7.writable)
        onfinish();
    };
    var writableEnded = stream7._writableState && stream7._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream7);
    };
    var readableEnded = stream7._readableState && stream7._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream7);
    };
    var onerror = function onerror(err2) {
      callback.call(stream7, err2);
    };
    var onclose = function onclose() {
      var err2;
      if (readable && !readableEnded) {
        if (!stream7._readableState || !stream7._readableState.ended)
          err2 = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream7, err2);
      }
      if (writable && !writableEnded) {
        if (!stream7._writableState || !stream7._writableState.ended)
          err2 = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream7, err2);
      }
    };
    var onrequest = function onrequest() {
      stream7.req.on("finish", onfinish);
    };
    if (isRequest(stream7)) {
      stream7.on("complete", onfinish);
      stream7.on("abort", onclose);
      if (stream7.req)
        onrequest();
      else
        stream7.on("request", onrequest);
    } else if (writable && !stream7._writableState) {
      stream7.on("end", onlegacyfinish);
      stream7.on("close", onlegacyfinish);
    }
    stream7.on("end", onend);
    stream7.on("finish", onfinish);
    if (opts.error !== false)
      stream7.on("error", onerror);
    stream7.on("close", onclose);
    return function() {
      stream7.removeListener("complete", onfinish);
      stream7.removeListener("abort", onclose);
      stream7.removeListener("request", onrequest);
      if (stream7.req)
        stream7.req.removeListener("finish", onfinish);
      stream7.removeListener("end", onlegacyfinish);
      stream7.removeListener("close", onlegacyfinish);
      stream7.removeListener("finish", onfinish);
      stream7.removeListener("end", onend);
      stream7.removeListener("error", onerror);
      stream7.removeListener("close", onclose);
    };
  };
  var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _defineProperty = function(obj, key, value26) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value26, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value26;
    }
    return obj;
  };
  var _toPropertyKey = function(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var createIterResult = function(value26, done) {
    return {
      value: value26,
      done
    };
  };
  var readAndResolve = function(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data, false));
      }
    }
  };
  var onReadable = function(iter) {
    process.nextTick(readAndResolve, iter);
  };
  var wrapForNext = function(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  };
  var _Object$setPrototypeO;
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error23 = this[kError];
      if (error23 !== null) {
        return Promise.reject(error23);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve2(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve2(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream7) {
    var _Object$create;
    var iterator3 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream7,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream7._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve2, reject) {
        var data = iterator3[kStream].read();
        if (data) {
          iterator3[kLastPromise] = null;
          iterator3[kLastResolve] = null;
          iterator3[kLastReject] = null;
          resolve2(createIterResult(data, false));
        } else {
          iterator3[kLastResolve] = resolve2;
          iterator3[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator3[kLastPromise] = null;
    finished(stream7, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator3[kLastReject];
        if (reject !== null) {
          iterator3[kLastPromise] = null;
          iterator3[kLastResolve] = null;
          iterator3[kLastReject] = null;
          reject(err2);
        }
        iterator3[kError] = err2;
        return;
      }
      var resolve2 = iterator3[kLastResolve];
      if (resolve2 !== null) {
        iterator3[kLastPromise] = null;
        iterator3[kLastResolve] = null;
        iterator3[kLastReject] = null;
        resolve2(createIterResult(undefined, true));
      }
      iterator3[kEnded] = true;
    });
    stream7.on("readable", onReadable.bind(null, iterator3));
    return iterator3;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var asyncGeneratorStep = function(gen, resolve2, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value26 = info.value;
    } catch (error23) {
      reject(error23);
      return;
    }
    if (info.done) {
      resolve2(value26);
    } else {
      Promise.resolve(value26).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve2, reject) {
        var gen = fn.apply(self2, args);
        function _next(value26) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value26);
        }
        function _throw(err2) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err2);
        }
        _next(undefined);
      });
    };
  };
  var ownKeys = function(object12, enumerableOnly) {
    var keys = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols67 = Object.getOwnPropertySymbols(object12);
      enumerableOnly && (symbols67 = symbols67.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
      })), keys.push.apply(keys, symbols67);
    }
    return keys;
  };
  var _objectSpread = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  };
  var _defineProperty = function(obj, key, value26) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value26, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value26;
    }
    return obj;
  };
  var _toPropertyKey = function(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var from = function(Readable2, iterable, opts) {
    var iterator3;
    if (iterable && typeof iterable.next === "function") {
      iterator3 = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator3 = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator3 = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable2(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator3.next(), value26 = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value26)) {
            next();
          } else {
            reading = false;
          }
        } catch (err2) {
          readable.destroy(err2);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  };
  var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
  module.exports = from;
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var _uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk);
  };
  var _isUint8Array = function(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  };
  var prependListener = function(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  };
  var ReadableState = function(options, stream7, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream7 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  };
  var Readable2 = function(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable2))
      return new Readable2(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  };
  var readableAddChunk = function(stream7, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state = stream7._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream7, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream7, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream7, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream7, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream7, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream7, state, chunk, false);
            else
              maybeReadMore(stream7, state);
          } else {
            addChunk(stream7, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream7, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  };
  var addChunk = function(stream7, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream7.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream7);
    }
    maybeReadMore(stream7, state);
  };
  var chunkInvalid = function(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  };
  var computeNewHighWaterMark = function(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  };
  var howMuchToRead = function(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  };
  var onEofChunk = function(stream7, state) {
    debug2("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream7);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream7);
      }
    }
  };
  var emitReadable = function(stream7) {
    var state = stream7._readableState;
    debug2("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug2("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream7);
    }
  };
  var emitReadable_ = function(stream7) {
    var state = stream7._readableState;
    debug2("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream7.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream7);
  };
  var maybeReadMore = function(stream7, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream7, state);
    }
  };
  var maybeReadMore_ = function(stream7, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug2("maybeReadMore read 0");
      stream7.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  };
  var pipeOnDrain = function(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug2("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  };
  var updateReadableListening = function(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  };
  var nReadingNextTick = function(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  };
  var resume = function(stream7, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream7, state);
    }
  };
  var resume_ = function(stream7, state) {
    debug2("resume", state.reading);
    if (!state.reading) {
      stream7.read(0);
    }
    state.resumeScheduled = false;
    stream7.emit("resume");
    flow(stream7);
    if (state.flowing && !state.reading)
      stream7.read(0);
  };
  var flow = function(stream7) {
    var state = stream7._readableState;
    debug2("flow", state.flowing);
    while (state.flowing && stream7.read() !== null)
      ;
  };
  var fromList = function(n, state) {
    if (state.length === 0)
      return null;
    var ret2;
    if (state.objectMode)
      ret2 = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret2 = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret2 = state.buffer.first();
      else
        ret2 = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret2 = state.buffer.consume(n, state.decoder);
    }
    return ret2;
  };
  var endReadable = function(stream7) {
    var state = stream7._readableState;
    debug2("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream7);
    }
  };
  var endReadableNT = function(state, stream7) {
    debug2("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream7.readable = false;
      stream7.emit("end");
      if (state.autoDestroy) {
        var wState = stream7._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream7.destroy();
        }
      }
    }
  };
  var indexOf2 = function(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  };
  module.exports = Readable2;
  var Duplex;
  Readable2.ReadableState = ReadableState;
  var EE = import.meta.require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type54) {
    return emitter.listeners(type54).length;
  };
  var Stream = import.meta.require("stream");
  var Buffer2 = import.meta.require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var debugUtil = import.meta.require("util");
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable2, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  Object.defineProperty(Readable2.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value26) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value26;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug2("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug2("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret2;
    if (n > 0)
      ret2 = fromList(n, state);
    else
      ret2 = null;
    if (ret2 === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret2 !== null)
      this.emit("data", ret2);
    return ret2;
  };
  Readable2.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret2 = dest.write(chunk);
      debug2("dest.write", ret2);
      if (ret2 === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug2("pipe resume");
      src.resume();
    }
    return dest;
  };
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index = indexOf2(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug2("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug2("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  Readable2.prototype.wrap = function(stream7) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream7.on("end", function() {
      debug2("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream7.on("data", function(chunk) {
      debug2("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret2 = _this.push(chunk);
      if (!ret2) {
        paused = true;
        stream7.pause();
      }
    });
    for (var i in stream7) {
      if (this[i] === undefined && typeof stream7[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream7[method].apply(stream7, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream7.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream7.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable2, iterable, opts);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var Duplex = function(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  };
  var onend = function() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  };
  var onEndNT = function(self2) {
    self2.end();
  };
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable2 = require__stream_readable();
  var Writable = require__stream_writable();
  require_inherits()(Duplex, Readable2);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value26) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value26;
      this._writableState.destroyed = value26;
    }
  });
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS((exports, module) => {
  module.exports = import.meta.require("util").deprecate;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var CorkedRequest = function(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  };
  var _uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk);
  };
  var _isUint8Array = function(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  };
  var nop = function() {
  };
  var WritableState = function(options, stream7, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream7 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream7, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  };
  var Writable = function(options) {
    Duplex = Duplex || require__stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  };
  var writeAfterEnd = function(stream7, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream7, er);
    process.nextTick(cb, er);
  };
  var validChunk = function(stream7, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream7, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  };
  var decodeChunk = function(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  };
  var writeOrBuffer = function(stream7, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret2 = state.length < state.highWaterMark;
    if (!ret2)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream7, state, false, len, chunk, encoding, cb);
    }
    return ret2;
  };
  var doWrite = function(stream7, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream7._writev(chunk, state.onwrite);
    else
      stream7._write(chunk, encoding, state.onwrite);
    state.sync = false;
  };
  var onwriteError = function(stream7, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream7, state);
      stream7._writableState.errorEmitted = true;
      errorOrDestroy(stream7, er);
    } else {
      cb(er);
      stream7._writableState.errorEmitted = true;
      errorOrDestroy(stream7, er);
      finishMaybe(stream7, state);
    }
  };
  var onwriteStateUpdate = function(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  };
  var onwrite = function(stream7, er) {
    var state = stream7._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream7, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream7.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream7, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream7, state, finished, cb);
      } else {
        afterWrite(stream7, state, finished, cb);
      }
    }
  };
  var afterWrite = function(stream7, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream7, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream7, state);
  };
  var onwriteDrain = function(stream7, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream7.emit("drain");
    }
  };
  var clearBuffer = function(stream7, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream7._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream7, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream7, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  };
  var needFinish = function(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  };
  var callFinal = function(stream7, state) {
    stream7._final(function(err2) {
      state.pendingcb--;
      if (err2) {
        errorOrDestroy(stream7, err2);
      }
      state.prefinished = true;
      stream7.emit("prefinish");
      finishMaybe(stream7, state);
    });
  };
  var prefinish = function(stream7, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream7._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream7, state);
      } else {
        state.prefinished = true;
        stream7.emit("prefinish");
      }
    }
  };
  var finishMaybe = function(stream7, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream7, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream7.emit("finish");
        if (state.autoDestroy) {
          var rState = stream7._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream7.destroy();
          }
        }
      }
    }
    return need;
  };
  var endWritable = function(stream7, state, cb) {
    state.ending = true;
    finishMaybe(stream7, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream7.once("finish", cb);
    }
    state.ended = true;
    stream7.writable = false;
  };
  var onCorkedFinish = function(corkReq, state, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  };
  module.exports = Writable;
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node2()
  };
  var Stream = import.meta.require("stream");
  var Buffer2 = import.meta.require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object12) {
        if (realHasInstance.call(this, object12))
          return true;
        if (this !== Writable)
          return false;
        return object12 && object12._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object12) {
      return object12 instanceof this;
    };
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret2 = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret2;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value26) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value26;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err2, cb) {
    cb(err2);
  };
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS((exports, module) => {
  var util2 = import.meta.require("util");
  var Writable = require__stream_writable();
  var { LEVEL } = require_triple_beam();
  var TransportStream = module.exports = function TransportStream(options = {}) {
    Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log)
      this.log = options.log;
    if (options.logv)
      this.logv = options.logv;
    if (options.close)
      this.close = options.close;
    this.once("pipe", (logger) => {
      this.levels = logger.levels;
      this.parent = logger;
    });
    this.once("unpipe", (src) => {
      if (src === this.parent) {
        this.parent = null;
        if (this.close) {
          this.close();
        }
      }
    });
  };
  util2.inherits(TransportStream, Writable);
  TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    const level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (info && !this.format) {
        return this.log(info, callback);
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, info), this.format.options);
      } catch (err2) {
        errState = err2;
      }
      if (errState || !transformed) {
        callback();
        if (errState)
          throw errState;
        return;
      }
      return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
  };
  TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
      const infos = chunks.filter(this._accept, this);
      if (!infos.length) {
        return callback(null);
      }
      return this.logv(infos, callback);
    }
    for (let i = 0;i < chunks.length; i++) {
      if (!this._accept(chunks[i]))
        continue;
      if (chunks[i].chunk && !this.format) {
        this.log(chunks[i].chunk, chunks[i].callback);
        continue;
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
      } catch (err2) {
        errState = err2;
      }
      if (errState || !transformed) {
        chunks[i].callback();
        if (errState) {
          callback(null);
          throw errState;
        }
      } else {
        this.log(transformed, chunks[i].callback);
      }
    }
    return callback(null);
  };
  TransportStream.prototype._accept = function _accept(write) {
    const info = write.chunk;
    if (this.silent) {
      return false;
    }
    const level = this.level || this.parent && this.parent.level;
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (this.handleExceptions || info.exception !== true) {
        return true;
      }
    }
    return false;
  };
  TransportStream.prototype._nop = function _nop() {
    return;
  };
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var util2 = import.meta.require("util");
  var { LEVEL } = require_triple_beam();
  var TransportStream = require_modern();
  var LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
      throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    this._deprecated();
    function transportError(err2) {
      this.emit("error", err2, this.transport);
    }
    if (!this.transport.__winstonError) {
      this.transport.__winstonError = transportError.bind(this);
      this.transport.on("error", this.transport.__winstonError);
    }
  };
  util2.inherits(LegacyTransportStream, TransportStream);
  LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
      this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
  };
  LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for (let i = 0;i < chunks.length; i++) {
      if (this._accept(chunks[i])) {
        this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
        chunks[i].callback();
      }
    }
    return callback(null);
  };
  LegacyTransportStream.prototype._deprecated = function _deprecated() {
    console.error([
      `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
      "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
    ].join("\n"));
  };
  LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
      this.transport.close();
    }
    if (this.transport.__winstonError) {
      this.transport.removeListener("error", this.transport.__winstonError);
      this.transport.__winstonError = null;
    }
  };
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS((exports, module) => {
  module.exports = require_modern();
  module.exports.LegacyTransportStream = require_legacy();
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var { LEVEL, MESSAGE } = require_triple_beam();
  var TransportStream = require_winston_transport();
  module.exports = class Console extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.name = options.name || "console";
      this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
      this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      this.forceConsole = options.forceConsole || false;
      this._consoleLog = console.log.bind(console);
      this._consoleWarn = console.warn.bind(console);
      this._consoleError = console.error.bind(console);
      this.setMaxListeners(30);
    }
    log(info, callback) {
      setImmediate(() => this.emit("logged", info));
      if (this.stderrLevels[info[LEVEL]]) {
        if (console._stderr && !this.forceConsole) {
          console._stderr.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          this._consoleError(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
        return;
      } else if (this.consoleWarnLevels[info[LEVEL]]) {
        if (console._stderr && !this.forceConsole) {
          console._stderr.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          this._consoleWarn(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
        return;
      }
      if (console._stdout && !this.forceConsole) {
        console._stdout.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        this._consoleLog(info[MESSAGE]);
      }
      if (callback) {
        callback();
      }
    }
    _stringArrayToSet(strArray, errMsg) {
      if (!strArray)
        return {};
      errMsg = errMsg || "Cannot make set from type other than Array of string elements";
      if (!Array.isArray(strArray)) {
        throw new Error(errMsg);
      }
      return strArray.reduce((set2, el) => {
        if (typeof el !== "string") {
          throw new Error(errMsg);
        }
        set2[el] = true;
        return set2;
      }, {});
    }
  };
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isArrayLike = function(value26) {
    return value26 && typeof value26.length === "number" && value26.length >= 0 && value26.length % 1 === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayLike;
  module.exports = exports.default;
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(fn) {
    return function(...args) {
      var callback = args.pop();
      return fn.call(this, args, callback);
    };
  };
  module.exports = exports.default;
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  var fallback = function(fn) {
    setTimeout(fn, 0);
  };
  var wrap = function(defer) {
    return (fn, ...args) => defer(() => fn(...args));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fallback = fallback;
  exports.wrap = wrap;
  var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  var _defer;
  if (hasQueueMicrotask) {
    _defer = queueMicrotask;
  } else if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports.default = wrap(_defer);
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncify = function(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function(...args) {
        const callback = args.pop();
        const promise2 = func.apply(this, args);
        return handlePromise(promise2, callback);
      };
    }
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e) {
        return callback(e);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  };
  var handlePromise = function(promise2, callback) {
    return promise2.then((value26) => {
      invokeCallback(callback, null, value26);
    }, (err2) => {
      invokeCallback(callback, err2 && (err2 instanceof Error || err2.message) ? err2 : new Error(err2));
    });
  };
  var invokeCallback = function(callback, error23, value26) {
    try {
      callback(error23, value26);
    } catch (err2) {
      (0, _setImmediate2.default)((e) => {
        throw e;
      }, err2);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncify;
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _wrapAsync = require_wrapAsync();
  module.exports = exports.default;
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAsync2 = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
  };
  var isAsyncGenerator = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
  };
  var isAsyncIterable = function(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
  };
  var wrapAsync = function(asyncFn) {
    if (typeof asyncFn !== "function")
      throw new Error("expected a function");
    return isAsync2(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  exports.default = wrapAsync;
  exports.isAsync = isAsync2;
  exports.isAsyncGenerator = isAsyncGenerator;
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS((exports, module) => {
  var awaitify = function(asyncFn, arity) {
    if (!arity)
      arity = asyncFn.length;
    if (!arity)
      throw new Error("arity is undefined");
    function awaitable(...args) {
      if (typeof args[arity - 1] === "function") {
        return asyncFn.apply(this, args);
      }
      return new Promise((resolve2, reject) => {
        args[arity - 1] = (err2, ...cbArgs) => {
          if (err2)
            return reject(err2);
          resolve2(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this, args);
      });
    }
    return awaitable;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = awaitify;
  module.exports = exports.default;
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, (task, key, taskCb) => {
      (0, _wrapAsync2.default)(task)((err2, ...result) => {
        if (result.length < 2) {
          [result] = result;
        }
        results[key] = result;
        taskCb(err2);
      });
    }, (err2) => callback(err2, results));
  }, 3);
  module.exports = exports.default;
});

// node_modules/async/internal/once.js
var require_once = __commonJS((exports, module) => {
  var once = function(fn) {
    function wrapper(...args) {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = once;
  module.exports = exports.default;
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module.exports = exports.default;
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createArrayIterator = function(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
      return ++i < len ? { value: coll[i], key: i } : null;
    };
  };
  var createES2015Iterator = function(iterator3) {
    var i = -1;
    return function next() {
      var item = iterator3.next();
      if (item.done)
        return null;
      i++;
      return { value: item.value, key: i };
    };
  };
  var createObjectIterator = function(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i];
      if (key === "__proto__") {
        return next();
      }
      return i < len ? { value: obj[key], key } : null;
    };
  };
  var createIterator = function(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator3 = (0, _getIterator2.default)(coll);
    return iterator3 ? createES2015Iterator(iterator3) : createObjectIterator(coll);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIterator;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  module.exports = exports.default;
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports, module) => {
  var onlyOnce = function(fn) {
    return function(...args) {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = onlyOnce;
  module.exports = exports.default;
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakLoop = {};
  exports.default = breakLoop;
  module.exports = exports.default;
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncEachOfLimit = function(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done)
        return;
      awaiting = true;
      generator.next().then(({ value: value26, done: iterDone }) => {
        if (canceled || done)
          return;
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value26, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err2, result) {
      running -= 1;
      if (canceled)
        return;
      if (err2)
        return handleError(err2);
      if (err2 === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err2) {
      if (canceled)
        return;
      awaiting = false;
      done = true;
      callback(err2);
    }
    replenish();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncEachOfLimit;
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  module.exports = exports.default;
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _asyncEachOfLimit = require_asyncEachOfLimit();
  var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  exports.default = (limit) => {
    return (obj, iteratee, callback) => {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err2, value26) {
        if (canceled)
          return;
        running -= 1;
        if (err2) {
          done = true;
          callback(err2);
        } else if (err2 === false) {
          done = true;
          canceled = true;
        } else if (value26 === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module.exports = exports.default;
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = require_eachOfLimit();
  var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
  module.exports = exports.default;
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfSeries = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
  module.exports = exports.default;
});

// node_modules/async/series.js
var require_series = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var series = function(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = series;
  var _parallel2 = require_parallel();
  var _parallel3 = _interopRequireDefault(_parallel2);
  var _eachOfSeries = require_eachOfSeries();
  var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
  module.exports = exports.default;
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  var afterTransform = function(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  };
  var Transform2 = function(options) {
    if (!(this instanceof Transform2))
      return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  };
  var prefinish = function() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  };
  var done = function(stream7, er, data) {
    if (er)
      return stream7.emit("error", er);
    if (data != null)
      stream7.push(data);
    if (stream7._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream7._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream7.push(null);
  };
  module.exports = Transform2;
  var _require$codes = require_errors2().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex();
  require_inherits()(Transform2, Duplex);
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
    });
  };
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  var PassThrough2 = function(options) {
    if (!(this instanceof PassThrough2))
      return new PassThrough2(options);
    Transform2.call(this, options);
  };
  module.exports = PassThrough2;
  var Transform2 = require__stream_transform();
  require_inherits()(PassThrough2, Transform2);
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var once = function(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  };
  var noop = function(err2) {
    if (err2)
      throw err2;
  };
  var isRequest = function(stream7) {
    return stream7.setHeader && typeof stream7.abort === "function";
  };
  var destroyer = function(stream7, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream7.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream();
    eos(stream7, {
      readable: reading,
      writable: writing
    }, function(err2) {
      if (err2)
        return callback(err2);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err2) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream7))
        return stream7.abort();
      if (typeof stream7.destroy === "function")
        return stream7.destroy();
      callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var popCallback = function(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  };
  var pipeline2 = function() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error23;
    var destroys = streams.map(function(stream7, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream7, reading, writing, function(err2) {
        if (!error23)
          error23 = err2;
        if (err2)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error23);
      });
    });
    return streams.reduce(pipe);
  };
  var eos;
  var _require$codes = require_errors2().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  module.exports = pipeline2;
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = import.meta.require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var use = function(adapter) {
    if (~adapters.indexOf(adapter))
      return false;
    adapters.push(adapter);
    return true;
  };
  var set2 = function(custom) {
    logger = custom;
  };
  var enabled = function(namespace) {
    var async = [];
    for (var i = 0;i < adapters.length; i++) {
      if (adapters[i].async) {
        async.push(adapters[i]);
        continue;
      }
      if (adapters[i](namespace))
        return true;
    }
    if (!async.length)
      return false;
    return new Promise(function pinky(resolve2) {
      Promise.all(async.map(function prebind(fn) {
        return fn(namespace);
      })).then(function resolved(values) {
        resolve2(values.some(Boolean));
      });
    });
  };
  var modify = function(fn) {
    if (~modifiers.indexOf(fn))
      return false;
    modifiers.push(fn);
    return true;
  };
  var write = function() {
    logger.apply(logger, arguments);
  };
  var process2 = function(message) {
    for (var i = 0;i < modifiers.length; i++) {
      message = modifiers[i].apply(modifiers[i], arguments);
    }
    return message;
  };
  var introduce = function(fn, options) {
    var has = Object.prototype.hasOwnProperty;
    for (var key in options) {
      if (has.call(options, key)) {
        fn[key] = options[key];
      }
    }
    return fn;
  };
  var nope = function(options) {
    options.enabled = false;
    options.modify = modify;
    options.set = set2;
    options.use = use;
    return introduce(function diagnopes() {
      return false;
    }, options);
  };
  var yep = function(options) {
    function diagnostics() {
      var args = Array.prototype.slice.call(arguments, 0);
      write.call(write, options, process2(args, options));
      return true;
    }
    options.enabled = true;
    options.modify = modify;
    options.set = set2;
    options.use = use;
    return introduce(diagnostics, options);
  };
  var adapters = [];
  var modifiers = [];
  var logger = function devnull() {
  };
  module.exports = function create(diagnostics) {
    diagnostics.introduce = introduce;
    diagnostics.enabled = enabled;
    diagnostics.process = process2;
    diagnostics.modify = modify;
    diagnostics.write = write;
    diagnostics.nope = nope;
    diagnostics.yep = yep;
    diagnostics.set = set2;
    diagnostics.use = use;
    return diagnostics;
  };
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports, module) => {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS((exports, module) => {
  var isArrayish = require_is_arrayish();
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length;i < len; i++) {
      var arg = args[i];
      if (isArrayish(arg)) {
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
});

// node_modules/color-string/index.js
var require_color_string = __commonJS((exports, module) => {
  var clamp = function(num, min, max2) {
    return Math.min(Math.max(min, num), max2);
  };
  var hexDouble = function(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  };
  var colorNames = require_color_name();
  var swizzle = require_simple_swizzle();
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);
  for (name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var name;
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string5) {
    var prefix = string5.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case "hsl":
        val = cs.get.hsl(string5);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string5);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string5);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string5) {
    if (!string5) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string5.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0;i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string5.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string5.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string5.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string5.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string5) {
    if (!string5) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string5.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string5) {
    if (!string5) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string5.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
});

// node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var comparativeDistance = function(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  };
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var key;
  var convert3 = module.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (model in convert3) {
    if (convert3.hasOwnProperty(model)) {
      if (!("channels" in convert3[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert3[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert3[model].labels.length !== convert3[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert3[model].channels;
      labels = convert3[model].labels;
      delete convert3[model].channels;
      delete convert3[model].labels;
      Object.defineProperty(convert3[model], "channels", { value: channels });
      Object.defineProperty(convert3[model], "labels", { value: labels });
    }
  }
  var channels;
  var labels;
  var model;
  convert3.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max2 = Math.max(r, g, b);
    var delta2 = max2 - min;
    var h;
    var s;
    var l;
    if (max2 === min) {
      h = 0;
    } else if (r === max2) {
      h = (g - b) / delta2;
    } else if (g === max2) {
      h = 2 + (b - r) / delta2;
    } else if (b === max2) {
      h = 4 + (r - g) / delta2;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max2) / 2;
    if (max2 === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta2 / (max2 + min);
    } else {
      s = delta2 / (2 - max2 - min);
    }
    return [h, s * 100, l * 100];
  };
  convert3.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert3.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert3.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert3.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k2;
    k2 = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k2) / (1 - k2) || 0;
    m = (1 - g - k2) / (1 - k2) || 0;
    y = (1 - b - k2) / (1 - k2) || 0;
    return [c * 100, m * 100, y * 100, k2 * 100];
  };
  convert3.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value26 = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value26);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert3.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert3.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert3.rgb.lab = function(rgb) {
    var xyz = convert3.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert3.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert3.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert3.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t2 = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t2, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t2];
      case 3:
        return [p, q, v];
      case 4:
        return [t2, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert3.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert3.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert3.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k2 = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k2) + k2);
    g = 1 - Math.min(1, m * (1 - k2) + k2);
    b = 1 - Math.min(1, y * (1 - k2) + k2);
    return [r * 255, g * 255, b * 255];
  };
  convert3.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert3.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert3.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert3.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert3.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert3.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value26 = 1 in arguments ? arguments[1] : convert3.rgb.hsv(args)[2];
    value26 = Math.round(value26 / 50);
    if (value26 === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value26 === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert3.hsv.ansi16 = function(args) {
    return convert3.rgb.ansi16(convert3.hsv.rgb(args), args[2]);
  };
  convert3.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert3.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert3.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert3.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string5 = integer.toString(16).toUpperCase();
    return "000000".substring(string5.length) + string5;
  };
  convert3.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert3.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max2 = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max2 - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max2 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert3.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert3.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert3.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert3.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert3.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert3.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert3.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert3.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert3.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert3.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert3.gray.hsl = convert3.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert3.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert3.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert3.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert3.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string5 = integer.toString(16).toUpperCase();
    return "000000".substring(string5.length) + string5;
  };
  convert3.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var buildGraph = function() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0;i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link = function(from, to) {
    return function(args) {
      return to(from(args));
    };
  };
  var wrapConversion = function(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  };
  var conversions = require_conversions();
  module.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0;i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var wrapRaw = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions();
  var route = require_route();
  var convert3 = {};
  var models = Object.keys(conversions);
  models.forEach(function(fromModel) {
    convert3[fromModel] = {};
    Object.defineProperty(convert3[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert3[fromModel], "labels", { value: conversions[fromModel].labels });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert3[fromModel][toModel] = wrapRounded(fn);
      convert3[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert3;
});

// node_modules/color/index.js
var require_color = __commonJS((exports, module) => {
  var Color = function(obj, model) {
    if (!(this instanceof Color)) {
      return new Color(obj, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert3)) {
      throw new Error("Unknown model: " + model);
    }
    var i;
    var channels;
    if (obj == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (obj instanceof Color) {
      this.model = obj.model;
      this.color = obj.color.slice();
      this.valpha = obj.valpha;
    } else if (typeof obj === "string") {
      var result = colorString.get(obj);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + obj);
      }
      this.model = result.model;
      channels = convert3[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (obj.length) {
      this.model = model || "rgb";
      channels = convert3[this.model].channels;
      var newArr = _slice.call(obj, 0, channels);
      this.color = zeroArray(newArr, channels);
      this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
    } else if (typeof obj === "number") {
      obj &= 16777215;
      this.model = "rgb";
      this.color = [
        obj >> 16 & 255,
        obj >> 8 & 255,
        obj & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      var keys = Object.keys(obj);
      if ("alpha" in obj) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
      }
      var hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
      }
      this.model = hashedModelKeys[hashedKeys];
      var labels = convert3[this.model].labels;
      var color = [];
      for (i = 0;i < labels.length; i++) {
        color.push(obj[labels[i]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = convert3[this.model].channels;
      for (i = 0;i < channels; i++) {
        var limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  };
  var roundTo = function(num, places) {
    return Number(num.toFixed(places));
  };
  var roundToPlace = function(places) {
    return function(num) {
      return roundTo(num, places);
    };
  };
  var getset = function(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    model.forEach(function(m) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    });
    model = model[0];
    return function(val) {
      var result;
      if (arguments.length) {
        if (modifier) {
          val = modifier(val);
        }
        result = this[model]();
        result.color[channel] = val;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  };
  var maxfn = function(max2) {
    return function(v) {
      return Math.max(0, Math.min(max2, v));
    };
  };
  var assertArray = function(val) {
    return Array.isArray(val) ? val : [val];
  };
  var zeroArray = function(arr, length) {
    for (var i = 0;i < length; i++) {
      if (typeof arr[i] !== "number") {
        arr[i] = 0;
      }
    }
    return arr;
  };
  var colorString = require_color_string();
  var convert3 = require_color_convert();
  var _slice = [].slice;
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  Object.keys(convert3).forEach(function(model) {
    hashedModelKeys[_slice.call(convert3[model].labels).sort().join("")] = model;
  });
  var limiters = {};
  Color.prototype = {
    toString: function() {
      return this.string();
    },
    toJSON: function() {
      return this[this.model]();
    },
    string: function(places) {
      var self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to[self2.model](args);
    },
    percentString: function(places) {
      var self2 = this.rgb().round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to.rgb.percent(args);
    },
    array: function() {
      return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    },
    object: function() {
      var result = {};
      var channels = convert3[this.model].channels;
      var labels = convert3[this.model].labels;
      for (var i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray: function() {
      var rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject: function() {
      var rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round: function(places) {
      places = Math.max(places || 0, 0);
      return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
    },
    alpha: function(val) {
      if (arguments.length) {
        return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
      return (val % 360 + 360) % 360;
    }),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(100)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(100)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return convert3[this.model].keyword(this.color);
    },
    hex: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    rgbNumber: function() {
      var rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity: function() {
      var rgb = this.rgb().color;
      var lum = [];
      for (var i = 0;i < rgb.length; i++) {
        var chan = rgb[i] / 255;
        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function(color2) {
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function(color2) {
      var contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7.1) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark: function() {
      var rgb = this.rgb().color;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    isLight: function() {
      return !this.isDark();
    },
    negate: function() {
      var rgb = this.rgb();
      for (var i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten: function(ratio) {
      var hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken: function(ratio) {
      var hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale: function() {
      var rgb = this.rgb().color;
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(val, val, val);
    },
    fade: function(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer: function(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate: function(degrees) {
      var hsl = this.hsl();
      var hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix: function(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      var color1 = mixinColor.rgb();
      var color2 = this.rgb();
      var p = weight === undefined ? 0.5 : weight;
      var w = 2 * p - 1;
      var a = color1.alpha() - color2.alpha();
      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      var w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  Object.keys(convert3).forEach(function(model) {
    if (skippedModels.indexOf(model) !== -1) {
      return;
    }
    var channels = convert3[model].channels;
    Color.prototype[model] = function() {
      if (this.model === model) {
        return new Color(this);
      }
      if (arguments.length) {
        return new Color(arguments, model);
      }
      var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
      return new Color(assertArray(convert3[this.model][model].raw(this.color)).concat(newAlpha), model);
    };
    Color[model] = function(color) {
      if (typeof color === "number") {
        color = zeroArray(_slice.call(arguments), channels);
      }
      return new Color(color, model);
    };
  });
  module.exports = Color;
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS((exports, module) => {
  module.exports = function hex(str) {
    for (var i = 0, hash5 = 0;i < str.length; hash5 = str.charCodeAt(i++) + ((hash5 << 5) - hash5))
      ;
    var color = Math.floor(Math.abs(Math.sin(hash5) * 1e4 % 1 * 16777216)).toString(16);
    return "#" + Array(6 - color.length + 1).join("0") + color;
  };
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS((exports, module) => {
  var color = require_color();
  var hex = require_text_hex();
  module.exports = function colorspace(namespace, delimiter) {
    var split = namespace.split(delimiter || ":");
    var base = hex(split[0]);
    if (!split.length)
      return base;
    for (var i = 0, l = split.length - 1;i < l; i++) {
      base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
    }
    return base;
  };
});

// node_modules/kuler/index.js
var require_kuler = __commonJS((exports, module) => {
  var Kuler = function(text, color) {
    if (color)
      return new Kuler(text).style(color);
    if (!(this instanceof Kuler))
      return new Kuler(text);
    this.text = text;
  };
  Kuler.prototype.prefix = "\x1B[";
  Kuler.prototype.suffix = "m";
  Kuler.prototype.hex = function hex(color) {
    color = color[0] === "#" ? color.substring(1) : color;
    if (color.length === 3) {
      color = color.split("");
      color[5] = color[2];
      color[4] = color[2];
      color[3] = color[1];
      color[2] = color[1];
      color[1] = color[0];
      color = color.join("");
    }
    var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
    return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
  };
  Kuler.prototype.rgb = function rgb(r, g, b) {
    var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
    return this.ansi(red, green, blue);
  };
  Kuler.prototype.ansi = function ansi(r, g, b) {
    var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
    return 16 + red * 36 + green * 6 + blue;
  };
  Kuler.prototype.reset = function reset() {
    return this.prefix + "39;49" + this.suffix;
  };
  Kuler.prototype.style = function style(color) {
    return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
  };
  module.exports = Kuler;
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS((exports, module) => {
  var colorspace = require_colorspace();
  var kuler = require_kuler();
  module.exports = function ansiModifier(args, options) {
    var namespace = options.namespace;
    var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
    args[0] = ansi + " " + args[0];
    return args;
  };
});

// node_modules/enabled/index.js
var require_enabled = __commonJS((exports, module) => {
  module.exports = function enabled(name, variable) {
    if (!variable)
      return false;
    var variables = variable.split(/[\s,]+/), i = 0;
    for (;i < variables.length; i++) {
      variable = variables[i].replace("*", ".*?");
      if (variable.charAt(0) === "-") {
        if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
          return false;
        }
        continue;
      }
      if (new RegExp("^" + variable + "$").test(name)) {
        return true;
      }
    }
    return false;
  };
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS((exports, module) => {
  var enabled = require_enabled();
  module.exports = function create(fn) {
    return function adapter(namespace) {
      try {
        return enabled(namespace, fn());
      } catch (e) {
      }
      return false;
    };
  };
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS((exports, module) => {
  var adapter = require_adapters();
  module.exports = adapter(function processenv() {
    return process.env.DEBUG || process.env.DIAGNOSTICS;
  });
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS((exports, module) => {
  module.exports = function(meta, messages) {
    try {
      Function.prototype.apply.call(console.log, console, messages);
    } catch (e) {
    }
  };
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS((exports, module) => {
  var create10 = require_diagnostics();
  var tty = import.meta.require("tty").isatty(1);
  var diagnostics = create10(function dev(namespace, options) {
    options = options || {};
    options.colors = "colors" in options ? options.colors : tty;
    options.namespace = namespace;
    options.prod = false;
    options.dev = true;
    if (!dev.enabled(namespace) && !(options.force || dev.force)) {
      return dev.nope(options);
    }
    return dev.yep(options);
  });
  diagnostics.modify(require_namespace_ansi());
  diagnostics.use(require_process_env());
  diagnostics.set(require_console2());
  module.exports = diagnostics;
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node3 = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_development();
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS((exports, module) => {
  var noop = function() {
  };
  var fs = import.meta.require("fs");
  var { StringDecoder } = import.meta.require("string_decoder");
  var { Stream } = require_readable();
  module.exports = (options, iter) => {
    const buffer = Buffer.alloc(64 * 1024);
    const decode2 = new StringDecoder("utf8");
    const stream7 = new Stream;
    let buff = "";
    let pos = 0;
    let row = 0;
    if (options.start === -1) {
      delete options.start;
    }
    stream7.readable = true;
    stream7.destroy = () => {
      stream7.destroyed = true;
      stream7.emit("end");
      stream7.emit("close");
    };
    fs.open(options.file, "a+", "0644", (err2, fd2) => {
      if (err2) {
        if (!iter) {
          stream7.emit("error", err2);
        } else {
          iter(err2);
        }
        stream7.destroy();
        return;
      }
      (function read() {
        if (stream7.destroyed) {
          fs.close(fd2, noop);
          return;
        }
        return fs.read(fd2, buffer, 0, buffer.length, pos, (error23, bytes) => {
          if (error23) {
            if (!iter) {
              stream7.emit("error", error23);
            } else {
              iter(error23);
            }
            stream7.destroy();
            return;
          }
          if (!bytes) {
            if (buff) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream7.emit("line", buff);
                } else {
                  iter(null, buff);
                }
              }
              row++;
              buff = "";
            }
            return setTimeout(read, 1000);
          }
          let data = decode2.write(buffer.slice(0, bytes));
          if (!iter) {
            stream7.emit("data", data);
          }
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (;i < l; i++) {
            if (options.start == null || row > options.start) {
              if (!iter) {
                stream7.emit("line", data[i]);
              } else {
                iter(null, data[i]);
              }
            }
            row++;
          }
          buff = data[l];
          pos += bytes;
          return read();
        });
      })();
    });
    if (!iter) {
      return stream7;
    }
    return stream7.destroy;
  };
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var asyncSeries = require_series();
  var zlib = import.meta.require("zlib");
  var { MESSAGE } = require_triple_beam();
  var { Stream, PassThrough: PassThrough2 } = require_readable();
  var TransportStream = require_winston_transport();
  var debug2 = require_node3()("winston:file");
  var os = import.meta.require("os");
  var tailFile = require_tail_file();
  module.exports = class File2 extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.name = options.name || "file";
      function throwIf(target, ...args) {
        args.slice(1).forEach((name) => {
          if (options[name]) {
            throw new Error(`Cannot set ${name} and ${target} together`);
          }
        });
      }
      this._stream = new PassThrough2;
      this._stream.setMaxListeners(30);
      this._onError = this._onError.bind(this);
      if (options.filename || options.dirname) {
        throwIf("filename or dirname", "stream");
        this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
        this.dirname = options.dirname || path.dirname(options.filename);
        this.options = options.options || { flags: "a" };
      } else if (options.stream) {
        console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
        throwIf("stream", "filename", "maxsize");
        this._dest = this._stream.pipe(this._setupStream(options.stream));
        this.dirname = path.dirname(this._dest.path);
      } else {
        throw new Error("Cannot log to file without filename or stream.");
      }
      this.maxsize = options.maxsize || null;
      this.rotationFormat = options.rotationFormat || false;
      this.zippedArchive = options.zippedArchive || false;
      this.maxFiles = options.maxFiles || null;
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      this.tailable = options.tailable || false;
      this.lazy = options.lazy || false;
      this._size = 0;
      this._pendingSize = 0;
      this._created = 0;
      this._drain = false;
      this._opening = false;
      this._ending = false;
      this._fileExist = false;
      if (this.dirname)
        this._createLogDirIfNotExist(this.dirname);
      if (!this.lazy)
        this.open();
    }
    finishIfEnding() {
      if (this._ending) {
        if (this._opening) {
          this.once("open", () => {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          });
        } else {
          this._stream.once("finish", () => this.emit("finish"));
          setImmediate(() => this._stream.end());
        }
      }
    }
    log(info, callback = () => {
    }) {
      if (this.silent) {
        callback();
        return true;
      }
      if (this._drain) {
        this._stream.once("drain", () => {
          this._drain = false;
          this.log(info, callback);
        });
        return;
      }
      if (this._rotate) {
        this._stream.once("rotate", () => {
          this._rotate = false;
          this.log(info, callback);
        });
        return;
      }
      if (this.lazy) {
        if (!this._fileExist) {
          if (!this._opening) {
            this.open();
          }
          this.once("open", () => {
            this._fileExist = true;
            this.log(info, callback);
            return;
          });
          return;
        }
        if (this._needsNewFile(this._pendingSize)) {
          this._dest.once("close", () => {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this.log(info, callback);
              return;
            });
            return;
          });
          return;
        }
      }
      const output = `${info[MESSAGE]}${this.eol}`;
      const bytes = Buffer.byteLength(output);
      function logged() {
        this._size += bytes;
        this._pendingSize -= bytes;
        debug2("logged %s %s", this._size, output);
        this.emit("logged", info);
        if (this._rotate) {
          return;
        }
        if (this._opening) {
          return;
        }
        if (!this._needsNewFile()) {
          return;
        }
        if (this.lazy) {
          this._endStream(() => {
            this.emit("fileclosed");
          });
          return;
        }
        this._rotate = true;
        this._endStream(() => this._rotateFile());
      }
      this._pendingSize += bytes;
      if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
        this.rotatedWhileOpening = true;
      }
      const written = this._stream.write(output, logged.bind(this));
      if (!written) {
        this._drain = true;
        this._stream.once("drain", () => {
          this._drain = false;
          callback();
        });
      } else {
        callback();
      }
      debug2("written", written, this._drain);
      this.finishIfEnding();
      return written;
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = normalizeQuery(options);
      const file = path.join(this.dirname, this.filename);
      let buff = "";
      let results = [];
      let row = 0;
      const stream7 = fs.createReadStream(file, {
        encoding: "utf8"
      });
      stream7.on("error", (err2) => {
        if (stream7.readable) {
          stream7.destroy();
        }
        if (!callback) {
          return;
        }
        return err2.code !== "ENOENT" ? callback(err2) : callback(null, results);
      });
      stream7.on("data", (data) => {
        data = (buff + data).split(/\n+/);
        const l = data.length - 1;
        let i = 0;
        for (;i < l; i++) {
          if (!options.start || row >= options.start) {
            add(data[i]);
          }
          row++;
        }
        buff = data[l];
      });
      stream7.on("close", () => {
        if (buff) {
          add(buff, true);
        }
        if (options.order === "desc") {
          results = results.reverse();
        }
        if (callback)
          callback(null, results);
      });
      function add(buff2, attempt) {
        try {
          const log = JSON.parse(buff2);
          if (check13(log)) {
            push(log);
          }
        } catch (e) {
          if (!attempt) {
            stream7.emit("error", e);
          }
        }
      }
      function push(log) {
        if (options.rows && results.length >= options.rows && options.order !== "desc") {
          if (stream7.readable) {
            stream7.destroy();
          }
          return;
        }
        if (options.fields) {
          log = options.fields.reduce((obj, key) => {
            obj[key] = log[key];
            return obj;
          }, {});
        }
        if (options.order === "desc") {
          if (results.length >= options.rows) {
            results.shift();
          }
        }
        results.push(log);
      }
      function check13(log) {
        if (!log) {
          return;
        }
        if (typeof log !== "object") {
          return;
        }
        const time = new Date(log.timestamp);
        if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
          return;
        }
        return true;
      }
      function normalizeQuery(options2) {
        options2 = options2 || {};
        options2.rows = options2.rows || options2.limit || 10;
        options2.start = options2.start || 0;
        options2.until = options2.until || new Date;
        if (typeof options2.until !== "object") {
          options2.until = new Date(options2.until);
        }
        options2.from = options2.from || options2.until - 24 * 60 * 60 * 1000;
        if (typeof options2.from !== "object") {
          options2.from = new Date(options2.from);
        }
        options2.order = options2.order || "desc";
        return options2;
      }
    }
    stream(options = {}) {
      const file = path.join(this.dirname, this.filename);
      const stream7 = new Stream;
      const tail = {
        file,
        start: options.start
      };
      stream7.destroy = tailFile(tail, (err2, line) => {
        if (err2) {
          return stream7.emit("error", err2);
        }
        try {
          stream7.emit("data", line);
          line = JSON.parse(line);
          stream7.emit("log", line);
        } catch (e) {
          stream7.emit("error", e);
        }
      });
      return stream7;
    }
    open() {
      if (!this.filename)
        return;
      if (this._opening)
        return;
      this._opening = true;
      this.stat((err2, size) => {
        if (err2) {
          return this.emit("error", err2);
        }
        debug2("stat done: %s { size: %s }", this.filename, size);
        this._size = size;
        this._dest = this._createStream(this._stream);
        this._opening = false;
        this.once("open", () => {
          if (!this._stream.emit("rotate")) {
            this._rotate = false;
          }
        });
      });
    }
    stat(callback) {
      const target = this._getFile();
      const fullpath = path.join(this.dirname, target);
      fs.stat(fullpath, (err2, stat4) => {
        if (err2 && err2.code === "ENOENT") {
          debug2("ENOENT\xA0ok", fullpath);
          this.filename = target;
          return callback(null, 0);
        }
        if (err2) {
          debug2(`err ${err2.code} ${fullpath}`);
          return callback(err2);
        }
        if (!stat4 || this._needsNewFile(stat4.size)) {
          return this._incFile(() => this.stat(callback));
        }
        this.filename = target;
        callback(null, stat4.size);
      });
    }
    close(cb) {
      if (!this._stream) {
        return;
      }
      this._stream.end(() => {
        if (cb) {
          cb();
        }
        this.emit("flush");
        this.emit("closed");
      });
    }
    _needsNewFile(size) {
      size = size || this._size;
      return this.maxsize && size >= this.maxsize;
    }
    _onError(err2) {
      this.emit("error", err2);
    }
    _setupStream(stream7) {
      stream7.on("error", this._onError);
      return stream7;
    }
    _cleanupStream(stream7) {
      stream7.removeListener("error", this._onError);
      stream7.destroy();
      return stream7;
    }
    _rotateFile() {
      this._incFile(() => this.open());
    }
    _endStream(callback = () => {
    }) {
      if (this._dest) {
        this._stream.unpipe(this._dest);
        this._dest.end(() => {
          this._cleanupStream(this._dest);
          callback();
        });
      } else {
        callback();
      }
    }
    _createStream(source) {
      const fullpath = path.join(this.dirname, this.filename);
      debug2("create stream start", fullpath, this.options);
      const dest = fs.createWriteStream(fullpath, this.options).on("error", (err2) => debug2(err2)).on("close", () => debug2("close", dest.path, dest.bytesWritten)).on("open", () => {
        debug2("file open ok", fullpath);
        this.emit("open", fullpath);
        source.pipe(dest);
        if (this.rotatedWhileOpening) {
          this._stream = new PassThrough2;
          this._stream.setMaxListeners(30);
          this._rotateFile();
          this.rotatedWhileOpening = false;
          this._cleanupStream(dest);
          source.end();
        }
      });
      debug2("create stream ok", fullpath);
      return dest;
    }
    _incFile(callback) {
      debug2("_incFile", this.filename);
      const ext = path.extname(this._basename);
      const basename = path.basename(this._basename, ext);
      const tasks = [];
      if (this.zippedArchive) {
        tasks.push(function(cb) {
          const num = this._created > 0 && !this.tailable ? this._created : "";
          this._compressFile(path.join(this.dirname, `${basename}${num}${ext}`), path.join(this.dirname, `${basename}${num}${ext}.gz`), cb);
        }.bind(this));
      }
      tasks.push(function(cb) {
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, cb);
        } else {
          this._checkMaxFilesTailable(ext, basename, cb);
        }
      }.bind(this));
      asyncSeries(tasks, callback);
    }
    _getFile() {
      const ext = path.extname(this._basename);
      const basename = path.basename(this._basename, ext);
      const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
      return !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
    }
    _checkMaxFilesIncrementing(ext, basename, callback) {
      if (!this.maxFiles || this._created < this.maxFiles) {
        return setImmediate(callback);
      }
      const oldest = this._created - this.maxFiles;
      const isOldest = oldest !== 0 ? oldest : "";
      const isZipped = this.zippedArchive ? ".gz" : "";
      const filePath = `${basename}${isOldest}${ext}${isZipped}`;
      const target = path.join(this.dirname, filePath);
      fs.unlink(target, callback);
    }
    _checkMaxFilesTailable(ext, basename, callback) {
      const tasks = [];
      if (!this.maxFiles) {
        return;
      }
      const isZipped = this.zippedArchive ? ".gz" : "";
      for (let x = this.maxFiles - 1;x > 1; x--) {
        tasks.push(function(i, cb) {
          let fileName = `${basename}${i - 1}${ext}${isZipped}`;
          const tmppath = path.join(this.dirname, fileName);
          fs.exists(tmppath, (exists) => {
            if (!exists) {
              return cb(null);
            }
            fileName = `${basename}${i}${ext}${isZipped}`;
            fs.rename(tmppath, path.join(this.dirname, fileName), cb);
          });
        }.bind(this, x));
      }
      asyncSeries(tasks, () => {
        fs.rename(path.join(this.dirname, `${basename}${ext}${isZipped}`), path.join(this.dirname, `${basename}1${ext}${isZipped}`), callback);
      });
    }
    _compressFile(src, dest, callback) {
      fs.access(src, fs.F_OK, (err2) => {
        if (err2) {
          return callback();
        }
        var gzip = zlib.createGzip();
        var inp = fs.createReadStream(src);
        var out = fs.createWriteStream(dest);
        out.on("finish", () => {
          fs.unlink(src, callback);
        });
        inp.pipe(gzip).pipe(out);
      });
    }
    _createLogDirIfNotExist(dirPath) {
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }
    }
  };
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS((exports, module) => {
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var { Stream } = require_readable();
  var TransportStream = require_winston_transport();
  var { configure } = require_safe_stable_stringify();
  module.exports = class Http extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.options = options;
      this.name = options.name || "http";
      this.ssl = !!options.ssl;
      this.host = options.host || "localhost";
      this.port = options.port;
      this.auth = options.auth;
      this.path = options.path || "";
      this.maximumDepth = options.maximumDepth;
      this.agent = options.agent;
      this.headers = options.headers || {};
      this.headers["content-type"] = "application/json";
      this.batch = options.batch || false;
      this.batchInterval = options.batchInterval || 5000;
      this.batchCount = options.batchCount || 10;
      this.batchOptions = [];
      this.batchTimeoutID = -1;
      this.batchCallback = {};
      if (!this.port) {
        this.port = this.ssl ? 443 : 80;
      }
    }
    log(info, callback) {
      this._request(info, null, null, (err2, res) => {
        if (res && res.statusCode !== 200) {
          err2 = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
        }
        if (err2) {
          this.emit("warn", err2);
        } else {
          this.emit("logged", info);
        }
      });
      if (callback) {
        setImmediate(callback);
      }
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = {
        method: "query",
        params: this.normalizeQuery(options)
      };
      const auth = options.params.auth || null;
      delete options.params.auth;
      const path = options.params.path || null;
      delete options.params.path;
      this._request(options, auth, path, (err2, res, body) => {
        if (res && res.statusCode !== 200) {
          err2 = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
        }
        if (err2) {
          return callback(err2);
        }
        if (typeof body === "string") {
          try {
            body = JSON.parse(body);
          } catch (e) {
            return callback(e);
          }
        }
        callback(null, body);
      });
    }
    stream(options = {}) {
      const stream7 = new Stream;
      options = {
        method: "stream",
        params: options
      };
      const path = options.params.path || null;
      delete options.params.path;
      const auth = options.params.auth || null;
      delete options.params.auth;
      let buff = "";
      const req = this._request(options, auth, path);
      stream7.destroy = () => req.destroy();
      req.on("data", (data) => {
        data = (buff + data).split(/\n+/);
        const l = data.length - 1;
        let i = 0;
        for (;i < l; i++) {
          try {
            stream7.emit("log", JSON.parse(data[i]));
          } catch (e) {
            stream7.emit("error", e);
          }
        }
        buff = data[l];
      });
      req.on("error", (err2) => stream7.emit("error", err2));
      return stream7;
    }
    _request(options, auth, path, callback) {
      options = options || {};
      auth = auth || this.auth;
      path = path || this.path || "";
      if (this.batch) {
        this._doBatch(options, callback, auth, path);
      } else {
        this._doRequest(options, callback, auth, path);
      }
    }
    _doBatch(options, callback, auth, path) {
      this.batchOptions.push(options);
      if (this.batchOptions.length === 1) {
        const me = this;
        this.batchCallback = callback;
        this.batchTimeoutID = setTimeout(function() {
          me.batchTimeoutID = -1;
          me._doBatchRequest(me.batchCallback, auth, path);
        }, this.batchInterval);
      }
      if (this.batchOptions.length === this.batchCount) {
        this._doBatchRequest(this.batchCallback, auth, path);
      }
    }
    _doBatchRequest(callback, auth, path) {
      if (this.batchTimeoutID > 0) {
        clearTimeout(this.batchTimeoutID);
        this.batchTimeoutID = -1;
      }
      const batchOptionsCopy = this.batchOptions.slice();
      this.batchOptions = [];
      this._doRequest(batchOptionsCopy, callback, auth, path);
    }
    _doRequest(options, callback, auth, path) {
      const headers = Object.assign({}, this.headers);
      if (auth && auth.bearer) {
        headers.Authorization = `Bearer ${auth.bearer}`;
      }
      const req = (this.ssl ? https : http).request({
        ...this.options,
        method: "POST",
        host: this.host,
        port: this.port,
        path: `/${path.replace(/^\//, "")}`,
        headers,
        auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
        agent: this.agent
      });
      req.on("error", callback);
      req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
      const jsonStringify = configure({
        ...this.maximumDepth && { maximumDepth: this.maximumDepth }
      });
      req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
    }
  };
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream7) => stream7 !== null && typeof stream7 === "object" && typeof stream7.pipe === "function";
  isStream.writable = (stream7) => isStream(stream7) && stream7.writable !== false && typeof stream7._write === "function" && typeof stream7._writableState === "object";
  isStream.readable = (stream7) => isStream(stream7) && stream7.readable !== false && typeof stream7._read === "function" && typeof stream7._readableState === "object";
  isStream.duplex = (stream7) => isStream.writable(stream7) && isStream.readable(stream7);
  isStream.transform = (stream7) => isStream.duplex(stream7) && typeof stream7._transform === "function";
  module.exports = isStream;
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream = __commonJS((exports, module) => {
  var isStream = require_is_stream();
  var { MESSAGE } = require_triple_beam();
  var os = import.meta.require("os");
  var TransportStream = require_winston_transport();
  module.exports = class Stream extends TransportStream {
    constructor(options = {}) {
      super(options);
      if (!options.stream || !isStream(options.stream)) {
        throw new Error("options.stream is required.");
      }
      this._stream = options.stream;
      this._stream.setMaxListeners(Infinity);
      this.isObjectMode = options.stream._writableState.objectMode;
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
    }
    log(info, callback) {
      setImmediate(() => this.emit("logged", info));
      if (this.isObjectMode) {
        this._stream.write(info);
        if (callback) {
          callback();
        }
        return;
      }
      this._stream.write(`${info[MESSAGE]}${this.eol}`);
      if (callback) {
        callback();
      }
      return;
    }
  };
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS((exports) => {
  Object.defineProperty(exports, "Console", {
    configurable: true,
    enumerable: true,
    get() {
      return require_console();
    }
  });
  Object.defineProperty(exports, "File", {
    configurable: true,
    enumerable: true,
    get() {
      return require_file();
    }
  });
  Object.defineProperty(exports, "Http", {
    configurable: true,
    enumerable: true,
    get() {
      return require_http();
    }
  });
  Object.defineProperty(exports, "Stream", {
    configurable: true,
    enumerable: true,
    get() {
      return require_stream();
    }
  });
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS((exports) => {
  var logform = require_logform();
  var { configs } = require_triple_beam();
  exports.cli = logform.levels(configs.cli);
  exports.npm = logform.levels(configs.npm);
  exports.syslog = logform.levels(configs.syslog);
  exports.addColors = logform.levels;
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfArrayLike = function(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0, completed = 0, { length } = coll, canceled = false;
    if (length === 0) {
      callback(null);
    }
    function iteratorCallback(err2, value26) {
      if (err2 === false) {
        canceled = true;
      }
      if (canceled === true)
        return;
      if (err2) {
        callback(err2);
      } else if (++completed === length || value26 === _breakLoop2.default) {
        callback(null);
      }
    }
    for (;index < length; index++) {
      iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
  };
  var eachOfGeneric = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
  };
  var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOf, 3);
  module.exports = exports.default;
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS((exports, module) => {
  var _withoutIndex = function(iteratee) {
    return (value26, index, callback) => iteratee(value26, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _withoutIndex;
  module.exports = exports.default;
});

// node_modules/async/forEach.js
var require_forEach = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOf = require_eachOf();
  var _eachOf2 = _interopRequireDefault(_eachOf);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachLimit, 3);
  module.exports = exports.default;
});

// node_modules/fn.name/index.js
var require_fn = __commonJS((exports, module) => {
  var toString = Object.prototype.toString;
  module.exports = function name(fn) {
    if (typeof fn.displayName === "string" && fn.constructor.name) {
      return fn.displayName;
    } else if (typeof fn.name === "string" && fn.name) {
      return fn.name;
    }
    if (typeof fn === "object" && fn.constructor && typeof fn.constructor.name === "string")
      return fn.constructor.name;
    var named = fn.toString(), type54 = toString.call(fn).slice(8, -1);
    if (type54 === "Function") {
      named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
    } else {
      named = type54;
    }
    return named || "anonymous";
  };
});

// node_modules/one-time/index.js
var require_one_time = __commonJS((exports, module) => {
  var name = require_fn();
  module.exports = function one(fn) {
    var called = 0, value26;
    function onetime() {
      if (called)
        return value26;
      called = 1;
      value26 = fn.apply(this, arguments);
      fn = null;
      return value26;
    }
    onetime.displayName = name(fn);
    return onetime;
  };
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS((exports) => {
  var CallSite = function(properties) {
    for (var property in properties) {
      this[property] = properties[property];
    }
  };
  exports.get = function(belowFn) {
    var oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    var dummyObject = {};
    var v8Handler = Error.prepareStackTrace;
    Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
      return v8StackTrace2;
    };
    Error.captureStackTrace(dummyObject, belowFn || exports.get);
    var v8StackTrace = dummyObject.stack;
    Error.prepareStackTrace = v8Handler;
    Error.stackTraceLimit = oldLimit;
    return v8StackTrace;
  };
  exports.parse = function(err2) {
    if (!err2.stack) {
      return [];
    }
    var self2 = this;
    var lines = err2.stack.split("\n").slice(1);
    return lines.map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self2._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          native: null
        });
      }
      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }
      var object12 = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = lineMatch[5] === "native";
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] == ".")
          methodStart--;
        if (methodStart > 0) {
          object12 = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object12.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object12 = object12.substr(0, objectEnd);
          }
        }
        typeName = null;
      }
      if (method) {
        typeName = object12;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = null;
        functionName = null;
      }
      var properties = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName,
        typeName,
        methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        native: isNative
      };
      return self2._createParsedCallSite(properties);
    }).filter(function(callSite) {
      return !!callSite;
    });
  };
  var strProperties = [
    "this",
    "typeName",
    "functionName",
    "methodName",
    "fileName",
    "lineNumber",
    "columnNumber",
    "function",
    "evalOrigin"
  ];
  var boolProperties = [
    "topLevel",
    "eval",
    "native",
    "constructor"
  ];
  strProperties.forEach(function(property) {
    CallSite.prototype[property] = null;
    CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  boolProperties.forEach(function(property) {
    CallSite.prototype[property] = false;
    CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  exports._createParsedCallSite = function(properties) {
    return new CallSite(properties);
  };
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS((exports, module) => {
  var { Writable } = require_readable();
  module.exports = class ExceptionStream extends Writable {
    constructor(transport) {
      super({ objectMode: true });
      if (!transport) {
        throw new Error("ExceptionStream requires a TransportStream instance.");
      }
      this.handleExceptions = true;
      this.transport = transport;
    }
    _write(info, enc, callback) {
      if (info.exception) {
        return this.transport.log(info, callback);
      }
      callback();
      return true;
    }
  };
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var asyncForEach = require_forEach();
  var debug2 = require_node3()("winston:exception");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var ExceptionStream = require_exception_stream();
  module.exports = class ExceptionHandler {
    constructor(logger) {
      if (!logger) {
        throw new Error("Logger is required to handle exceptions");
      }
      this.logger = logger;
      this.handlers = new Map;
    }
    handle(...args) {
      args.forEach((arg) => {
        if (Array.isArray(arg)) {
          return arg.forEach((handler) => this._addHandler(handler));
        }
        this._addHandler(arg);
      });
      if (!this.catcher) {
        this.catcher = this._uncaughtException.bind(this);
        process.on("uncaughtException", this.catcher);
      }
    }
    unhandle() {
      if (this.catcher) {
        process.removeListener("uncaughtException", this.catcher);
        this.catcher = false;
        Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
      }
    }
    getAllInfo(err2) {
      let message = null;
      if (err2) {
        message = typeof err2 === "string" ? err2 : err2.message;
      }
      return {
        error: err2,
        level: "error",
        message: [
          `uncaughtException: ${message || "(no error message)"}`,
          err2 && err2.stack || "  No stack trace"
        ].join("\n"),
        stack: err2 && err2.stack,
        exception: true,
        date: new Date().toString(),
        process: this.getProcessInfo(),
        os: this.getOsInfo(),
        trace: this.getTrace(err2)
      };
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    }
    getOsInfo() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    }
    getTrace(err2) {
      const trace = err2 ? stackTrace.parse(err2) : stackTrace.get();
      return trace.map((site) => {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    }
    _addHandler(handler) {
      if (!this.handlers.has(handler)) {
        handler.handleExceptions = true;
        const wrapper = new ExceptionStream(handler);
        this.handlers.set(handler, wrapper);
        this.logger.pipe(wrapper);
      }
    }
    _uncaughtException(err2) {
      const info = this.getAllInfo(err2);
      const handlers = this._getExceptionHandlers();
      let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err2) : this.logger.exitOnError;
      let timeout;
      if (!handlers.length && doExit) {
        console.warn("winston: exitOnError cannot be true with no exception handlers.");
        console.warn("winston: not exiting process.");
        doExit = false;
      }
      function gracefulExit() {
        debug2("doExit", doExit);
        debug2("process._exiting", process._exiting);
        if (doExit && !process._exiting) {
          if (timeout) {
            clearTimeout(timeout);
          }
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return process.nextTick(gracefulExit);
      }
      asyncForEach(handlers, (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;
        function onDone(event) {
          return () => {
            debug2(event);
            done();
          };
        }
        transport._ending = true;
        transport.once("finish", onDone("finished"));
        transport.once("error", onDone("error"));
      }, () => doExit && gracefulExit());
      this.logger.log(info);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    }
    _getExceptionHandlers() {
      return this.logger.transports.filter((wrap) => {
        const transport = wrap.transport || wrap;
        return transport.handleExceptions;
      });
    }
  };
});

// node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS((exports, module) => {
  var { Writable } = require_readable();
  module.exports = class RejectionStream extends Writable {
    constructor(transport) {
      super({ objectMode: true });
      if (!transport) {
        throw new Error("RejectionStream requires a TransportStream instance.");
      }
      this.handleRejections = true;
      this.transport = transport;
    }
    _write(info, enc, callback) {
      if (info.rejection) {
        return this.transport.log(info, callback);
      }
      callback();
      return true;
    }
  };
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var asyncForEach = require_forEach();
  var debug2 = require_node3()("winston:rejection");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var RejectionStream = require_rejection_stream();
  module.exports = class RejectionHandler {
    constructor(logger) {
      if (!logger) {
        throw new Error("Logger is required to handle rejections");
      }
      this.logger = logger;
      this.handlers = new Map;
    }
    handle(...args) {
      args.forEach((arg) => {
        if (Array.isArray(arg)) {
          return arg.forEach((handler) => this._addHandler(handler));
        }
        this._addHandler(arg);
      });
      if (!this.catcher) {
        this.catcher = this._unhandledRejection.bind(this);
        process.on("unhandledRejection", this.catcher);
      }
    }
    unhandle() {
      if (this.catcher) {
        process.removeListener("unhandledRejection", this.catcher);
        this.catcher = false;
        Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
      }
    }
    getAllInfo(err2) {
      let message = null;
      if (err2) {
        message = typeof err2 === "string" ? err2 : err2.message;
      }
      return {
        error: err2,
        level: "error",
        message: [
          `unhandledRejection: ${message || "(no error message)"}`,
          err2 && err2.stack || "  No stack trace"
        ].join("\n"),
        stack: err2 && err2.stack,
        rejection: true,
        date: new Date().toString(),
        process: this.getProcessInfo(),
        os: this.getOsInfo(),
        trace: this.getTrace(err2)
      };
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    }
    getOsInfo() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    }
    getTrace(err2) {
      const trace = err2 ? stackTrace.parse(err2) : stackTrace.get();
      return trace.map((site) => {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    }
    _addHandler(handler) {
      if (!this.handlers.has(handler)) {
        handler.handleRejections = true;
        const wrapper = new RejectionStream(handler);
        this.handlers.set(handler, wrapper);
        this.logger.pipe(wrapper);
      }
    }
    _unhandledRejection(err2) {
      const info = this.getAllInfo(err2);
      const handlers = this._getRejectionHandlers();
      let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err2) : this.logger.exitOnError;
      let timeout;
      if (!handlers.length && doExit) {
        console.warn("winston: exitOnError cannot be true with no rejection handlers.");
        console.warn("winston: not exiting process.");
        doExit = false;
      }
      function gracefulExit() {
        debug2("doExit", doExit);
        debug2("process._exiting", process._exiting);
        if (doExit && !process._exiting) {
          if (timeout) {
            clearTimeout(timeout);
          }
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return process.nextTick(gracefulExit);
      }
      asyncForEach(handlers, (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;
        function onDone(event) {
          return () => {
            debug2(event);
            done();
          };
        }
        transport._ending = true;
        transport.once("finish", onDone("finished"));
        transport.once("error", onDone("error"));
      }, () => doExit && gracefulExit());
      this.logger.log(info);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    }
    _getRejectionHandlers() {
      return this.logger.transports.filter((wrap) => {
        const transport = wrap.transport || wrap;
        return transport.handleRejections;
      });
    }
  };
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS((exports, module) => {
  class Profiler {
    constructor(logger) {
      const Logger = require_logger();
      if (typeof logger !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
        throw new Error("Logger is required for profiling");
      } else {
        this.logger = logger;
        this.start = Date.now();
      }
    }
    done(...args) {
      if (typeof args[args.length - 1] === "function") {
        console.warn("Callback function no longer supported as of winston@3.0.0");
        args.pop();
      }
      const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
      info.level = info.level || "info";
      info.durationMs = Date.now() - this.start;
      return this.logger.write(info);
    }
  }
  module.exports = Profiler;
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS((exports, module) => {
  var getLevelValue = function(levels, level) {
    const value26 = levels[level];
    if (!value26 && value26 !== 0) {
      return null;
    }
    return value26;
  };
  var { Stream, Transform: Transform2 } = require_readable();
  var asyncForEach = require_forEach();
  var { LEVEL, SPLAT } = require_triple_beam();
  var isStream = require_is_stream();
  var ExceptionHandler = require_exception_handler();
  var RejectionHandler = require_rejection_handler();
  var LegacyTransportStream = require_legacy();
  var Profiler = require_profiler();
  var { warn } = require_common2();
  var config = require_config2();
  var formatRegExp = /%[scdjifoO%]/g;

  class Logger extends Transform2 {
    constructor(options) {
      super({ objectMode: true });
      this.configure(options);
    }
    child(defaultRequestMetadata) {
      const logger = this;
      return Object.create(logger, {
        write: {
          value: function(info) {
            const infoClone = Object.assign({}, defaultRequestMetadata, info);
            if (info instanceof Error) {
              infoClone.stack = info.stack;
              infoClone.message = info.message;
            }
            logger.write(infoClone);
          }
        }
      });
    }
    configure({
      silent,
      format,
      defaultMeta,
      levels,
      level = "info",
      exitOnError = true,
      transports,
      colors,
      emitErrs,
      formatters,
      padLevels,
      rewriters,
      stripColors,
      exceptionHandlers,
      rejectionHandlers
    } = {}) {
      if (this.transports.length) {
        this.clear();
      }
      this.silent = silent;
      this.format = format || this.format || require_json()();
      this.defaultMeta = defaultMeta || null;
      this.levels = levels || this.levels || config.npm.levels;
      this.level = level;
      if (this.exceptions) {
        this.exceptions.unhandle();
      }
      if (this.rejections) {
        this.rejections.unhandle();
      }
      this.exceptions = new ExceptionHandler(this);
      this.rejections = new RejectionHandler(this);
      this.profilers = {};
      this.exitOnError = exitOnError;
      if (transports) {
        transports = Array.isArray(transports) ? transports : [transports];
        transports.forEach((transport) => this.add(transport));
      }
      if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
        throw new Error([
          "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
          "Use a custom winston.format(function) instead.",
          "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
        ].join("\n"));
      }
      if (exceptionHandlers) {
        this.exceptions.handle(exceptionHandlers);
      }
      if (rejectionHandlers) {
        this.rejections.handle(rejectionHandlers);
      }
    }
    isLevelEnabled(level) {
      const givenLevelValue = getLevelValue(this.levels, level);
      if (givenLevelValue === null) {
        return false;
      }
      const configuredLevelValue = getLevelValue(this.levels, this.level);
      if (configuredLevelValue === null) {
        return false;
      }
      if (!this.transports || this.transports.length === 0) {
        return configuredLevelValue >= givenLevelValue;
      }
      const index = this.transports.findIndex((transport) => {
        let transportLevelValue = getLevelValue(this.levels, transport.level);
        if (transportLevelValue === null) {
          transportLevelValue = configuredLevelValue;
        }
        return transportLevelValue >= givenLevelValue;
      });
      return index !== -1;
    }
    log(level, msg, ...splat) {
      if (arguments.length === 1) {
        level[LEVEL] = level.level;
        this._addDefaultMeta(level);
        this.write(level);
        return this;
      }
      if (arguments.length === 2) {
        if (msg && typeof msg === "object") {
          msg[LEVEL] = msg.level = level;
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        msg = { [LEVEL]: level, level, message: msg };
        this._addDefaultMeta(msg);
        this.write(msg);
        return this;
      }
      const [meta] = splat;
      if (typeof meta === "object" && meta !== null) {
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens) {
          const info = Object.assign({}, this.defaultMeta, meta, {
            [LEVEL]: level,
            [SPLAT]: splat,
            level,
            message: msg
          });
          if (meta.message)
            info.message = `${info.message} ${meta.message}`;
          if (meta.stack)
            info.stack = meta.stack;
          if (meta.cause)
            info.cause = meta.cause;
          this.write(info);
          return this;
        }
      }
      this.write(Object.assign({}, this.defaultMeta, {
        [LEVEL]: level,
        [SPLAT]: splat,
        level,
        message: msg
      }));
      return this;
    }
    _transform(info, enc, callback) {
      if (this.silent) {
        return callback();
      }
      if (!info[LEVEL]) {
        info[LEVEL] = info.level;
      }
      if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
        console.error("[winston] Unknown logger level: %s", info[LEVEL]);
      }
      if (!this._readableState.pipes) {
        console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", info);
      }
      try {
        this.push(this.format.transform(info, this.format.options));
      } finally {
        this._writableState.sync = false;
        callback();
      }
    }
    _final(callback) {
      const transports = this.transports.slice();
      asyncForEach(transports, (transport, next) => {
        if (!transport || transport.finished)
          return setImmediate(next);
        transport.once("finish", next);
        transport.end();
      }, callback);
    }
    add(transport) {
      const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
      if (!target._writableState || !target._writableState.objectMode) {
        throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
      }
      this._onEvent("error", target);
      this._onEvent("warn", target);
      this.pipe(target);
      if (transport.handleExceptions) {
        this.exceptions.handle();
      }
      if (transport.handleRejections) {
        this.rejections.handle();
      }
      return this;
    }
    remove(transport) {
      if (!transport)
        return this;
      let target = transport;
      if (!isStream(transport) || transport.log.length > 2) {
        target = this.transports.filter((match) => match.transport === transport)[0];
      }
      if (target) {
        this.unpipe(target);
      }
      return this;
    }
    clear() {
      this.unpipe();
      return this;
    }
    close() {
      this.exceptions.unhandle();
      this.rejections.unhandle();
      this.clear();
      this.emit("close");
      return this;
    }
    setLevels() {
      warn.deprecated("setLevels");
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const results = {};
      const queryObject = Object.assign({}, options.query || {});
      function queryTransport(transport, next) {
        if (options.query && typeof transport.formatQuery === "function") {
          options.query = transport.formatQuery(queryObject);
        }
        transport.query(options, (err2, res) => {
          if (err2) {
            return next(err2);
          }
          if (typeof transport.formatResults === "function") {
            res = transport.formatResults(res, options.format);
          }
          next(null, res);
        });
      }
      function addResults(transport, next) {
        queryTransport(transport, (err2, result) => {
          if (next) {
            result = err2 || result;
            if (result) {
              results[transport.name] = result;
            }
            next();
          }
          next = null;
        });
      }
      asyncForEach(this.transports.filter((transport) => !!transport.query), addResults, () => callback(null, results));
    }
    stream(options = {}) {
      const out = new Stream;
      const streams = [];
      out._streams = streams;
      out.destroy = () => {
        let i = streams.length;
        while (i--) {
          streams[i].destroy();
        }
      };
      this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
        const str = transport.stream(options);
        if (!str) {
          return;
        }
        streams.push(str);
        str.on("log", (log) => {
          log.transport = log.transport || [];
          log.transport.push(transport.name);
          out.emit("log", log);
        });
        str.on("error", (err2) => {
          err2.transport = err2.transport || [];
          err2.transport.push(transport.name);
          out.emit("error", err2);
        });
      });
      return out;
    }
    startTimer() {
      return new Profiler(this);
    }
    profile(id, ...args) {
      const time = Date.now();
      if (this.profilers[id]) {
        const timeEnd = this.profilers[id];
        delete this.profilers[id];
        if (typeof args[args.length - 2] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = time - timeEnd;
        info.message = info.message || id;
        return this.write(info);
      }
      this.profilers[id] = time;
      return this;
    }
    handleExceptions(...args) {
      console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
      this.exceptions.handle(...args);
    }
    unhandleExceptions(...args) {
      console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
      this.exceptions.unhandle(...args);
    }
    cli() {
      throw new Error([
        "Logger.cli() was removed in winston@3.0.0",
        "Use a custom winston.formats.cli() instead.",
        "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
      ].join("\n"));
    }
    _onEvent(event, transport) {
      function transportEvent(err2) {
        if (event === "error" && !this.transports.includes(transport)) {
          this.add(transport);
        }
        this.emit(event, err2, transport);
      }
      if (!transport["__winston" + event]) {
        transport["__winston" + event] = transportEvent.bind(this);
        transport.on(event, transport["__winston" + event]);
      }
    }
    _addDefaultMeta(msg) {
      if (this.defaultMeta) {
        Object.assign(msg, this.defaultMeta);
      }
    }
  }
  Object.defineProperty(Logger.prototype, "transports", {
    configurable: false,
    enumerable: true,
    get() {
      const { pipes } = this._readableState;
      return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
    }
  });
  module.exports = Logger;
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS((exports, module) => {
  var isLevelEnabledFunctionName = function(level) {
    return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
  };
  var { LEVEL } = require_triple_beam();
  var config = require_config2();
  var Logger = require_logger();
  var debug2 = require_node3()("winston:create-logger");
  module.exports = function(opts = {}) {
    opts.levels = opts.levels || config.npm.levels;

    class DerivedLogger extends Logger {
      constructor(options) {
        super(options);
      }
    }
    const logger = new DerivedLogger(opts);
    Object.keys(opts.levels).forEach(function(level) {
      debug2('Define prototype method for "%s"', level);
      if (level === "log") {
        console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
        return;
      }
      DerivedLogger.prototype[level] = function(...args) {
        const self2 = this || logger;
        if (args.length === 1) {
          const [msg] = args;
          const info = msg && msg.message && msg || { message: msg };
          info.level = info[LEVEL] = level;
          self2._addDefaultMeta(info);
          self2.write(info);
          return this || logger;
        }
        if (args.length === 0) {
          self2.log(level, "");
          return self2;
        }
        return self2.log(level, ...args);
      };
      DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
        return (this || logger).isLevelEnabled(level);
      };
    });
    return logger;
  };
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS((exports, module) => {
  var createLogger = require_create_logger();
  module.exports = class Container {
    constructor(options = {}) {
      this.loggers = new Map;
      this.options = options;
    }
    add(id, options) {
      if (!this.loggers.has(id)) {
        options = Object.assign({}, options || this.options);
        const existing = options.transports || this.options.transports;
        if (existing) {
          options.transports = Array.isArray(existing) ? existing.slice() : [existing];
        } else {
          options.transports = [];
        }
        const logger = createLogger(options);
        logger.on("close", () => this._delete(id));
        this.loggers.set(id, logger);
      }
      return this.loggers.get(id);
    }
    get(id, options) {
      return this.add(id, options);
    }
    has(id) {
      return !!this.loggers.has(id);
    }
    close(id) {
      if (id) {
        return this._removeLogger(id);
      }
      this.loggers.forEach((val, key) => this._removeLogger(key));
    }
    _removeLogger(id) {
      if (!this.loggers.has(id)) {
        return;
      }
      const logger = this.loggers.get(id);
      logger.close();
      this._delete(id);
    }
    _delete(id) {
      this.loggers.delete(id);
    }
  };
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS((exports) => {
  var logform = require_logform();
  var { warn } = require_common2();
  exports.version = require_package().version;
  exports.transports = require_transports();
  exports.config = require_config2();
  exports.addColors = logform.levels;
  exports.format = logform.format;
  exports.createLogger = require_create_logger();
  exports.Logger = require_logger();
  exports.ExceptionHandler = require_exception_handler();
  exports.RejectionHandler = require_rejection_handler();
  exports.Container = require_container();
  exports.Transport = require_winston_transport();
  exports.loggers = new exports.Container;
  var defaultLogger = exports.createLogger();
  Object.keys(exports.config.npm.levels).concat([
    "log",
    "query",
    "stream",
    "add",
    "remove",
    "clear",
    "profile",
    "startTimer",
    "handleExceptions",
    "unhandleExceptions",
    "handleRejections",
    "unhandleRejections",
    "configure",
    "child"
  ]).forEach((method) => exports[method] = (...args) => defaultLogger[method](...args));
  Object.defineProperty(exports, "level", {
    get() {
      return defaultLogger.level;
    },
    set(val) {
      defaultLogger.level = val;
    }
  });
  Object.defineProperty(exports, "exceptions", {
    get() {
      return defaultLogger.exceptions;
    }
  });
  Object.defineProperty(exports, "rejections", {
    get() {
      return defaultLogger.rejections;
    }
  });
  ["exitOnError"].forEach((prop) => {
    Object.defineProperty(exports, prop, {
      get() {
        return defaultLogger[prop];
      },
      set(val) {
        defaultLogger[prop] = val;
      }
    });
  });
  Object.defineProperty(exports, "default", {
    get() {
      return {
        exceptionHandlers: defaultLogger.exceptionHandlers,
        rejectionHandlers: defaultLogger.rejectionHandlers,
        transports: defaultLogger.transports
      };
    }
  });
  warn.deprecated(exports, "setLevels");
  warn.forFunctions(exports, "useFormat", ["cli"]);
  warn.forProperties(exports, "useFormat", ["padLevels", "stripColors"]);
  warn.forFunctions(exports, "deprecated", [
    "addRewriter",
    "addFilter",
    "clone",
    "extend"
  ]);
  warn.forProperties(exports, "deprecated", ["emitErrs", "levelLength"]);
});

// node_modules/object-hash/index.js
var require_object_hash = __commonJS((exports, module) => {
  var objectHash = function(object12, options) {
    options = applyDefaults(object12, options);
    return hash5(object12, options);
  };
  var applyDefaults = function(object12, sourceOptions) {
    sourceOptions = sourceOptions || {};
    var options = {};
    options.algorithm = sourceOptions.algorithm || "sha1";
    options.encoding = sourceOptions.encoding || "hex";
    options.excludeValues = sourceOptions.excludeValues ? true : false;
    options.algorithm = options.algorithm.toLowerCase();
    options.encoding = options.encoding.toLowerCase();
    options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true;
    options.respectType = sourceOptions.respectType === false ? false : true;
    options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
    options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
    options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true;
    options.unorderedSets = sourceOptions.unorderedSets === false ? false : true;
    options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true;
    options.replacer = sourceOptions.replacer || undefined;
    options.excludeKeys = sourceOptions.excludeKeys || undefined;
    if (typeof object12 === "undefined") {
      throw new Error("Object argument required.");
    }
    for (var i = 0;i < hashes.length; ++i) {
      if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
        options.algorithm = hashes[i];
      }
    }
    if (hashes.indexOf(options.algorithm) === -1) {
      throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
    }
    if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
      throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
    }
    return options;
  };
  var isNativeFunction = function(f) {
    if (typeof f !== "function") {
      return false;
    }
    var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
    return exp.exec(Function.prototype.toString.call(f)) != null;
  };
  var hash5 = function(object12, options) {
    var hashingStream;
    if (options.algorithm !== "passthrough") {
      hashingStream = crypto2.createHash(options.algorithm);
    } else {
      hashingStream = new PassThrough2;
    }
    if (typeof hashingStream.write === "undefined") {
      hashingStream.write = hashingStream.update;
      hashingStream.end = hashingStream.update;
    }
    var hasher = typeHasher(options, hashingStream);
    hasher.dispatch(object12);
    if (!hashingStream.update) {
      hashingStream.end("");
    }
    if (hashingStream.digest) {
      return hashingStream.digest(options.encoding === "buffer" ? undefined : options.encoding);
    }
    var buf = hashingStream.read();
    if (options.encoding === "buffer") {
      return buf;
    }
    return buf.toString(options.encoding);
  };
  var typeHasher = function(options, writeTo, context) {
    context = context || [];
    var write = function(str) {
      if (writeTo.update) {
        return writeTo.update(str, "utf8");
      } else {
        return writeTo.write(str, "utf8");
      }
    };
    return {
      dispatch: function(value26) {
        if (options.replacer) {
          value26 = options.replacer(value26);
        }
        var type54 = typeof value26;
        if (value26 === null) {
          type54 = "null";
        }
        return this["_" + type54](value26);
      },
      _object: function(object12) {
        var pattern2 = /\[object (.*)\]/i;
        var objString = Object.prototype.toString.call(object12);
        var objType = pattern2.exec(objString);
        if (!objType) {
          objType = "unknown:[" + objString + "]";
        } else {
          objType = objType[1];
        }
        objType = objType.toLowerCase();
        var objectNumber = null;
        if ((objectNumber = context.indexOf(object12)) >= 0) {
          return this.dispatch("[CIRCULAR:" + objectNumber + "]");
        } else {
          context.push(object12);
        }
        if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object12)) {
          write("buffer:");
          return write(object12);
        }
        if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
          if (this["_" + objType]) {
            this["_" + objType](object12);
          } else if (options.ignoreUnknown) {
            return write("[" + objType + "]");
          } else {
            throw new Error('Unknown object type "' + objType + '"');
          }
        } else {
          var keys = Object.keys(object12);
          if (options.unorderedObjects) {
            keys = keys.sort();
          }
          if (options.respectType !== false && !isNativeFunction(object12)) {
            keys.splice(0, 0, "prototype", "__proto__", "constructor");
          }
          if (options.excludeKeys) {
            keys = keys.filter(function(key) {
              return !options.excludeKeys(key);
            });
          }
          write("object:" + keys.length + ":");
          var self2 = this;
          return keys.forEach(function(key) {
            self2.dispatch(key);
            write(":");
            if (!options.excludeValues) {
              self2.dispatch(object12[key]);
            }
            write(",");
          });
        }
      },
      _array: function(arr, unordered) {
        unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false;
        var self2 = this;
        write("array:" + arr.length + ":");
        if (!unordered || arr.length <= 1) {
          return arr.forEach(function(entry) {
            return self2.dispatch(entry);
          });
        }
        var contextAdditions = [];
        var entries = arr.map(function(entry) {
          var strm = new PassThrough2;
          var localContext = context.slice();
          var hasher = typeHasher(options, strm, localContext);
          hasher.dispatch(entry);
          contextAdditions = contextAdditions.concat(localContext.slice(context.length));
          return strm.read().toString();
        });
        context = context.concat(contextAdditions);
        entries.sort();
        return this._array(entries, false);
      },
      _date: function(date3) {
        return write("date:" + date3.toJSON());
      },
      _symbol: function(sym) {
        return write("symbol:" + sym.toString());
      },
      _error: function(err2) {
        return write("error:" + err2.toString());
      },
      _boolean: function(bool) {
        return write("bool:" + bool.toString());
      },
      _string: function(string5) {
        write("string:" + string5.length + ":");
        write(string5.toString());
      },
      _function: function(fn) {
        write("fn:");
        if (isNativeFunction(fn)) {
          this.dispatch("[native]");
        } else {
          this.dispatch(fn.toString());
        }
        if (options.respectFunctionNames !== false) {
          this.dispatch("function-name:" + String(fn.name));
        }
        if (options.respectFunctionProperties) {
          this._object(fn);
        }
      },
      _number: function(number5) {
        return write("number:" + number5.toString());
      },
      _xml: function(xml) {
        return write("xml:" + xml.toString());
      },
      _null: function() {
        return write("Null");
      },
      _undefined: function() {
        return write("Undefined");
      },
      _regexp: function(regex2) {
        return write("regex:" + regex2.toString());
      },
      _uint8array: function(arr) {
        write("uint8array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _uint8clampedarray: function(arr) {
        write("uint8clampedarray:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _int8array: function(arr) {
        write("uint8array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _uint16array: function(arr) {
        write("uint16array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _int16array: function(arr) {
        write("uint16array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _uint32array: function(arr) {
        write("uint32array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _int32array: function(arr) {
        write("uint32array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _float32array: function(arr) {
        write("float32array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _float64array: function(arr) {
        write("float64array:");
        return this.dispatch(Array.prototype.slice.call(arr));
      },
      _arraybuffer: function(arr) {
        write("arraybuffer:");
        return this.dispatch(new Uint8Array(arr));
      },
      _url: function(url) {
        return write("url:" + url.toString(), "utf8");
      },
      _map: function(map3) {
        write("map:");
        var arr = Array.from(map3);
        return this._array(arr, options.unorderedSets !== false);
      },
      _set: function(set2) {
        write("set:");
        var arr = Array.from(set2);
        return this._array(arr, options.unorderedSets !== false);
      },
      _file: function(file) {
        write("file:");
        return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
      },
      _blob: function() {
        if (options.ignoreUnknown) {
          return write("[blob]");
        }
        throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
      },
      _domwindow: function() {
        return write("domwindow");
      },
      _bigint: function(number5) {
        return write("bigint:" + number5.toString());
      },
      _process: function() {
        return write("process");
      },
      _timer: function() {
        return write("timer");
      },
      _pipe: function() {
        return write("pipe");
      },
      _tcp: function() {
        return write("tcp");
      },
      _udp: function() {
        return write("udp");
      },
      _tty: function() {
        return write("tty");
      },
      _statwatcher: function() {
        return write("statwatcher");
      },
      _securecontext: function() {
        return write("securecontext");
      },
      _connection: function() {
        return write("connection");
      },
      _zlib: function() {
        return write("zlib");
      },
      _context: function() {
        return write("context");
      },
      _nodescript: function() {
        return write("nodescript");
      },
      _httpparser: function() {
        return write("httpparser");
      },
      _dataview: function() {
        return write("dataview");
      },
      _signal: function() {
        return write("signal");
      },
      _fsevent: function() {
        return write("fsevent");
      },
      _tlswrap: function() {
        return write("tlswrap");
      }
    };
  };
  var PassThrough2 = function() {
    return {
      buf: "",
      write: function(b) {
        this.buf += b;
      },
      end: function(b) {
        this.buf += b;
      },
      read: function() {
        return this.buf;
      }
    };
  };
  var crypto2 = import.meta.require("crypto");
  exports = module.exports = objectHash;
  exports.sha1 = function(object12) {
    return objectHash(object12);
  };
  exports.keys = function(object12) {
    return objectHash(object12, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
  };
  exports.MD5 = function(object12) {
    return objectHash(object12, { algorithm: "md5", encoding: "hex" });
  };
  exports.keysMD5 = function(object12) {
    return objectHash(object12, { algorithm: "md5", encoding: "hex", excludeValues: true });
  };
  var hashes = crypto2.getHashes ? crypto2.getHashes().slice() : ["sha1", "md5"];
  hashes.push("passthrough");
  var encodings = ["buffer", "hex", "binary", "base64"];
  exports.writeToStream = function(object12, options, stream7) {
    if (typeof stream7 === "undefined") {
      stream7 = options;
      options = {};
    }
    options = applyDefaults(object12, options);
    return typeHasher(options, stream7).dispatch(object12);
  };
});

// node_modules/moment/moment.js
var require_moment = __commonJS((exports, module) => {
  //! moment.js
  //! version : 2.30.1
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
  })(exports, function() {
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject2(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k2;
        for (k2 in obj) {
          if (hasOwnProp(obj, k2)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === undefined;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map3(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0;i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i;
        for (i = 0;i < len; i++) {
          if (i in t2 && fun.call(this, t2[i], i, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m) {
      var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m);
        parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0;i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0;i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set2(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number5, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number5), zerosToFill = targetLength - absNumber.length, sign2 = number5 >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(func.apply(this, arguments), token2);
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array3 = format2.match(formattingTokens), i, length;
      for (i = 0, length = array3.length;i < length; i++) {
        if (formatTokenFunctions[array3[i]]) {
          array3[i] = formatTokenFunctions[array3[i]];
        } else {
          array3[i] = removeFormattingTokens(array3[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0;i2 < length; i2++) {
          output += isFunction(array3[i2]) ? array3[i2].call(mom, format2) : array3[i2];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number5) {
      return this._ordinal.replace("%d", number5);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number5, withoutSuffix, string5, isFuture) {
      var output = this._relativeTime[string5];
      return isFunction(output) ? output(number5, withoutSuffix, string5, isFuture) : output.replace(/%d/i, number5);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units.push({ unit: u, priority: priorities[u] });
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex2, strictRegex) {
      regexes[token2] = isFunction(regex2) ? regex2 : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex2;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number5) {
      if (number5 < 0) {
        return Math.ceil(number5) || 0;
      } else {
        return Math.floor(number5);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value26 = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value26 = absFloor(coercedNumber);
      }
      return value26;
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array3) {
          array3[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0;i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array3, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE2 = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array3) {
      array3[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array3) {
      array3[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array3) {
      array3[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear2(this.year());
    }
    function makeGetSet(unit, keepTime) {
      return function(value26) {
        if (value26 != null) {
          set$1(this, unit, value26);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }
    function get(mom, unit) {
      if (!mom.isValid()) {
        return NaN;
      }
      var { _d: d, _isUTC: isUTC } = mom;
      switch (unit) {
        case "Milliseconds":
          return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
        case "Seconds":
          return isUTC ? d.getUTCSeconds() : d.getSeconds();
        case "Minutes":
          return isUTC ? d.getUTCMinutes() : d.getMinutes();
        case "Hours":
          return isUTC ? d.getUTCHours() : d.getHours();
        case "Date":
          return isUTC ? d.getUTCDate() : d.getDate();
        case "Day":
          return isUTC ? d.getUTCDay() : d.getDay();
        case "Month":
          return isUTC ? d.getUTCMonth() : d.getMonth();
        case "FullYear":
          return isUTC ? d.getUTCFullYear() : d.getFullYear();
        default:
          return NaN;
      }
    }
    function set$1(mom, unit, value26) {
      var d, isUTC, year, month, date3;
      if (!mom.isValid() || isNaN(value26)) {
        return;
      }
      d = mom._d;
      isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return void (isUTC ? d.setUTCMilliseconds(value26) : d.setMilliseconds(value26));
        case "Seconds":
          return void (isUTC ? d.setUTCSeconds(value26) : d.setSeconds(value26));
        case "Minutes":
          return void (isUTC ? d.setUTCMinutes(value26) : d.setMinutes(value26));
        case "Hours":
          return void (isUTC ? d.setUTCHours(value26) : d.setHours(value26));
        case "Date":
          return void (isUTC ? d.setUTCDate(value26) : d.setDate(value26));
        case "FullYear":
          break;
        default:
          return;
      }
      year = value26;
      month = mom.month();
      date3 = mom.date();
      date3 = date3 === 29 && month === 1 && !isLeapYear2(year) ? 28 : date3;
      isUTC ? d.setUTCFullYear(year, month, date3) : d.setFullYear(year, month, date3);
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value26) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0;i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value26);
        }
      }
      return this;
    }
    function mod(n, x) {
      return (n % x + x) % x;
    }
    var indexOf2;
    if (Array.prototype.indexOf) {
      indexOf2 = Array.prototype.indexOf;
    } else {
      indexOf2 = function(o) {
        var i;
        for (i = 0;i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear2(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array3) {
      array3[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array3, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array3[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0;i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf2.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf2.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf2.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf2.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex2;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0;i < 12; i++) {
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
          this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
        }
        if (!strict && !this._monthsParse[i]) {
          regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex2.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value26) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value26 === "string") {
        if (/^\d+$/.test(value26)) {
          value26 = toInt(value26);
        } else {
          value26 = mom.localeData().monthsParse(value26);
          if (!isNumber(value26)) {
            return mom;
          }
        }
      }
      var month = value26, date3 = mom.date();
      date3 = date3 < 29 ? date3 : Math.min(date3, daysInMonth(mom.year(), month));
      mom._isUTC ? mom._d.setUTCMonth(month, date3) : mom._d.setMonth(month, date3);
      return mom;
    }
    function getSetMonth(value26) {
      if (value26 != null) {
        setMonth(this, value26);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
      for (i = 0;i < 12; i++) {
        mom = createUTC([2000, i]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
      this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    function createDate(y, m, d, h, M, s, ms) {
      var date3;
      if (y < 100 && y >= 0) {
        date3 = new Date(y + 400, m, d, h, M, s, ms);
        if (isFinite(date3.getFullYear())) {
          date3.setFullYear(y);
        }
      } else {
        date3 = new Date(y, m, d, h, M, s, ms);
      }
      return date3;
    }
    function createUTCDate(y) {
      var date3, args;
      if (y < 100 && y >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y + 400;
        date3 = new Date(Date.UTC.apply(null, args));
        if (isFinite(date3.getUTCFullYear())) {
          date3.setUTCFullYear(y);
        }
      } else {
        date3 = new Date(Date.UTC.apply(null, arguments));
      }
      return date3;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
      week[token2.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0;i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf2.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf2.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf2.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf2.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf2.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf2.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf2.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex2;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0;i < 7; i++) {
        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
          this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
          this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
        }
        if (!this._weekdaysParse[i]) {
          regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex2.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0;i < 7; i++) {
        mom = createUTC([2000, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
      this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array3, config) {
      var kInput = toInt(input);
      array3[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array3, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array3, config) {
      array3[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array3, config) {
      var pos = input.length - 2;
      array3[HOUR] = toInt(input.substr(0, pos));
      array3[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array3, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array3[HOUR] = toInt(input.substr(0, pos1));
      array3[MINUTE] = toInt(input.substr(pos1, 2));
      array3[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array3, config) {
      var pos = input.length - 2;
      array3[HOUR] = toInt(input.substr(0, pos));
      array3[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array3, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array3[HOUR] = toInt(input.substr(0, pos1));
      array3[MINUTE] = toInt(input.substr(pos1, 2));
      array3[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0;i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return !!(name && name.match("^[^/\\\\]*$"));
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === undefined && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn("Locale " + key + " not found. Did you forget to load it?");
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x) {
            defineLocale(x.name, x.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE2] < 1 || a[DATE2] > daysInMonth(a[YEAR], a[MONTH]) ? DATE2 : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE2)) {
          overflow = DATE2;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l, string5 = config._i, match = extendedIsoRegex.exec(string5) || basicIsoRegex.exec(string5), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDatesLen;i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimesLen;i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
      config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date3, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE2] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date3 = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date3.getUTCMonth();
        config._a[DATE2] = date3.getUTCDate();
      }
      for (i = 0;i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (;i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
        week = defaults(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string5 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string5.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0;i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string5.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string5.substr(0, string5.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string5 = string5.slice(string5.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string5.length > 0) {
        getParsingFlags(config).unusedInput.push(string5);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i = 0;i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;
      config._a = map3([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = undefined;
      }
      return res;
    }
    function prepareConfig(config) {
      var { _i: input, _f: format2 } = config;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === undefined && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map3(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject2(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = undefined;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = undefined;
      }
      if (isObject2(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var other = createLocal.apply(null, arguments);
      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    });
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1;i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max2() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +new Date;
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf2.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i = 0;i < orderLen; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1000 + minutes2 * 60000 + hours2 * 1000 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number5) {
      if (number5 < 0) {
        return Math.round(-1 * number5) * -1;
      } else {
        return Math.round(number5);
      }
    }
    function compareArrays(array1, array22, dontConvert) {
      var len = Math.min(array1.length, array22.length), lengthDiff = Math.abs(array1.length - array22.length), diffs = 0, i;
      for (i = 0;i < len; i++) {
        if (dontConvert && array1[i] !== array22[i] || !dontConvert && toInt(array1[i]) !== toInt(array22[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array3, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string5) {
      var matches = (string5 || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset2, "m"), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret2, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE2]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign2
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && (("from" in duration) || ("to" in duration))) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret2 = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret2._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret2._isValid = input._isValid;
      }
      return ret2;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties.length;
      for (i = 0;i < propertyLen; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0;i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = undefined;
          formats = undefined;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = undefined;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = undefined;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
    }
    function clone11() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 60000;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1000;
          break;
        case "minute":
          output = (this - that) / 60000;
          break;
        case "hour":
          output = (this - that) / 3600000;
          break;
        case "day":
          output = (this - that - zoneDelta) / 86400000;
          break;
        case "week":
          output = (this - that - zoneDelta) / 604800000;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1000, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }
    function utcStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === undefined || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;
        case "isoWeek":
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === undefined || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;
        case "isoWeek":
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array3, config, token2) {
      var era = config._locale.erasParse(input, token2, config._strict);
      if (era) {
        getParsingFlags(config).era = era;
      } else {
        getParsingFlags(config).invalidEra = input;
      }
    });
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array3, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array3[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array3[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i, l, date3, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l = eras.length;i < l; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date3 = hooks(eras[i].since).startOf("day");
            eras[i].since = date3.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date3 = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date3.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l = eras.length;i < l; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === undefined) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length;i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length;i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length;i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l, dir, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length;i < l; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i = 0, l = eras.length;i < l; ++i) {
        erasName = regexEscape(eras[i].name);
        erasAbbr = regexEscape(eras[i].abbr);
        erasNarrow = regexEscape(eras[i].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
      week[token2.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date3 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date3.getUTCFullYear());
      this.month(date3.getUTCMonth());
      this.date(date3.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array3) {
      array3[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE2);
    addParseToken("Do", function(input, array3) {
      array3[DATE2] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array3, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 86400000) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS";token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array3) {
      array3[MILLISECOND] = toInt(("0." + input) * 1000);
    }
    for (token = "S";token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone11;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    function createUnix(input) {
      return createLocal(input * 1000);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string5) {
      return string5;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set2;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index, field) {
      if (isNumber(format2)) {
        index = format2;
        format2 = undefined;
      }
      format2 = format2 || "";
      if (index != null) {
        return get$1(format2, index, field, "month");
      }
      var i, out = [];
      for (i = 0;i < 12; i++) {
        out[i] = get$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index = format2;
          format2 = undefined;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index = format2;
          format2 = undefined;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index != null) {
        return get$1(format2, (index + shift) % 7, field, "day");
      }
      for (i = 0;i < 7; i++) {
        out[i] = get$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index) {
      return listMonthsImpl(format2, index, "months");
    }
    function listMonthsShort(format2, index) {
      return listMonthsImpl(format2, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: (-Infinity),
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number5) {
        var b = number5 % 10, output = toInt(number5 % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number5 + output;
      }
    });
    hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value26, direction) {
      var other = createDuration(input, value26);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value26) {
      return addSubtract$1(this, input, value26, 1);
    }
    function subtract$1(input, value26) {
      return addSubtract$1(this, input, value26, -1);
    }
    function absCeil(number5) {
      if (number5 < 0) {
        return Math.floor(number5);
      } else {
        return Math.ceil(number5);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 86400000;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1000;
      seconds2 = absFloor(milliseconds2 / 1000);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 86400000;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 604800000;
          case "day":
            return days2 + milliseconds2 / 86400000;
          case "hour":
            return days2 * 24 + milliseconds2 / 3600000;
          case "minute":
            return days2 * 1440 + milliseconds2 / 60000;
          case "second":
            return days2 * 86400 + milliseconds2 / 1000;
          case "millisecond":
            return Math.floor(days2 * 86400000) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      w: null,
      M: 11
    };
    function substituteTimeAgo(string5, number5, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number5 || 1, !!withoutSuffix, string5, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }
      if (limit === undefined) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1000, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array3, config) {
      config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken("x", function(input, array3, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max2;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    };
    return hooks;
  });
});

// node_modules/file-stream-rotator/FileStreamRotator.js
var require_FileStreamRotator = __commonJS((exports, module) => {
  var removeFile = function(file, verbose) {
    if (file.hash === crypto2.createHash(file.hashType).update(file.name + "LOG_FILE" + file.date).digest("hex")) {
      try {
        if (fs.existsSync(file.name)) {
          fs.unlinkSync(file.name);
        }
      } catch (e) {
        if (verbose) {
          console.error(new Date, "[FileStreamRotator] Could not remove old log file: ", file.name);
        }
      }
    }
  };
  var createCurrentSymLink = function(logfile, name, verbose) {
    let symLinkName = name || "current.log";
    let logPath = path.dirname(logfile);
    let logfileName = path.basename(logfile);
    let current = logPath + "/" + symLinkName;
    try {
      let stats = fs.lstatSync(current);
      if (stats.isSymbolicLink()) {
        fs.unlinkSync(current);
        fs.symlinkSync(logfileName, current);
      }
    } catch (err2) {
      if (err2 && err2.code == "ENOENT") {
        try {
          fs.symlinkSync(logfileName, current);
        } catch (e) {
          if (verbose) {
            console.error(new Date, "[FileStreamRotator] Could not create symlink file: ", current, " -> ", logfileName);
          }
        }
      }
    }
  };
  var createLogWatcher = function(logfile, verbose, cb) {
    if (!logfile)
      return null;
    try {
      let stats = fs.lstatSync(logfile);
      return fs.watch(logfile, function(event, filename) {
        if (event == "rename") {
          try {
            let stats2 = fs.lstatSync(logfile);
          } catch (err2) {
            cb(err2, logfile);
          }
        }
      });
    } catch (err2) {
      if (verbose) {
        console.log(new Date, "[FileStreamRotator] Could not add watcher for " + logfile);
      }
    }
  };
  /*!
   * FileStreamRotator
   * Copyright(c) 2012-2017 Holiday Extras.
   * Copyright(c) 2017 Roger C.
   * MIT Licensed
   */
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var moment = require_moment();
  var crypto2 = import.meta.require("crypto");
  var EventEmitter = import.meta.require("events");
  var FileStreamRotator = {};
  module.exports = FileStreamRotator;
  var staticFrequency = ["daily", "test", "m", "h", "custom"];
  var DATE_FORMAT = "YYYYMMDDHHmm";
  var _checkNumAndType = function(type54, num) {
    if (typeof num == "number") {
      switch (type54) {
        case "m":
          if (num < 0 || num > 60) {
            return false;
          }
          break;
        case "h":
          if (num < 0 || num > 24) {
            return false;
          }
          break;
      }
      return { type: type54, digit: num };
    }
  };
  var _checkDailyAndTest = function(freqType) {
    switch (freqType) {
      case "custom":
      case "daily":
        return { type: freqType, digit: undefined };
        break;
      case "test":
        return { type: freqType, digit: 0 };
    }
    return false;
  };
  FileStreamRotator.getFrequency = function(frequency) {
    var _f = frequency.toLowerCase().match(/^(\d+)([mh])$/);
    if (_f) {
      return _checkNumAndType(_f[2], parseInt(_f[1]));
    }
    var dailyOrTest = _checkDailyAndTest(frequency);
    if (dailyOrTest) {
      return dailyOrTest;
    }
    return false;
  };
  FileStreamRotator.parseFileSize = function(size) {
    if (size && typeof size == "string") {
      var _s = size.toLowerCase().match(/^((?:0\.)?\d+)([kmg])$/);
      if (_s) {
        switch (_s[2]) {
          case "k":
            return _s[1] * 1024;
          case "m":
            return _s[1] * 1024 * 1024;
          case "g":
            return _s[1] * 1024 * 1024 * 1024;
        }
      }
    }
    return null;
  };
  FileStreamRotator.getDate = function(format, date_format, utc) {
    date_format = date_format || DATE_FORMAT;
    let currentMoment = utc ? moment.utc() : moment().local();
    if (format && staticFrequency.indexOf(format.type) !== -1) {
      switch (format.type) {
        case "m":
          var minute = Math.floor(currentMoment.minutes() / format.digit) * format.digit;
          return currentMoment.minutes(minute).format(date_format);
          break;
        case "h":
          var hour = Math.floor(currentMoment.hour() / format.digit) * format.digit;
          return currentMoment.hour(hour).format(date_format);
          break;
        case "daily":
        case "custom":
        case "test":
          return currentMoment.format(date_format);
      }
    }
    return currentMoment.format(date_format);
  };
  FileStreamRotator.setAuditLog = function(max_logs, audit_file, log_file) {
    var _rtn = null;
    if (max_logs) {
      var use_days = max_logs.toString().substr(-1);
      var _num = max_logs.toString().match(/^(\d+)/);
      if (Number(_num[1]) > 0) {
        var baseLog = path.dirname(log_file.replace(/%DATE%.+/, "_filename"));
        try {
          if (audit_file) {
            var full_path = path.resolve(audit_file);
            _rtn = JSON.parse(fs.readFileSync(full_path, { encoding: "utf-8" }));
          } else {
            var full_path = path.resolve(baseLog + "/.audit.json");
            _rtn = JSON.parse(fs.readFileSync(full_path, { encoding: "utf-8" }));
          }
        } catch (e) {
          if (e.code !== "ENOENT") {
            return null;
          }
          _rtn = {
            keep: {
              days: false,
              amount: Number(_num[1])
            },
            auditLog: audit_file || baseLog + "/.audit.json",
            files: []
          };
        }
        _rtn.keep = {
          days: use_days === "d",
          amount: Number(_num[1])
        };
      }
    }
    return _rtn;
  };
  FileStreamRotator.writeAuditLog = function(audit, verbose) {
    try {
      mkDirForFile(audit.auditLog);
      fs.writeFileSync(audit.auditLog, JSON.stringify(audit, null, 4));
    } catch (e) {
      if (verbose) {
        console.error(new Date, "[FileStreamRotator] Failed to store log audit at:", audit.auditLog, "Error:", e);
      }
    }
  };
  FileStreamRotator.addLogToAudit = function(logfile, audit, stream7, verbose) {
    if (audit && audit.files) {
      var index = audit.files.findIndex(function(file) {
        return file.name === logfile;
      });
      if (index !== -1) {
        return audit;
      }
      var time = Date.now();
      audit.files.push({
        date: time,
        name: logfile,
        hash: crypto2.createHash(audit.hashType).update(logfile + "LOG_FILE" + time).digest("hex")
      });
      if (audit.keep.days) {
        var oldestDate = moment().subtract(audit.keep.amount, "days").valueOf();
        var recentFiles = audit.files.filter(function(file) {
          if (file.date > oldestDate) {
            return true;
          }
          file.hashType = audit.hashType;
          removeFile(file, verbose);
          stream7.emit("logRemoved", file);
          return false;
        });
        audit.files = recentFiles;
      } else {
        var filesToKeep = audit.files.splice(-audit.keep.amount);
        if (audit.files.length > 0) {
          audit.files.filter(function(file) {
            file.hashType = audit.hashType;
            removeFile(file, verbose);
            stream7.emit("logRemoved", file);
            return false;
          });
        }
        audit.files = filesToKeep;
      }
      FileStreamRotator.writeAuditLog(audit, verbose);
    }
    return audit;
  };
  FileStreamRotator.getStream = function(options) {
    var frequencyMetaData = null;
    var curDate = null;
    var self2 = this;
    if (!options.filename) {
      console.error(new Date, "[FileStreamRotator] No filename supplied. Defaulting to STDOUT");
      return process.stdout;
    }
    if (options.frequency) {
      frequencyMetaData = self2.getFrequency(options.frequency);
    }
    let auditLog = self2.setAuditLog(options.max_logs, options.audit_file, options.filename);
    if (auditLog != null) {
      auditLog.hashType = options.audit_hash_type !== undefined ? options.audit_hash_type : "md5";
    }
    self2.verbose = options.verbose !== undefined ? options.verbose : true;
    var fileSize = null;
    var fileCount = 0;
    var curSize = 0;
    if (options.size) {
      fileSize = FileStreamRotator.parseFileSize(options.size);
    }
    var dateFormat = options.date_format || DATE_FORMAT;
    if (frequencyMetaData && frequencyMetaData.type == "daily") {
      if (!options.date_format) {
        dateFormat = "YYYY-MM-DD";
      }
      if (moment().format(dateFormat) != moment().endOf("day").format(dateFormat) || moment().format(dateFormat) == moment().add(1, "day").format(dateFormat)) {
        if (self2.verbose) {
          console.log(new Date, "[FileStreamRotator] Changing type to custom as date format changes more often than once a day or not every day");
        }
        frequencyMetaData.type = "custom";
      }
    }
    if (frequencyMetaData) {
      curDate = options.frequency ? self2.getDate(frequencyMetaData, dateFormat, options.utc) : "";
    }
    options.create_symlink = options.create_symlink || false;
    options.extension = options.extension || "";
    var filename = options.filename;
    var oldFile = null;
    var logfile = filename + (curDate ? "." + curDate : "");
    if (filename.match(/%DATE%/)) {
      logfile = filename.replace(/%DATE%/g, curDate ? curDate : self2.getDate(null, dateFormat, options.utc));
    }
    if (fileSize) {
      var lastLogFile = null;
      var t_log = logfile;
      var f = null;
      if (auditLog && auditLog.files && auditLog.files instanceof Array && auditLog.files.length > 0) {
        var lastEntry = auditLog.files[auditLog.files.length - 1].name;
        if (lastEntry.match(t_log)) {
          var lastCount = lastEntry.match(t_log + "\\.(\\d+)");
          if (lastCount) {
            t_log = lastEntry;
            fileCount = lastCount[1];
          }
        }
      }
      if (fileCount == 0 && t_log == logfile) {
        t_log += options.extension;
      }
      while (f = fs.existsSync(t_log)) {
        lastLogFile = t_log;
        fileCount++;
        t_log = logfile + "." + fileCount + options.extension;
      }
      if (lastLogFile) {
        var lastLogFileStats = fs.statSync(lastLogFile);
        if (lastLogFileStats.size < fileSize) {
          t_log = lastLogFile;
          fileCount--;
          curSize = lastLogFileStats.size;
        }
      }
      logfile = t_log;
    } else {
      logfile += options.extension;
    }
    if (self2.verbose) {
      console.log(new Date, "[FileStreamRotator] Logging to: ", logfile);
    }
    mkDirForFile(logfile);
    var file_options = options.file_options || { flags: "a" };
    var rotateStream = fs.createWriteStream(logfile, file_options);
    if (curDate && frequencyMetaData && staticFrequency.indexOf(frequencyMetaData.type) > -1 || fileSize > 0) {
      if (self2.verbose) {
        console.log(new Date, "[FileStreamRotator] Rotating file: ", frequencyMetaData ? frequencyMetaData.type : "", fileSize ? "size: " + fileSize : "");
      }
      var stream7 = new EventEmitter;
      stream7.auditLog = auditLog;
      stream7.end = function() {
        rotateStream.end.apply(rotateStream, arguments);
      };
      BubbleEvents(rotateStream, stream7);
      stream7.on("close", function() {
        if (logWatcher) {
          logWatcher.close();
        }
      });
      stream7.on("new", function(newLog) {
        stream7.auditLog = self2.addLogToAudit(newLog, stream7.auditLog, stream7, self2.verbose);
        if (options.create_symlink) {
          createCurrentSymLink(newLog, options.symlink_name, self2.verbose);
        }
        if (options.watch_log) {
          stream7.emit("addWatcher", newLog);
        }
      });
      var logWatcher;
      stream7.on("addWatcher", function(newLog) {
        if (logWatcher) {
          logWatcher.close();
        }
        if (!options.watch_log) {
          return;
        }
        logWatcher = createLogWatcher(newLog, self2.verbose, function(err2, newLog2) {
          stream7.emit("createLog", newLog2);
        });
      });
      stream7.on("createLog", function(file) {
        try {
          let stats = fs.lstatSync(file);
        } catch (err2) {
          if (rotateStream && rotateStream.end == "function") {
            rotateStream.end();
          }
          rotateStream = fs.createWriteStream(file, file_options);
          stream7.emit("new", file);
          BubbleEvents(rotateStream, stream7);
        }
      });
      stream7.write = function(str, encoding) {
        var newDate = frequencyMetaData ? this.getDate(frequencyMetaData, dateFormat, options.utc) : curDate;
        if (newDate != curDate || fileSize && curSize > fileSize) {
          var newLogfile = filename + (curDate && frequencyMetaData ? "." + newDate : "");
          if (filename.match(/%DATE%/) && curDate) {
            newLogfile = filename.replace(/%DATE%/g, newDate);
          }
          if (fileSize && curSize > fileSize) {
            fileCount++;
            newLogfile += "." + fileCount + options.extension;
          } else {
            fileCount = 0;
            newLogfile += options.extension;
          }
          curSize = 0;
          if (self2.verbose) {
            console.log(new Date, import.meta.require("util").format("[FileStreamRotator] Changing logs from %s to %s", logfile, newLogfile));
          }
          curDate = newDate;
          oldFile = logfile;
          logfile = newLogfile;
          if (options.end_stream === true) {
            rotateStream.end();
          } else {
            rotateStream.destroy();
          }
          mkDirForFile(logfile);
          rotateStream = fs.createWriteStream(newLogfile, file_options);
          stream7.emit("new", newLogfile);
          stream7.emit("rotate", oldFile, newLogfile);
          BubbleEvents(rotateStream, stream7);
        }
        rotateStream.write(str, encoding);
        curSize += Buffer.byteLength(str, encoding);
      }.bind(this);
      process.nextTick(function() {
        stream7.emit("new", logfile);
      });
      stream7.emit("new", logfile);
      return stream7;
    } else {
      if (self2.verbose) {
        console.log(new Date, "[FileStreamRotator] File won't be rotated: ", options.frequency, options.size);
      }
      process.nextTick(function() {
        rotateStream.emit("new", logfile);
      });
      return rotateStream;
    }
  };
  var mkDirForFile = function(pathWithFile) {
    var _path = path.dirname(pathWithFile);
    _path.split(path.sep).reduce(function(fullPath, folder) {
      fullPath += folder + path.sep;
      if (!fs.existsSync(fullPath)) {
        try {
          fs.mkdirSync(fullPath);
        } catch (e) {
          if (e.code !== "EEXIST") {
            throw e;
          }
        }
      }
      return fullPath;
    }, "");
  };
  var BubbleEvents = function BubbleEvents(emitter, proxy) {
    emitter.on("close", function() {
      proxy.emit("close");
    });
    emitter.on("finish", function() {
      proxy.emit("finish");
    });
    emitter.on("error", function(err2) {
      proxy.emit("error", err2);
    });
    emitter.on("open", function(fd2) {
      proxy.emit("open", fd2);
    });
  };
});

// node_modules/winston-daily-rotate-file/daily-rotate-file.js
var require_daily_rotate_file = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var os = import.meta.require("os");
  var path = import.meta.require("path");
  var util2 = import.meta.require("util");
  var zlib = import.meta.require("zlib");
  var hash5 = require_object_hash();
  var MESSAGE = require_triple_beam().MESSAGE;
  var PassThrough2 = import.meta.require("stream").PassThrough;
  var Transport = require_winston_transport();
  var loggerDefaults = {
    json: false,
    colorize: false,
    eol: os.EOL,
    logstash: null,
    prettyPrint: false,
    label: null,
    stringify: false,
    depth: null,
    showLevel: true,
    timestamp: function() {
      return new Date().toISOString();
    }
  };
  var DailyRotateFile = function(options) {
    options = options || {};
    Transport.call(this, options);
    function throwIf(target) {
      Array.prototype.slice.call(arguments, 1).forEach(function(name) {
        if (options[name]) {
          throw new Error("Cannot set " + name + " and " + target + " together");
        }
      });
    }
    function getMaxSize(size) {
      if (size && typeof size === "string") {
        var _s = size.toLowerCase().match(/^((?:0\.)?\d+)([k|m|g])$/);
        if (_s) {
          return size;
        }
      } else if (size && Number.isInteger(size)) {
        var sizeK = Math.round(size / 1024);
        return sizeK === 0 ? "1k" : sizeK + "k";
      }
      return null;
    }
    function isValidFileName(filename) {
      return !/["<>|:*?\\/\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]/g.test(filename);
    }
    function isValidDirName(dirname) {
      return !/["<>|\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]/g.test(dirname);
    }
    this.options = Object.assign({}, loggerDefaults, options);
    if (options.stream) {
      throwIf("stream", "filename", "maxsize");
      this.logStream = new PassThrough2;
      this.logStream.pipe(options.stream);
    } else {
      this.filename = options.filename ? path.basename(options.filename) : "winston.log";
      this.dirname = options.dirname || path.dirname(options.filename);
      if (!isValidFileName(this.filename) || !isValidDirName(this.dirname)) {
        throw new Error("Your path or filename contain an invalid character.");
      }
      var self2 = this;
      this.logStream = require_FileStreamRotator().getStream({
        filename: path.join(this.dirname, this.filename),
        frequency: options.frequency ? options.frequency : "custom",
        date_format: options.datePattern ? options.datePattern : "YYYY-MM-DD",
        verbose: false,
        size: getMaxSize(options.maxSize),
        max_logs: options.maxFiles,
        end_stream: true,
        audit_file: options.auditFile ? options.auditFile : path.join(self2.dirname, "." + hash5(options) + "-audit.json"),
        file_options: options.options ? options.options : { flags: "a" },
        utc: options.utc ? options.utc : false,
        extension: options.extension ? options.extension : "",
        create_symlink: options.createSymlink ? options.createSymlink : false,
        symlink_name: options.symlinkName ? options.symlinkName : "current.log",
        watch_log: options.watchLog ? options.watchLog : false,
        audit_hash_type: options.auditHashType ? options.auditHashType : "sha256"
      });
      this.logStream.on("new", function(newFile) {
        self2.emit("new", newFile);
      });
      this.logStream.on("rotate", function(oldFile, newFile) {
        self2.emit("rotate", oldFile, newFile);
      });
      this.logStream.on("logRemoved", function(params) {
        if (options.zippedArchive) {
          var gzName = params.name + ".gz";
          if (fs.existsSync(gzName)) {
            try {
              fs.unlinkSync(gzName);
            } catch (_err) {
            }
            self2.emit("logRemoved", gzName);
            return;
          }
        }
        self2.emit("logRemoved", params.name);
      });
      if (options.zippedArchive) {
        this.logStream.on("rotate", function(oldFile) {
          var oldFileExist = fs.existsSync(oldFile);
          var gzExist = fs.existsSync(oldFile + ".gz");
          if (!oldFileExist || gzExist) {
            return;
          }
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(oldFile);
          var out = fs.createWriteStream(oldFile + ".gz");
          inp.pipe(gzip).pipe(out).on("finish", function() {
            if (fs.existsSync(oldFile)) {
              fs.unlinkSync(oldFile);
            }
            self2.emit("archive", oldFile + ".gz");
          });
        });
      }
      if (options.watchLog) {
        this.logStream.on("addWatcher", (newFile) => {
          self2.emit("addWatcher", newFile);
        });
      }
    }
  };
  module.exports = DailyRotateFile;
  util2.inherits(DailyRotateFile, Transport);
  DailyRotateFile.prototype.name = "dailyRotateFile";
  var noop = function() {
  };
  DailyRotateFile.prototype.log = function(info, callback) {
    callback = callback || noop;
    this.logStream.write(info[MESSAGE] + this.options.eol);
    this.emit("logged", info);
    callback(null, true);
  };
  DailyRotateFile.prototype.close = function() {
    var self2 = this;
    if (this.logStream) {
      this.logStream.end(function() {
        self2.emit("finish");
      });
    }
  };
  DailyRotateFile.prototype.query = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.options.json) {
      throw new Error("query() may not be used without the json option being set to true");
    }
    if (!this.filename) {
      throw new Error("query() may not be used when initializing with a stream");
    }
    var self2 = this;
    var results = [];
    options = options || {};
    options.rows = options.rows || options.limit || 10;
    options.start = options.start || 0;
    options.until = options.until || new Date;
    if (typeof options.until !== "object") {
      options.until = new Date(options.until);
    }
    options.from = options.from || options.until - 24 * 60 * 60 * 1000;
    if (typeof options.from !== "object") {
      options.from = new Date(options.from);
    }
    options.order = options.order || "desc";
    var logFiles = function() {
      var fileRegex = new RegExp(self2.filename.replace("%DATE%", ".*"), "i");
      return fs.readdirSync(self2.dirname).filter(function(file) {
        return path.basename(file).match(fileRegex);
      });
    }();
    if (logFiles.length === 0 && callback) {
      callback(null, results);
    }
    (function processLogFile(file) {
      if (!file) {
        return;
      }
      var logFile = path.join(self2.dirname, file);
      var buff = "";
      var stream7;
      if (file.endsWith(".gz")) {
        stream7 = new PassThrough2;
        fs.createReadStream(logFile).pipe(zlib.createGunzip()).pipe(stream7);
      } else {
        stream7 = fs.createReadStream(logFile, {
          encoding: "utf8"
        });
      }
      stream7.on("error", function(err2) {
        if (stream7.readable) {
          stream7.destroy();
        }
        if (!callback) {
          return;
        }
        return err2.code === "ENOENT" ? callback(null, results) : callback(err2);
      });
      stream7.on("data", function(data) {
        data = (buff + data).split(/\n+/);
        var l = data.length - 1;
        for (var i = 0;i < l; i++) {
          add(data[i]);
        }
        buff = data[l];
      });
      stream7.on("end", function() {
        if (buff) {
          add(buff, true);
        }
        if (logFiles.length) {
          processLogFile(logFiles.shift());
        } else if (callback) {
          results.sort(function(a, b) {
            var d1 = new Date(a.timestamp).getTime();
            var d2 = new Date(b.timestamp).getTime();
            return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
          });
          if (options.order === "desc") {
            results = results.reverse();
          }
          var start = options.start || 0;
          var limit = options.limit || results.length;
          results = results.slice(start, start + limit);
          if (options.fields) {
            results = results.map(function(log) {
              var obj = {};
              options.fields.forEach(function(key) {
                obj[key] = log[key];
              });
              return obj;
            });
          }
          callback(null, results);
        }
      });
      function add(buff2, attempt) {
        try {
          var log = JSON.parse(buff2);
          if (!log || typeof log !== "object") {
            return;
          }
          var time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          results.push(log);
        } catch (e) {
          if (!attempt) {
            stream7.emit("error", e);
          }
        }
      }
    })(logFiles.shift());
  };
});

// node_modules/winston-daily-rotate-file/index.js
var require_winston_daily_rotate_file = __commonJS((exports, module) => {
  var winston = require_winston();
  var DailyRotateFile = require_daily_rotate_file();
  winston.transports.DailyRotateFile = DailyRotateFile;
  module.exports = DailyRotateFile;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  };
  var stringify = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse4 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse4;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes2 = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version, hashfunc) {
    function generateUUID(value26, namespace, buf, offset) {
      var _namespace;
      if (typeof value26 === "string") {
        value26 = stringToBytes2(value26);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value26.length);
      bytes.set(namespace);
      bytes.set(value26, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err2) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
});

// node_modules/uuid/wrapper.mjs
var dist, v1, v3, v4, v5, NIL, version, validate, stringify, parse4;
var init_wrapper = __esm(() => {
  dist = __toESM(require_dist2(), 1);
  v1 = dist.default.v1;
  v3 = dist.default.v3;
  v4 = dist.default.v4;
  v5 = dist.default.v5;
  NIL = dist.default.NIL;
  version = dist.default.version;
  validate = dist.default.validate;
  stringify = dist.default.stringify;
  parse4 = dist.default.parse;
});

// src/utils/logger.ts
var import_winston, import_winston_daily_rotate_file, logger, createRequestLogger, generateRequestId, logInfo, logError, logWarn;
var init_logger = __esm(() => {
  import_winston = __toESM(require_winston(), 1);
  import_winston_daily_rotate_file = __toESM(require_winston_daily_rotate_file(), 1);
  init_wrapper();
  logger = import_winston.default.createLogger({
    level: process.env.LOG_LEVEL || "info",
    format: import_winston.default.format.combine(import_winston.default.format.timestamp(), import_winston.default.format.errors({ stack: true }), import_winston.default.format.json()),
    defaultMeta: { service: "websocket-server" },
    transports: [
      new import_winston.default.transports.Console({
        format: import_winston.default.format.combine(import_winston.default.format.colorize(), import_winston.default.format.simple())
      }),
      new import_winston_daily_rotate_file.default({
        filename: "logs/application-%DATE%.log",
        datePattern: "YYYY-MM-DD",
        zippedArchive: true,
        maxSize: "20m",
        maxFiles: "14d"
      }),
      new import_winston_daily_rotate_file.default({
        filename: "logs/error-%DATE%.log",
        datePattern: "YYYY-MM-DD",
        level: "error",
        zippedArchive: true,
        maxSize: "20m",
        maxFiles: "30d"
      })
    ]
  });
  createRequestLogger = (requestId) => {
    return logger.child({ request_id: requestId });
  };
  generateRequestId = () => v4();
  logInfo = (message, meta) => logger.info(message, meta);
  logError = (message, meta) => logger.error(message, meta);
  logWarn = (message, meta) => logger.warn(message, meta);
});

// node_modules/prom-client/lib/util.js
var require_util = __commonJS((exports) => {
  var fastHashObject = function(keys, labels) {
    if (keys.length === 0) {
      return "";
    }
    let hash5 = "";
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      const value26 = labels[key];
      if (value26 === undefined)
        continue;
      hash5 += `${key}:${value26},`;
    }
    return hash5;
  };
  var hashObject = function(labels, labelNames) {
    if (labelNames) {
      return fastHashObject(labelNames, labels);
    }
    const keys = Object.keys(labels);
    if (keys.length > 1) {
      keys.sort();
    }
    return fastHashObject(keys, labels);
  };
  exports.getValueAsString = function getValueString(value26) {
    if (Number.isNaN(value26)) {
      return "Nan";
    } else if (!Number.isFinite(value26)) {
      if (value26 < 0) {
        return "-Inf";
      } else {
        return "+Inf";
      }
    } else {
      return `${value26}`;
    }
  };
  exports.removeLabels = function removeLabels(hashMap, labels, sortedLabelNames) {
    const hash5 = hashObject(labels, sortedLabelNames);
    delete hashMap[hash5];
  };
  exports.setValue = function setValue(hashMap, value26, labels) {
    const hash5 = hashObject(labels);
    hashMap[hash5] = {
      value: typeof value26 === "number" ? value26 : 0,
      labels: labels || {}
    };
    return hashMap;
  };
  exports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels, hash5 = "") {
    const value26 = typeof deltaValue === "number" ? deltaValue : 0;
    if (hashMap[hash5]) {
      hashMap[hash5].value += value26;
    } else {
      hashMap[hash5] = { value: value26, labels };
    }
    return hashMap;
  };
  exports.getLabels = function(labelNames, args) {
    if (typeof args[0] === "object") {
      return args[0];
    }
    if (labelNames.length !== args.length) {
      throw new Error(`Invalid number of arguments (${args.length}): "${args.join(", ")}" for label names (${labelNames.length}): "${labelNames.join(", ")}".`);
    }
    const acc = {};
    for (let i = 0;i < labelNames.length; i++) {
      acc[labelNames[i]] = args[i];
    }
    return acc;
  };
  exports.hashObject = hashObject;
  exports.isObject = function isObject(obj) {
    return obj !== null && typeof obj === "object";
  };
  exports.nowTimestamp = function nowTimestamp() {
    return Date.now() / 1000;
  };

  class Grouper extends Map {
    add(key, value26) {
      if (this.has(key)) {
        this.get(key).push(value26);
      } else {
        this.set(key, [value26]);
      }
    }
  }
  exports.Grouper = Grouper;
});

// node_modules/prom-client/lib/registry.js
var require_registry = __commonJS((exports, module) => {
  var formatLabels = function(labels, exclude3) {
    const { hasOwnProperty } = Object.prototype;
    const formatted = [];
    for (const [name, value26] of Object.entries(labels)) {
      if (!exclude3 || !hasOwnProperty.call(exclude3, name)) {
        formatted.push(`${name}="${escapeLabelValue(value26)}"`);
      }
    }
    return formatted;
  };
  var flattenSharedLabels = function(labels) {
    const cached = sharedLabelCache.get(labels);
    if (cached) {
      return cached;
    }
    const formattedLabels = formatLabels(labels);
    const flattened = formattedLabels.join(",");
    sharedLabelCache.set(labels, flattened);
    return flattened;
  };
  var escapeLabelValue = function(str) {
    if (typeof str !== "string") {
      return str;
    }
    return escapeString(str).replace(/"/g, '\\"');
  };
  var escapeString = function(str) {
    return str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n");
  };
  var standardizeCounterName = function(name) {
    return name.replace(/_total$/, "");
  };
  var { getValueAsString } = require_util();

  class Registry {
    static get PROMETHEUS_CONTENT_TYPE() {
      return "text/plain; version=0.0.4; charset=utf-8";
    }
    static get OPENMETRICS_CONTENT_TYPE() {
      return "application/openmetrics-text; version=1.0.0; charset=utf-8";
    }
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {
      this._metrics = {};
      this._collectors = [];
      this._defaultLabels = {};
      if (regContentType !== Registry.PROMETHEUS_CONTENT_TYPE && regContentType !== Registry.OPENMETRICS_CONTENT_TYPE) {
        throw new TypeError(`Content type ${regContentType} is unsupported`);
      }
      this._contentType = regContentType;
    }
    getMetricsAsArray() {
      return Object.values(this._metrics);
    }
    async getMetricsAsString(metrics) {
      const metric = typeof metrics.getForPromString === "function" ? await metrics.getForPromString() : await metrics.get();
      const name = escapeString(metric.name);
      const help = `# HELP ${name} ${escapeString(metric.help)}`;
      const type54 = `# TYPE ${name} ${metric.type}`;
      const values = [help, type54];
      const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;
      const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
      for (const val of metric.values || []) {
        let { metricName = name, labels = {} } = val;
        const { sharedLabels = {} } = val;
        if (isOpenMetrics && metric.type === "counter") {
          metricName = `${metricName}_total`;
        }
        if (defaultLabels) {
          labels = { ...labels, ...defaultLabels, ...labels };
        }
        const formattedLabels = formatLabels(labels, sharedLabels);
        const flattenedShared = flattenSharedLabels(sharedLabels);
        const labelParts = [...formattedLabels, flattenedShared].filter(Boolean);
        const labelsString = labelParts.length ? `{${labelParts.join(",")}}` : "";
        let fullMetricLine = `${metricName}${labelsString} ${getValueAsString(val.value)}`;
        const { exemplar } = val;
        if (exemplar && isOpenMetrics) {
          const formattedExemplars = formatLabels(exemplar.labelSet);
          fullMetricLine += ` # {${formattedExemplars.join(",")}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;
        }
        values.push(fullMetricLine);
      }
      return values.join("\n");
    }
    async metrics() {
      const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
      const promises5 = this.getMetricsAsArray().map((metric) => {
        if (isOpenMetrics && metric.type === "counter") {
          metric.name = standardizeCounterName(metric.name);
        }
        return this.getMetricsAsString(metric);
      });
      const resolves = await Promise.all(promises5);
      return isOpenMetrics ? `${resolves.join("\n")}\n# EOF\n` : `${resolves.join("\n\n")}\n`;
    }
    registerMetric(metric) {
      if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {
        throw new Error(`A metric with the name ${metric.name} has already been registered.`);
      }
      this._metrics[metric.name] = metric;
    }
    clear() {
      this._metrics = {};
      this._defaultLabels = {};
    }
    async getMetricsAsJSON() {
      const metrics = [];
      const defaultLabelNames = Object.keys(this._defaultLabels);
      const promises5 = [];
      for (const metric of this.getMetricsAsArray()) {
        promises5.push(metric.get());
      }
      const resolves = await Promise.all(promises5);
      for (const item of resolves) {
        if (item.values && defaultLabelNames.length > 0) {
          for (const val of item.values) {
            val.labels = Object.assign({}, val.labels);
            for (const labelName of defaultLabelNames) {
              val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];
            }
          }
        }
        metrics.push(item);
      }
      return metrics;
    }
    removeSingleMetric(name) {
      delete this._metrics[name];
    }
    getSingleMetricAsString(name) {
      return this.getMetricsAsString(this._metrics[name]);
    }
    getSingleMetric(name) {
      return this._metrics[name];
    }
    setDefaultLabels(labels) {
      this._defaultLabels = labels;
    }
    resetMetrics() {
      for (const metric in this._metrics) {
        this._metrics[metric].reset();
      }
    }
    get contentType() {
      return this._contentType;
    }
    setContentType(metricsContentType) {
      if (metricsContentType === Registry.OPENMETRICS_CONTENT_TYPE || metricsContentType === Registry.PROMETHEUS_CONTENT_TYPE) {
        this._contentType = metricsContentType;
      } else {
        throw new Error(`Content type ${metricsContentType} is unsupported`);
      }
    }
    static merge(registers) {
      const regType = registers[0].contentType;
      for (const reg of registers) {
        if (reg.contentType !== regType) {
          throw new Error("Registers can only be merged if they have the same content type");
        }
      }
      const mergedRegistry = new Registry(regType);
      const metricsToMerge = registers.reduce((acc, reg) => acc.concat(reg.getMetricsAsArray()), []);
      metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);
      return mergedRegistry;
    }
  }
  var sharedLabelCache = new WeakMap;
  module.exports = Registry;
  module.exports.globalRegistry = new Registry;
});

// node_modules/prom-client/lib/validation.js
var require_validation = __commonJS((exports) => {
  var util2 = import.meta.require("util");
  var metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;
  var labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
  exports.validateMetricName = function(name) {
    return metricRegexp.test(name);
  };
  exports.validateLabelName = function(names = []) {
    return names.every((name) => labelRegexp.test(name));
  };
  exports.validateLabel = function validateLabel(savedLabels, labels) {
    for (const label in labels) {
      if (!savedLabels.includes(label)) {
        throw new Error(`Added label "${label}" is not included in initial labelset: ${util2.inspect(savedLabels)}`);
      }
    }
  };
});

// node_modules/prom-client/lib/metric.js
var require_metric = __commonJS((exports, module) => {
  var Registry = require_registry();
  var { isObject: isObject2 } = require_util();
  var { validateMetricName, validateLabelName } = require_validation();

  class Metric {
    constructor(config, defaults = {}) {
      if (!isObject2(config)) {
        throw new TypeError("constructor expected a config object");
      }
      Object.assign(this, {
        labelNames: [],
        registers: [Registry.globalRegistry],
        aggregator: "sum",
        enableExemplars: false
      }, defaults, config);
      if (!this.registers) {
        this.registers = [Registry.globalRegistry];
      }
      if (!this.help) {
        throw new Error("Missing mandatory help parameter");
      }
      if (!this.name) {
        throw new Error("Missing mandatory name parameter");
      }
      if (!validateMetricName(this.name)) {
        throw new Error("Invalid metric name");
      }
      if (!validateLabelName(this.labelNames)) {
        throw new Error("Invalid label name");
      }
      if (this.collect && typeof this.collect !== "function") {
        throw new Error('Optional "collect" parameter must be a function');
      }
      if (this.labelNames) {
        this.sortedLabelNames = [...this.labelNames].sort();
      } else {
        this.sortedLabelNames = [];
      }
      this.reset();
      for (const register of this.registers) {
        if (this.enableExemplars && register.contentType === Registry.PROMETHEUS_CONTENT_TYPE) {
          throw new TypeError("Exemplars are supported only on OpenMetrics registries");
        }
        register.registerMetric(this);
      }
    }
    reset() {
    }
  }
  module.exports = { Metric };
});

// node_modules/prom-client/lib/exemplar.js
var require_exemplar = __commonJS((exports, module) => {
  class Exemplar {
    constructor(labelSet = {}, value26 = null) {
      this.labelSet = labelSet;
      this.value = value26;
    }
    validateExemplarLabelSet(labelSet) {
      let res = "";
      for (const [labelName, labelValue] of Object.entries(labelSet)) {
        res += `${labelName}${labelValue}`;
      }
      if (res.length > 128) {
        throw new RangeError("Label set size must be smaller than 128 UTF-8 chars");
      }
    }
  }
  module.exports = Exemplar;
});

// node_modules/prom-client/lib/counter.js
var require_counter = __commonJS((exports, module) => {
  var setValue = function(hashMap, value26, labels = {}, hash5 = "") {
    if (hashMap[hash5]) {
      hashMap[hash5].value += value26;
    } else {
      hashMap[hash5] = { value: value26, labels };
    }
    return hashMap;
  };
  var util2 = import.meta.require("util");
  var {
    hashObject,
    isObject: isObject2,
    getLabels,
    removeLabels,
    nowTimestamp
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var Exemplar = require_exemplar();

  class Counter extends Metric {
    constructor(config) {
      super(config);
      this.type = "counter";
      this.defaultLabels = {};
      this.defaultValue = 1;
      this.defaultExemplarLabelSet = {};
      if (config.enableExemplars) {
        this.enableExemplars = true;
        this.inc = this.incWithExemplar;
      } else {
        this.inc = this.incWithoutExemplar;
      }
    }
    incWithoutExemplar(labels, value26) {
      let hash5 = "";
      if (isObject2(labels)) {
        hash5 = hashObject(labels, this.sortedLabelNames);
        validateLabel(this.labelNames, labels);
      } else {
        value26 = labels;
        labels = {};
      }
      if (value26 && !Number.isFinite(value26)) {
        throw new TypeError(`Value is not a valid number: ${util2.format(value26)}`);
      }
      if (value26 < 0) {
        throw new Error("It is not possible to decrease a counter");
      }
      if (value26 === null || value26 === undefined)
        value26 = 1;
      setValue(this.hashMap, value26, labels, hash5);
      return { labelHash: hash5 };
    }
    incWithExemplar({
      labels = this.defaultLabels,
      value: value26 = this.defaultValue,
      exemplarLabels = this.defaultExemplarLabelSet
    } = {}) {
      const res = this.incWithoutExemplar(labels, value26);
      this.updateExemplar(exemplarLabels, value26, res.labelHash);
    }
    updateExemplar(exemplarLabels, value26, hash5) {
      if (exemplarLabels === this.defaultExemplarLabelSet)
        return;
      if (!isObject2(this.hashMap[hash5].exemplar)) {
        this.hashMap[hash5].exemplar = new Exemplar;
      }
      this.hashMap[hash5].exemplar.validateExemplarLabelSet(exemplarLabels);
      this.hashMap[hash5].exemplar.labelSet = exemplarLabels;
      this.hashMap[hash5].exemplar.value = value26 ? value26 : 1;
      this.hashMap[hash5].exemplar.timestamp = nowTimestamp();
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0);
      }
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type: this.type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      return {
        inc: this.inc.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      validateLabel(this.labelNames, labels);
      return removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
  }
  module.exports = Counter;
});

// node_modules/prom-client/lib/gauge.js
var require_gauge = __commonJS((exports, module) => {
  var set2 = function(gauge, labels, value26) {
    if (typeof value26 !== "number") {
      throw new TypeError(`Value is not a valid number: ${util2.format(value26)}`);
    }
    validateLabel(gauge.labelNames, labels);
    setValue(gauge.hashMap, value26, labels);
  };
  var setDelta = function(gauge, labels, delta2) {
    if (typeof delta2 !== "number") {
      throw new TypeError(`Delta is not a valid number: ${util2.format(delta2)}`);
    }
    validateLabel(gauge.labelNames, labels);
    const hash5 = hashObject(labels, gauge.sortedLabelNames);
    setValueDelta(gauge.hashMap, delta2, labels, hash5);
  };
  var getLabelArg = function(labels) {
    return isObject2(labels) ? labels : {};
  };
  var getValueArg = function(labels, value26) {
    return isObject2(labels) ? value26 : labels;
  };
  var util2 = import.meta.require("util");
  var {
    setValue,
    setValueDelta,
    getLabels,
    hashObject,
    isObject: isObject2,
    removeLabels
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();

  class Gauge extends Metric {
    constructor(config) {
      super(config);
      this.type = "gauge";
    }
    set(labels, value26) {
      value26 = getValueArg(labels, value26);
      labels = getLabelArg(labels);
      set2(this, labels, value26);
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0, {});
      }
    }
    inc(labels, value26) {
      value26 = getValueArg(labels, value26);
      labels = getLabelArg(labels);
      if (value26 === undefined)
        value26 = 1;
      setDelta(this, labels, value26);
    }
    dec(labels, value26) {
      value26 = getValueArg(labels, value26);
      labels = getLabelArg(labels);
      if (value26 === undefined)
        value26 = 1;
      setDelta(this, labels, -value26);
    }
    setToCurrentTime(labels) {
      const now = Date.now() / 1000;
      if (labels === undefined) {
        this.set(now);
      } else {
        this.set(labels, now);
      }
    }
    startTimer(labels) {
      const start = process.hrtime();
      return (endLabels) => {
        const delta2 = process.hrtime(start);
        const value26 = delta2[0] + delta2[1] / 1e9;
        this.set(Object.assign({}, labels, endLabels), value26);
        return value26;
      };
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type: this.type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    _getValue(labels) {
      const hash5 = hashObject(labels || {}, this.sortedLabelNames);
      return this.hashMap[hash5] ? this.hashMap[hash5].value : 0;
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        inc: this.inc.bind(this, labels),
        dec: this.dec.bind(this, labels),
        set: this.set.bind(this, labels),
        setToCurrentTime: this.setToCurrentTime.bind(this, labels),
        startTimer: this.startTimer.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
  }
  module.exports = Gauge;
});

// node_modules/prom-client/lib/histogram.js
var require_histogram = __commonJS((exports, module) => {
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta2 = process.hrtime(start);
        const value26 = delta2[0] + delta2[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value26);
        return value26;
      };
    };
  };
  var startTimerWithExemplar = function(startLabels, startExemplarLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels, endExemplarLabels) => {
        const delta2 = process.hrtime(start);
        const value26 = delta2[0] + delta2[1] / 1e9;
        this.observe({
          labels: Object.assign({}, startLabels, endLabels),
          value: value26,
          exemplarLabels: Object.assign({}, startExemplarLabels, endExemplarLabels)
        });
        return value26;
      };
    };
  };
  var setValuePair = function(labels, value26, metricName, exemplar, sharedLabels = {}) {
    return {
      labels,
      sharedLabels,
      value: value26,
      metricName,
      exemplar
    };
  };
  var findBound = function(upperBounds, value26) {
    for (let i = 0;i < upperBounds.length; i++) {
      const bound = upperBounds[i];
      if (value26 <= bound) {
        return bound;
      }
    }
    return -1;
  };
  var observe = function(labels) {
    return (value26) => {
      const labelValuePair = convertLabelsAndValues(labels, value26);
      validateLabel(this.labelNames, labelValuePair.labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util2.format(labelValuePair.value)}`);
      }
      const hash5 = hashObject(labelValuePair.labels, this.sortedLabelNames);
      let valueFromMap = this.hashMap[hash5];
      if (!valueFromMap) {
        valueFromMap = createBaseValues(labelValuePair.labels, this.bucketValues, this.bucketExemplars);
      }
      const b = findBound(this.upperBounds, labelValuePair.value);
      valueFromMap.sum += labelValuePair.value;
      valueFromMap.count += 1;
      if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {
        valueFromMap.bucketValues[b] += 1;
      }
      this.hashMap[hash5] = valueFromMap;
    };
  };
  var createBaseValues = function(labels, bucketValues, bucketExemplars) {
    const result = {
      labels,
      bucketValues: { ...bucketValues },
      sum: 0,
      count: 0
    };
    if (bucketExemplars) {
      result.bucketExemplars = { ...bucketExemplars };
    }
    return result;
  };
  var convertLabelsAndValues = function(labels, value26) {
    return isObject2(labels) ? {
      labels,
      value: value26
    } : {
      value: labels,
      labels: {}
    };
  };
  var extractBucketValuesForExport = function(histogram) {
    const name = `${histogram.name}_bucket`;
    return (bucketData) => {
      let acc = 0;
      const buckets = histogram.upperBounds.map((upperBound) => {
        acc += bucketData.bucketValues[upperBound];
        return setValuePair({ le: upperBound }, acc, name, bucketData.bucketExemplars ? bucketData.bucketExemplars[upperBound] : null, bucketData.labels);
      });
      return { buckets, data: bucketData };
    };
  };
  var addSumAndCountForExport = function(histogram) {
    return (acc, d) => {
      acc.push(...d.buckets);
      const infLabel = { le: "+Inf" };
      acc.push(setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`, d.data.bucketExemplars ? d.data.bucketExemplars["-1"] : null, d.data.labels), setValuePair({}, d.data.sum, `${histogram.name}_sum`, undefined, d.data.labels), setValuePair({}, d.data.count, `${histogram.name}_count`, undefined, d.data.labels));
      return acc;
    };
  };
  var splayLabels = function(bucket) {
    const { sharedLabels, labels, ...newBucket } = bucket;
    for (const label of Object.keys(sharedLabels)) {
      labels[label] = sharedLabels[label];
    }
    newBucket.labels = labels;
    return newBucket;
  };
  var util2 = import.meta.require("util");
  var {
    getLabels,
    hashObject,
    isObject: isObject2,
    removeLabels,
    nowTimestamp
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var Exemplar = require_exemplar();

  class Histogram extends Metric {
    constructor(config) {
      super(config, {
        buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
      });
      this.type = "histogram";
      this.defaultLabels = {};
      this.defaultExemplarLabelSet = {};
      this.enableExemplars = false;
      for (const label of this.labelNames) {
        if (label === "le") {
          throw new Error("le is a reserved label keyword");
        }
      }
      this.upperBounds = this.buckets;
      this.bucketValues = this.upperBounds.reduce((acc, upperBound) => {
        acc[upperBound] = 0;
        return acc;
      }, {});
      if (config.enableExemplars) {
        this.enableExemplars = true;
        this.bucketExemplars = this.upperBounds.reduce((acc, upperBound) => {
          acc[upperBound] = null;
          return acc;
        }, {});
        Object.freeze(this.bucketExemplars);
        this.observe = this.observeWithExemplar;
      } else {
        this.observe = this.observeWithoutExemplar;
      }
      Object.freeze(this.bucketValues);
      Object.freeze(this.upperBounds);
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: createBaseValues({}, this.bucketValues, this.bucketExemplars)
        };
      }
    }
    observeWithoutExemplar(labels, value26) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value26);
    }
    observeWithExemplar({
      labels = this.defaultLabels,
      value: value26,
      exemplarLabels = this.defaultExemplarLabelSet
    } = {}) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value26);
      this.updateExemplar(labels, value26, exemplarLabels);
    }
    updateExemplar(labels, value26, exemplarLabels) {
      if (Object.keys(exemplarLabels).length === 0)
        return;
      const hash5 = hashObject(labels, this.sortedLabelNames);
      const bound = findBound(this.upperBounds, value26);
      const { bucketExemplars } = this.hashMap[hash5];
      let exemplar = bucketExemplars[bound];
      if (!isObject2(exemplar)) {
        exemplar = new Exemplar;
        bucketExemplars[bound] = exemplar;
      }
      exemplar.validateExemplarLabelSet(exemplarLabels);
      exemplar.labelSet = exemplarLabels;
      exemplar.value = value26;
      exemplar.timestamp = nowTimestamp();
    }
    async get() {
      const data = await this.getForPromString();
      data.values = data.values.map(splayLabels);
      return data;
    }
    async getForPromString() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const data = Object.values(this.hashMap);
      const values = data.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);
      return {
        name: this.name,
        help: this.help,
        type: this.type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      this.hashMap = {};
    }
    zero(labels) {
      const hash5 = hashObject(labels, this.sortedLabelNames);
      this.hashMap[hash5] = createBaseValues(labels, this.bucketValues, this.bucketExemplars);
    }
    startTimer(labels, exemplarLabels) {
      return this.enableExemplars ? startTimerWithExemplar.call(this, labels, exemplarLabels)() : startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
  }
  module.exports = Histogram;
});

// node_modules/bintrees/lib/treebase.js
var require_treebase = __commonJS((exports, module) => {
  var TreeBase = function() {
  };
  var Iterator2 = function(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
  };
  TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
  };
  TreeBase.prototype.find = function(data) {
    var res = this._root;
    while (res !== null) {
      var c = this._comparator(data, res.data);
      if (c === 0) {
        return res.data;
      } else {
        res = res.get_child(c > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();
    while (res !== null) {
      var c = this._comparator(data, res.data);
      if (c === 0) {
        iter._cursor = res;
        return iter;
      } else {
        iter._ancestors.push(res);
        res = res.get_child(c > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;
    while (cur !== null) {
      var c = cmp(item, cur.data);
      if (c === 0) {
        iter._cursor = cur;
        return iter;
      }
      iter._ancestors.push(cur);
      cur = cur.get_child(c > 0);
    }
    for (var i = iter._ancestors.length - 1;i >= 0; --i) {
      cur = iter._ancestors[i];
      if (cmp(item, cur.data) < 0) {
        iter._cursor = cur;
        iter._ancestors.length = i;
        return iter;
      }
    }
    iter._ancestors.length = 0;
    return iter;
  };
  TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;
    while (iter.data() !== null && cmp(iter.data(), item) === 0) {
      iter.next();
    }
    return iter;
  };
  TreeBase.prototype.min = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.left !== null) {
      res = res.left;
    }
    return res.data;
  };
  TreeBase.prototype.max = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.right !== null) {
      res = res.right;
    }
    return res.data;
  };
  TreeBase.prototype.iterator = function() {
    return new Iterator2(this);
  };
  TreeBase.prototype.each = function(cb) {
    var it = this.iterator(), data;
    while ((data = it.next()) !== null) {
      if (cb(data) === false) {
        return;
      }
    }
  };
  TreeBase.prototype.reach = function(cb) {
    var it = this.iterator(), data;
    while ((data = it.prev()) !== null) {
      if (cb(data) === false) {
        return;
      }
    }
  };
  Iterator2.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator2.prototype.next = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._minNode(root);
      }
    } else {
      if (this._cursor.right === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.right === save);
      } else {
        this._ancestors.push(this._cursor);
        this._minNode(this._cursor.right);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator2.prototype.prev = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._maxNode(root);
      }
    } else {
      if (this._cursor.left === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.left === save);
      } else {
        this._ancestors.push(this._cursor);
        this._maxNode(this._cursor.left);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator2.prototype._minNode = function(start) {
    while (start.left !== null) {
      this._ancestors.push(start);
      start = start.left;
    }
    this._cursor = start;
  };
  Iterator2.prototype._maxNode = function(start) {
    while (start.right !== null) {
      this._ancestors.push(start);
      start = start.right;
    }
    this._cursor = start;
  };
  module.exports = TreeBase;
});

// node_modules/bintrees/lib/rbtree.js
var require_rbtree = __commonJS((exports, module) => {
  var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
  };
  var RBTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var is_red = function(node) {
    return node !== null && node.red;
  };
  var single_rotate = function(root, dir) {
    var save = root.get_child(!dir);
    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);
    root.red = true;
    save.red = false;
    return save;
  };
  var double_rotate = function(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  RBTree.prototype = new TreeBase;
  RBTree.prototype.insert = function(data) {
    var ret2 = false;
    if (this._root === null) {
      this._root = new Node(data);
      ret2 = true;
      this.size++;
    } else {
      var head = new Node(undefined);
      var dir = 0;
      var last = 0;
      var gp = null;
      var ggp = head;
      var p = null;
      var node = this._root;
      ggp.right = this._root;
      while (true) {
        if (node === null) {
          node = new Node(data);
          p.set_child(dir, node);
          ret2 = true;
          this.size++;
        } else if (is_red(node.left) && is_red(node.right)) {
          node.red = true;
          node.left.red = false;
          node.right.red = false;
        }
        if (is_red(node) && is_red(p)) {
          var dir2 = ggp.right === gp;
          if (node === p.get_child(last)) {
            ggp.set_child(dir2, single_rotate(gp, !last));
          } else {
            ggp.set_child(dir2, double_rotate(gp, !last));
          }
        }
        var cmp = this._comparator(node.data, data);
        if (cmp === 0) {
          break;
        }
        last = dir;
        dir = cmp < 0;
        if (gp !== null) {
          ggp = gp;
        }
        gp = p;
        p = node;
        node = node.get_child(dir);
      }
      this._root = head.right;
    }
    this._root.red = false;
    return ret2;
  };
  RBTree.prototype.remove = function(data) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node = head;
    node.right = this._root;
    var p = null;
    var gp = null;
    var found = null;
    var dir = 1;
    while (node.get_child(dir) !== null) {
      var last = dir;
      gp = p;
      p = node;
      node = node.get_child(dir);
      var cmp = this._comparator(data, node.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node;
      }
      if (!is_red(node) && !is_red(node.get_child(dir))) {
        if (is_red(node.get_child(!dir))) {
          var sr = single_rotate(node, dir);
          p.set_child(last, sr);
          p = sr;
        } else if (!is_red(node.get_child(!dir))) {
          var sibling = p.get_child(!last);
          if (sibling !== null) {
            if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
              p.red = false;
              sibling.red = true;
              node.red = true;
            } else {
              var dir2 = gp.right === p;
              if (is_red(sibling.get_child(last))) {
                gp.set_child(dir2, double_rotate(p, last));
              } else if (is_red(sibling.get_child(!last))) {
                gp.set_child(dir2, single_rotate(p, last));
              }
              var gpc = gp.get_child(dir2);
              gpc.red = true;
              node.red = true;
              gpc.left.red = false;
              gpc.right.red = false;
            }
          }
        }
      }
    }
    if (found !== null) {
      found.data = node.data;
      p.set_child(p.right === node, node.get_child(node.left === null));
      this.size--;
    }
    this._root = head.right;
    if (this._root !== null) {
      this._root.red = false;
    }
    return found !== null;
  };
  module.exports = RBTree;
});

// node_modules/bintrees/lib/bintree.js
var require_bintree = __commonJS((exports, module) => {
  var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  };
  var BinTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  BinTree.prototype = new TreeBase;
  BinTree.prototype.insert = function(data) {
    if (this._root === null) {
      this._root = new Node(data);
      this.size++;
      return true;
    }
    var dir = 0;
    var p = null;
    var node = this._root;
    while (true) {
      if (node === null) {
        node = new Node(data);
        p.set_child(dir, node);
        ret = true;
        this.size++;
        return true;
      }
      if (this._comparator(node.data, data) === 0) {
        return false;
      }
      dir = this._comparator(node.data, data) < 0;
      p = node;
      node = node.get_child(dir);
    }
  };
  BinTree.prototype.remove = function(data) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node = head;
    node.right = this._root;
    var p = null;
    var found = null;
    var dir = 1;
    while (node.get_child(dir) !== null) {
      p = node;
      node = node.get_child(dir);
      var cmp = this._comparator(data, node.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node;
      }
    }
    if (found !== null) {
      found.data = node.data;
      p.set_child(p.right === node, node.get_child(node.left === null));
      this._root = head.right;
      this.size--;
      return true;
    } else {
      return false;
    }
  };
  module.exports = BinTree;
});

// node_modules/bintrees/index.js
var require_bintrees = __commonJS((exports, module) => {
  module.exports = {
    RBTree: require_rbtree(),
    BinTree: require_bintree()
  };
});

// node_modules/tdigest/tdigest.js
var require_tdigest = __commonJS((exports, module) => {
  var TDigest = function(delta2, K, CX) {
    this.discrete = delta2 === false;
    this.delta = delta2 || 0.01;
    this.K = K === undefined ? 25 : K;
    this.CX = CX === undefined ? 1.1 : CX;
    this.centroids = new RBTree(compare_centroid_means);
    this.nreset = 0;
    this.reset();
  };
  var compare_centroid_means = function(a, b) {
    return a.mean > b.mean ? 1 : a.mean < b.mean ? -1 : 0;
  };
  var compare_centroid_mean_cumns = function(a, b) {
    return a.mean_cumn - b.mean_cumn;
  };
  var pop_random = function(choices) {
    var idx = Math.floor(Math.random() * choices.length);
    return choices.splice(idx, 1)[0];
  };
  var Digest = function(config) {
    this.config = config || {};
    this.mode = this.config.mode || "auto";
    TDigest.call(this, this.mode === "cont" ? config.delta : false);
    this.digest_ratio = this.config.ratio || 0.9;
    this.digest_thresh = this.config.thresh || 1000;
    this.n_unique = 0;
  };
  var RBTree = require_bintrees().RBTree;
  TDigest.prototype.reset = function() {
    this.centroids.clear();
    this.n = 0;
    this.nreset += 1;
    this.last_cumulate = 0;
  };
  TDigest.prototype.size = function() {
    return this.centroids.size;
  };
  TDigest.prototype.toArray = function(everything) {
    var result = [];
    if (everything) {
      this._cumulate(true);
      this.centroids.each(function(c) {
        result.push(c);
      });
    } else {
      this.centroids.each(function(c) {
        result.push({ mean: c.mean, n: c.n });
      });
    }
    return result;
  };
  TDigest.prototype.summary = function() {
    var approx = this.discrete ? "exact " : "approximating ";
    var s = [
      approx + this.n + " samples using " + this.size() + " centroids",
      "min = " + this.percentile(0),
      "Q1  = " + this.percentile(0.25),
      "Q2  = " + this.percentile(0.5),
      "Q3  = " + this.percentile(0.75),
      "max = " + this.percentile(1)
    ];
    return s.join("\n");
  };
  TDigest.prototype.push = function(x, n) {
    n = n || 1;
    x = Array.isArray(x) ? x : [x];
    for (var i = 0;i < x.length; i++) {
      this._digest(x[i], n);
    }
  };
  TDigest.prototype.push_centroid = function(c) {
    c = Array.isArray(c) ? c : [c];
    for (var i = 0;i < c.length; i++) {
      this._digest(c[i].mean, c[i].n);
    }
  };
  TDigest.prototype._cumulate = function(exact) {
    if (this.n === this.last_cumulate || !exact && this.CX && this.CX > this.n / this.last_cumulate) {
      return;
    }
    var cumn = 0;
    this.centroids.each(function(c) {
      c.mean_cumn = cumn + c.n / 2;
      cumn = c.cumn = cumn + c.n;
    });
    this.n = this.last_cumulate = cumn;
  };
  TDigest.prototype.find_nearest = function(x) {
    if (this.size() === 0) {
      return null;
    }
    var iter = this.centroids.lowerBound({ mean: x });
    var c = iter.data() === null ? iter.prev() : iter.data();
    if (c.mean === x || this.discrete) {
      return c;
    }
    var prev = iter.prev();
    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {
      return prev;
    } else {
      return c;
    }
  };
  TDigest.prototype._new_centroid = function(x, n, cumn) {
    var c = { mean: x, n, cumn };
    this.centroids.insert(c);
    this.n += n;
    return c;
  };
  TDigest.prototype._addweight = function(nearest, x, n) {
    if (x !== nearest.mean) {
      nearest.mean += n * (x - nearest.mean) / (nearest.n + n);
    }
    nearest.cumn += n;
    nearest.mean_cumn += n / 2;
    nearest.n += n;
    this.n += n;
  };
  TDigest.prototype._digest = function(x, n) {
    var min = this.centroids.min();
    var max2 = this.centroids.max();
    var nearest = this.find_nearest(x);
    if (nearest && nearest.mean === x) {
      this._addweight(nearest, x, n);
    } else if (nearest === min) {
      this._new_centroid(x, n, 0);
    } else if (nearest === max2) {
      this._new_centroid(x, n, this.n);
    } else if (this.discrete) {
      this._new_centroid(x, n, nearest.cumn);
    } else {
      var p = nearest.mean_cumn / this.n;
      var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));
      if (max_n - nearest.n >= n) {
        this._addweight(nearest, x, n);
      } else {
        this._new_centroid(x, n, nearest.cumn);
      }
    }
    this._cumulate(false);
    if (!this.discrete && this.K && this.size() > this.K / this.delta) {
      this.compress();
    }
  };
  TDigest.prototype.bound_mean = function(x) {
    var iter = this.centroids.upperBound({ mean: x });
    var lower = iter.prev();
    var upper = lower.mean === x ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.p_rank = function(x_or_xlist) {
    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];
    var ps = xs.map(this._p_rank, this);
    return Array.isArray(x_or_xlist) ? ps : ps[0];
  };
  TDigest.prototype._p_rank = function(x) {
    if (this.size() === 0) {
      return;
    } else if (x < this.centroids.min().mean) {
      return 0;
    } else if (x > this.centroids.max().mean) {
      return 1;
    }
    this._cumulate(true);
    var bound = this.bound_mean(x);
    var lower = bound[0], upper = bound[1];
    if (this.discrete) {
      return lower.cumn / this.n;
    } else {
      var cumn = lower.mean_cumn;
      if (lower !== upper) {
        cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);
      }
      return cumn / this.n;
    }
  };
  TDigest.prototype.bound_mean_cumn = function(cumn) {
    this.centroids._comparator = compare_centroid_mean_cumns;
    var iter = this.centroids.upperBound({ mean_cumn: cumn });
    this.centroids._comparator = compare_centroid_means;
    var lower = iter.prev();
    var upper = lower && lower.mean_cumn === cumn ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.percentile = function(p_or_plist) {
    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];
    var qs = ps.map(this._percentile, this);
    return Array.isArray(p_or_plist) ? qs : qs[0];
  };
  TDigest.prototype._percentile = function(p) {
    if (this.size() === 0) {
      return;
    }
    this._cumulate(true);
    var h = this.n * p;
    var bound = this.bound_mean_cumn(h);
    var lower = bound[0], upper = bound[1];
    if (upper === lower || lower === null || upper === null) {
      return (lower || upper).mean;
    } else if (!this.discrete) {
      return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);
    } else if (h <= lower.cumn) {
      return lower.mean;
    } else {
      return upper.mean;
    }
  };
  TDigest.prototype.compress = function() {
    if (this.compressing) {
      return;
    }
    var points = this.toArray();
    this.reset();
    this.compressing = true;
    while (points.length > 0) {
      this.push_centroid(pop_random(points));
    }
    this._cumulate(true);
    this.compressing = false;
  };
  Digest.prototype = Object.create(TDigest.prototype);
  Digest.prototype.constructor = Digest;
  Digest.prototype.push = function(x_or_xlist) {
    TDigest.prototype.push.call(this, x_or_xlist);
    this.check_continuous();
  };
  Digest.prototype._new_centroid = function(x, n, cumn) {
    this.n_unique += 1;
    TDigest.prototype._new_centroid.call(this, x, n, cumn);
  };
  Digest.prototype._addweight = function(nearest, x, n) {
    if (nearest.n === 1) {
      this.n_unique -= 1;
    }
    TDigest.prototype._addweight.call(this, nearest, x, n);
  };
  Digest.prototype.check_continuous = function() {
    if (this.mode !== "auto" || this.size() < this.digest_thresh) {
      return false;
    }
    if (this.n_unique / this.size() > this.digest_ratio) {
      this.mode = "cont";
      this.discrete = false;
      this.delta = this.config.delta || 0.01;
      this.compress();
      return true;
    }
    return false;
  };
  module.exports = {
    TDigest,
    Digest
  };
});

// node_modules/prom-client/lib/timeWindowQuantiles.js
var require_timeWindowQuantiles = __commonJS((exports, module) => {
  var rotate = function() {
    let timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;
    while (timeSinceLastRotateMillis > this.durationBetweenRotatesMillis && this.shouldRotate) {
      this.ringBuffer[this.currentBuffer] = new TDigest;
      if (++this.currentBuffer >= this.ringBuffer.length) {
        this.currentBuffer = 0;
      }
      timeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;
      this.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;
    }
    return this.ringBuffer[this.currentBuffer];
  };
  var { TDigest } = require_tdigest();

  class TimeWindowQuantiles {
    constructor(maxAgeSeconds, ageBuckets) {
      this.maxAgeSeconds = maxAgeSeconds || 0;
      this.ageBuckets = ageBuckets || 0;
      this.shouldRotate = maxAgeSeconds && ageBuckets;
      this.ringBuffer = Array(ageBuckets).fill(new TDigest);
      this.currentBuffer = 0;
      this.lastRotateTimestampMillis = Date.now();
      this.durationBetweenRotatesMillis = maxAgeSeconds * 1000 / ageBuckets || Infinity;
    }
    size() {
      const bucket = rotate.call(this);
      return bucket.size();
    }
    percentile(quantile) {
      const bucket = rotate.call(this);
      return bucket.percentile(quantile);
    }
    push(value26) {
      rotate.call(this);
      this.ringBuffer.forEach((bucket) => {
        bucket.push(value26);
      });
    }
    reset() {
      this.ringBuffer.forEach((bucket) => {
        bucket.reset();
      });
    }
    compress() {
      this.ringBuffer.forEach((bucket) => {
        bucket.compress();
      });
    }
  }
  module.exports = TimeWindowQuantiles;
});

// node_modules/prom-client/lib/summary.js
var require_summary = __commonJS((exports, module) => {
  var extractSummariesForExport = function(summaryOfLabels, percentiles) {
    summaryOfLabels.td.compress();
    return percentiles.map((percentile) => {
      const percentileValue = summaryOfLabels.td.percentile(percentile);
      return {
        labels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),
        value: percentileValue ? percentileValue : 0
      };
    });
  };
  var getCountForExport = function(value26, summary) {
    return {
      metricName: `${summary.name}_count`,
      labels: value26.labels,
      value: value26.count
    };
  };
  var getSumForExport = function(value26, summary) {
    return {
      metricName: `${summary.name}_sum`,
      labels: value26.labels,
      value: value26.sum
    };
  };
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta2 = process.hrtime(start);
        const value26 = delta2[0] + delta2[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value26);
        return value26;
      };
    };
  };
  var observe = function(labels) {
    return (value26) => {
      const labelValuePair = convertLabelsAndValues(labels, value26);
      validateLabel(this.labelNames, labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util2.format(labelValuePair.value)}`);
      }
      const hash5 = hashObject(labelValuePair.labels, this.sortedLabelNames);
      let summaryOfLabel = this.hashMap[hash5];
      if (!summaryOfLabel) {
        summaryOfLabel = {
          labels: labelValuePair.labels,
          td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
          count: 0,
          sum: 0
        };
      }
      summaryOfLabel.td.push(labelValuePair.value);
      summaryOfLabel.count++;
      if (summaryOfLabel.count % this.compressCount === 0) {
        summaryOfLabel.td.compress();
      }
      summaryOfLabel.sum += labelValuePair.value;
      this.hashMap[hash5] = summaryOfLabel;
    };
  };
  var convertLabelsAndValues = function(labels, value26) {
    if (value26 === undefined) {
      return {
        value: labels,
        labels: {}
      };
    }
    return {
      labels,
      value: value26
    };
  };
  var util2 = import.meta.require("util");
  var { getLabels, hashObject, removeLabels } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var timeWindowQuantiles = require_timeWindowQuantiles();
  var DEFAULT_COMPRESS_COUNT = 1000;

  class Summary extends Metric {
    constructor(config) {
      super(config, {
        percentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],
        compressCount: DEFAULT_COMPRESS_COUNT,
        hashMap: {}
      });
      this.type = "summary";
      for (const label of this.labelNames) {
        if (label === "quantile")
          throw new Error("quantile is a reserved label keyword");
      }
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: {
            labels: {},
            td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
            count: 0,
            sum: 0
          }
        };
      }
    }
    observe(labels, value26) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value26);
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const hashKeys = Object.keys(this.hashMap);
      const values = [];
      hashKeys.forEach((hashKey) => {
        const s = this.hashMap[hashKey];
        if (s) {
          if (this.pruneAgedBuckets && s.td.size() === 0) {
            delete this.hashMap[hashKey];
          } else {
            extractSummariesForExport(s, this.percentiles).forEach((v) => {
              values.push(v);
            });
            values.push(getSumForExport(s, this));
            values.push(getCountForExport(s, this));
          }
        }
      });
      return {
        name: this.name,
        help: this.help,
        type: this.type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      const data = Object.values(this.hashMap);
      data.forEach((s) => {
        s.td.reset();
        s.count = 0;
        s.sum = 0;
      });
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);
    }
  }
  module.exports = Summary;
});

// node_modules/prom-client/lib/pushgateway.js
var require_pushgateway = __commonJS((exports, module) => {
  async function useGateway(method, job, groupings) {
    const gatewayUrlParsed = url.parse(this.gatewayUrl);
    const gatewayUrlPath = gatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== "/" ? gatewayUrlParsed.pathname : "";
    const jobPath = job ? `/job/${encodeURIComponent(job)}${generateGroupings(groupings)}` : "";
    const path = `${gatewayUrlPath}/metrics${jobPath}`;
    const target = url.resolve(this.gatewayUrl, path);
    const requestParams = url.parse(target);
    const httpModule = isHttps(requestParams.href) ? https : http;
    const options = Object.assign(requestParams, this.requestOptions, {
      method
    });
    return new Promise((resolve2, reject) => {
      if (method === "DELETE" && options.headers) {
        delete options.headers["Content-Encoding"];
      }
      const req = httpModule.request(options, (resp) => {
        let body = "";
        resp.setEncoding("utf8");
        resp.on("data", (chunk) => {
          body += chunk;
        });
        resp.on("end", () => {
          if (resp.statusCode >= 400) {
            reject(new Error(`push failed with status ${resp.statusCode}, ${body}`));
          } else {
            resolve2({ resp, body });
          }
        });
      });
      req.on("error", (err2) => {
        reject(err2);
      });
      req.on("timeout", () => {
        req.destroy(new Error("Pushgateway request timed out"));
      });
      if (method !== "DELETE") {
        this.registry.metrics().then((metrics) => {
          if (options.headers && options.headers["Content-Encoding"] === "gzip") {
            metrics = gzipSync(metrics);
          }
          req.write(metrics);
          req.end();
        }).catch((err2) => {
          reject(err2);
        });
      } else {
        req.end();
      }
    });
  }
  var generateGroupings = function(groupings) {
    if (!groupings) {
      return "";
    }
    return Object.keys(groupings).map((key) => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`).join("");
  };
  var isHttps = function(href) {
    return href.search(/^https/) !== -1;
  };
  var url = import.meta.require("url");
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var { gzipSync } = import.meta.require("zlib");
  var { globalRegistry } = require_registry();

  class Pushgateway {
    constructor(gatewayUrl, options, registry5) {
      if (!registry5) {
        registry5 = globalRegistry;
      }
      this.registry = registry5;
      this.gatewayUrl = gatewayUrl;
      const { requireJobName, ...requestOptions } = {
        requireJobName: true,
        ...options
      };
      this.requireJobName = requireJobName;
      this.requestOptions = requestOptions;
    }
    pushAdd(params = {}) {
      if (this.requireJobName && !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "POST", params.jobName, params.groupings);
    }
    push(params = {}) {
      if (this.requireJobName && !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "PUT", params.jobName, params.groupings);
    }
    delete(params = {}) {
      if (this.requireJobName && !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "DELETE", params.jobName, params.groupings);
    }
  }
  module.exports = Pushgateway;
});

// node_modules/prom-client/lib/bucketGenerators.js
var require_bucketGenerators = __commonJS((exports) => {
  exports.linearBuckets = (start, width, count) => {
    if (count < 1) {
      throw new Error("Linear buckets needs a positive count");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start + i * width;
    }
    return buckets;
  };
  exports.exponentialBuckets = (start, factor, count) => {
    if (start <= 0) {
      throw new Error("Exponential buckets needs a positive start");
    }
    if (count < 1) {
      throw new Error("Exponential buckets needs a positive count");
    }
    if (factor <= 1) {
      throw new Error("Exponential buckets needs a factor greater than 1");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start;
      start *= factor;
    }
    return buckets;
  };
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node4(), exports);
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  var _makeCompatibilityCheck = function(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version2();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  var registerGlobal = function(type54, instance, diag, allowOverride = false) {
    var _a2;
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== undefined ? _a2 : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type54]) {
      const err2 = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type54}`);
      diag.error(err2.stack || err2.message);
      return false;
    }
    if (api.version !== version_1.VERSION) {
      const err2 = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type54} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err2.stack || err2.message);
      return false;
    }
    api[type54] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type54} v${version_1.VERSION}.`);
    return true;
  };
  var getGlobal = function(type54) {
    var _a2, _b2;
    const globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === undefined ? undefined : _a2.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === undefined ? undefined : _b2[type54];
  };
  var unregisterGlobal = function(type54, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type54} v${version_1.VERSION}.`);
    const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type54];
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version2();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  exports.registerGlobal = registerGlobal;
  exports.getGlobal = getGlobal;
  exports.unregisterGlobal = unregisterGlobal;
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  var logProxy = function(funcName, namespace, args) {
    const logger2 = (0, global_utils_1.getGlobal)("diag");
    if (!logger2) {
      return;
    }
    args.unshift(namespace);
    return logger2[funcName](...args);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  var createLogLevelDiagLogger = function(maxLevel, logger2) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger2 = logger2 || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger2[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger2);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger2 = (0, global_utils_1.getGlobal)("diag");
          if (!logger2)
            return;
          return logger2[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger2, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a2, _b2, _c;
        if (logger2 === self2) {
          const err2 = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a2 = err2.stack) !== null && _a2 !== undefined ? _a2 : err2.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b2 = optionsOrLogLevel.logLevel) !== null && _b2 !== undefined ? _b2 : types_1.DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k2, v]) => [k2, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  var createBaggage = function(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  };
  var baggageEntryMetadataFromString = function(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  exports.createBaggage = createBaggage;
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  var createContextKey = function(description) {
    return Symbol.for(description);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value26) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value26);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  var createNoopMeter = function() {
    return exports.NOOP_METER;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {
    }
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {
    }
    removeBatchObservableCallback(_callback) {
    }
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {
    }
    removeCallback(_callback) {
    }
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  exports.createNoopMeter = createNoopMeter;
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType4;
  (function(ValueType5) {
    ValueType5[ValueType5["INT"] = 0] = "INT";
    ValueType5[ValueType5["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType4 = exports.ValueType || (exports.ValueType = {}));
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value26) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value26;
    }
  };
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {
    }
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {
    }
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  var getSpan = function(context) {
    return context.getValue(SPAN_KEY) || undefined;
  };
  var getActiveSpan = function() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  };
  var setSpan = function(context, span) {
    return context.setValue(SPAN_KEY, span);
  };
  var deleteSpan = function(context) {
    return context.deleteValue(SPAN_KEY);
  };
  var setSpanContext = function(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  };
  var getSpanContext = function(context) {
    var _a2;
    return (_a2 = getSpan(context)) === null || _a2 === undefined ? undefined : _a2.spanContext();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  exports.getSpan = getSpan;
  exports.getActiveSpan = getActiveSpan;
  exports.setSpan = setSpan;
  exports.deleteSpan = deleteSpan;
  exports.setSpanContext = setSpanContext;
  exports.getSpanContext = getSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  var isValidTraceId = function(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  };
  var isValidSpanId = function(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  };
  var isSpanContextValid = function(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  };
  var wrapSpanContext = function(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  exports.isValidTraceId = isValidTraceId;
  exports.isValidSpanId = isValidSpanId;
  exports.isSpanContextValid = isSpanContextValid;
  exports.wrapSpanContext = wrapSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  var isSpanContext = function(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version2, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version2;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version2, options) {
      var _a2;
      return (_a2 = this.getDelegateTracer(name, version2, options)) !== null && _a2 !== undefined ? _a2 : new ProxyTracer_1.ProxyTracer(this, name, version2, options);
    }
    getDelegate() {
      var _a2;
      return (_a2 = this._delegate) !== null && _a2 !== undefined ? _a2 : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version2, options) {
      var _a2;
      return (_a2 = this._delegate) === null || _a2 === undefined ? undefined : _a2.getTracer(name, version2, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  var validateKey = function(key) {
    return VALID_KEY_REGEX.test(key);
  };
  var validateValue = function(value26) {
    return VALID_VALUE_BASE_REGEX.test(value26) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value26);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})\$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  exports.validateKey = validateKey;
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value26) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value26);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value26 = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value26)) {
            agg.set(key, value26);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  var createTraceState = function(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  exports.createTraceState = createTraceState;
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version2, options) {
      return this.getMeterProvider().getMeter(name, version2, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {
    }
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  var getBaggage = function(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  };
  var getActiveBaggage = function() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  };
  var setBaggage = function(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  };
  var deleteBaggage = function(context) {
    return context.deleteValue(BAGGAGE_KEY);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  exports.getBaggage = getBaggage;
  exports.getActiveBaggage = getActiveBaggage;
  exports.setBaggage = setBaggage;
  exports.deleteBaggage = deleteBaggage;
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version2) {
      return this.getTracerProvider().getTracer(name, version2);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// node_modules/prom-client/lib/metrics/processCpuTotal.js
var require_processCpuTotal = __commonJS((exports, module) => {
  var OtelApi = require_src2();
  var Counter = require_counter();
  var PROCESS_CPU_USER_SECONDS = "process_cpu_user_seconds_total";
  var PROCESS_CPU_SYSTEM_SECONDS = "process_cpu_system_seconds_total";
  var PROCESS_CPU_SECONDS = "process_cpu_seconds_total";
  module.exports = (registry5, config = {}) => {
    const registers = registry5 ? [registry5] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const exemplars = config.enableExemplars ? config.enableExemplars : false;
    const labelNames = Object.keys(labels);
    let lastCpuUsage = process.cpuUsage();
    const cpuUserUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_USER_SECONDS,
      help: "Total user CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames,
      collect() {
        const cpuUsage = process.cpuUsage();
        const userUsageMicros = cpuUsage.user - lastCpuUsage.user;
        const systemUsageMicros = cpuUsage.system - lastCpuUsage.system;
        lastCpuUsage = cpuUsage;
        if (this.enableExemplars) {
          let exemplarLabels = {};
          const currentSpan = OtelApi.trace.getSpan(OtelApi.context.active());
          if (currentSpan) {
            exemplarLabels = {
              traceId: currentSpan.spanContext().traceId,
              spanId: currentSpan.spanContext().spanId
            };
          }
          cpuUserUsageCounter.inc({
            labels,
            value: userUsageMicros / 1e6,
            exemplarLabels
          });
          cpuSystemUsageCounter.inc({
            labels,
            value: systemUsageMicros / 1e6,
            exemplarLabels
          });
          cpuUsageCounter.inc({
            labels,
            value: (userUsageMicros + systemUsageMicros) / 1e6,
            exemplarLabels
          });
        } else {
          cpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);
          cpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);
          cpuUsageCounter.inc(labels, (userUsageMicros + systemUsageMicros) / 1e6);
        }
      }
    });
    const cpuSystemUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,
      help: "Total system CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames
    });
    const cpuUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SECONDS,
      help: "Total user and system CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_CPU_USER_SECONDS,
    PROCESS_CPU_SYSTEM_SECONDS,
    PROCESS_CPU_SECONDS
  ];
});

// node_modules/prom-client/lib/metrics/processStartTime.js
var require_processStartTime = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var startInSeconds = Math.round(Date.now() / 1000 - process.uptime());
  var PROCESS_START_TIME = "process_start_time_seconds";
  module.exports = (registry5, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_START_TIME,
      help: "Start time of the process since unix epoch in seconds.",
      registers: registry5 ? [registry5] : undefined,
      labelNames,
      aggregator: "omit",
      collect() {
        this.set(labels, startInSeconds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_START_TIME];
});

// node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js
var require_osMemoryHeapLinux = __commonJS((exports, module) => {
  var structureOutput = function(input) {
    return input.split("\n").reduce((acc, string5) => {
      if (!values.some((value27) => string5.startsWith(value27))) {
        return acc;
      }
      const split = string5.split(":");
      let value26 = split[1].trim();
      value26 = value26.substr(0, value26.length - 3);
      value26 = Number(value26) * 1024;
      acc[split[0]] = value26;
      return acc;
    }, {});
  };
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var values = ["VmSize", "VmRSS", "VmData"];
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  var PROCESS_VIRTUAL_MEMORY = "process_virtual_memory_bytes";
  var PROCESS_HEAP = "process_heap_bytes";
  module.exports = (registry5, config = {}) => {
    const registers = registry5 ? [registry5] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const residentMemGauge = new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers,
      labelNames,
      collect() {
        try {
          const stat4 = fs.readFileSync("/proc/self/status", "utf8");
          const structuredOutput = structureOutput(stat4);
          residentMemGauge.set(labels, structuredOutput.VmRSS);
          virtualMemGauge.set(labels, structuredOutput.VmSize);
          heapSizeMemGauge.set(labels, structuredOutput.VmData);
        } catch {
        }
      }
    });
    const virtualMemGauge = new Gauge({
      name: namePrefix + PROCESS_VIRTUAL_MEMORY,
      help: "Virtual memory size in bytes.",
      registers,
      labelNames
    });
    const heapSizeMemGauge = new Gauge({
      name: namePrefix + PROCESS_HEAP,
      help: "Process heap size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_RESIDENT_MEMORY,
    PROCESS_VIRTUAL_MEMORY,
    PROCESS_HEAP
  ];
});

// node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js
var require_safeMemoryUsage = __commonJS((exports, module) => {
  var safeMemoryUsage = function() {
    try {
      return process.memoryUsage();
    } catch {
      return;
    }
  };
  module.exports = safeMemoryUsage;
});

// node_modules/prom-client/lib/metrics/osMemoryHeap.js
var require_osMemoryHeap = __commonJS((exports, module) => {
  var notLinuxVariant = function(registry5, config = {}) {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers: registry5 ? [registry5] : undefined,
      labelNames,
      collect() {
        const memUsage = safeMemoryUsage();
        if (memUsage) {
          this.set(labels, memUsage.rss);
        }
      }
    });
  };
  var Gauge = require_gauge();
  var linuxVariant = require_osMemoryHeapLinux();
  var safeMemoryUsage = require_safeMemoryUsage();
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  module.exports = (registry5, config) => process.platform === "linux" ? linuxVariant(registry5, config) : notLinuxVariant(registry5, config);
  module.exports.metricNames = process.platform === "linux" ? linuxVariant.metricNames : [PROCESS_RESIDENT_MEMORY];
});

// node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js
var require_processOpenFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var process2 = import.meta.require("process");
  var PROCESS_OPEN_FDS = "process_open_fds";
  module.exports = (registry5, config = {}) => {
    if (process2.platform !== "linux") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_OPEN_FDS,
      help: "Number of open file descriptors.",
      registers: registry5 ? [registry5] : undefined,
      labelNames,
      collect() {
        try {
          const fds = fs.readdirSync("/proc/self/fd");
          this.set(labels, fds.length - 1);
        } catch {
        }
      }
    });
  };
  module.exports.metricNames = [PROCESS_OPEN_FDS];
});

// node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js
var require_processMaxFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var PROCESS_MAX_FDS = "process_max_fds";
  var maxFds;
  module.exports = (registry5, config = {}) => {
    if (maxFds === undefined) {
      try {
        const limits = fs.readFileSync("/proc/self/limits", "utf8");
        const lines = limits.split("\n");
        for (const line of lines) {
          if (line.startsWith("Max open files")) {
            const parts = line.split(/  +/);
            maxFds = Number(parts[1]);
            break;
          }
        }
      } catch {
        return;
      }
    }
    if (maxFds === undefined)
      return;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_MAX_FDS,
      help: "Maximum number of open file descriptors.",
      registers: registry5 ? [registry5] : undefined,
      labelNames,
      collect() {
        if (maxFds !== undefined)
          this.set(labels, maxFds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_MAX_FDS];
});

// node_modules/prom-client/lib/metrics/eventLoopLag.js
var require_eventLoopLag = __commonJS((exports, module) => {
  var reportEventloopLag = function(start, gauge, labels) {
    const delta2 = process.hrtime(start);
    const nanosec = delta2[0] * 1e9 + delta2[1];
    const seconds = nanosec / 1e9;
    gauge.set(labels, seconds);
  };
  var Gauge = require_gauge();
  var perf_hooks;
  try {
    perf_hooks = import.meta.require("perf_hooks");
  } catch {
  }
  var NODEJS_EVENTLOOP_LAG = "nodejs_eventloop_lag_seconds";
  var NODEJS_EVENTLOOP_LAG_MIN = "nodejs_eventloop_lag_min_seconds";
  var NODEJS_EVENTLOOP_LAG_MAX = "nodejs_eventloop_lag_max_seconds";
  var NODEJS_EVENTLOOP_LAG_MEAN = "nodejs_eventloop_lag_mean_seconds";
  var NODEJS_EVENTLOOP_LAG_STDDEV = "nodejs_eventloop_lag_stddev_seconds";
  var NODEJS_EVENTLOOP_LAG_P50 = "nodejs_eventloop_lag_p50_seconds";
  var NODEJS_EVENTLOOP_LAG_P90 = "nodejs_eventloop_lag_p90_seconds";
  var NODEJS_EVENTLOOP_LAG_P99 = "nodejs_eventloop_lag_p99_seconds";
  module.exports = (registry5, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry5 ? [registry5] : undefined;
    let collect = () => {
      const start = process.hrtime();
      setImmediate(reportEventloopLag, start, lag, labels);
    };
    if (perf_hooks && perf_hooks.monitorEventLoopDelay) {
      try {
        const histogram = perf_hooks.monitorEventLoopDelay({
          resolution: config.eventLoopMonitoringPrecision
        });
        histogram.enable();
        collect = () => {
          const start = process.hrtime();
          setImmediate(reportEventloopLag, start, lag, labels);
          lagMin.set(labels, histogram.min / 1e9);
          lagMax.set(labels, histogram.max / 1e9);
          lagMean.set(labels, histogram.mean / 1e9);
          lagStddev.set(labels, histogram.stddev / 1e9);
          lagP50.set(labels, histogram.percentile(50) / 1e9);
          lagP90.set(labels, histogram.percentile(90) / 1e9);
          lagP99.set(labels, histogram.percentile(99) / 1e9);
          histogram.reset();
        };
      } catch (e) {
        if (e.code === "ERR_NOT_IMPLEMENTED") {
          return;
        }
        throw e;
      }
    }
    const lag = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG,
      help: "Lag of event loop in seconds.",
      registers,
      labelNames,
      aggregator: "average",
      collect
    });
    const lagMin = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,
      help: "The minimum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "min"
    });
    const lagMax = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,
      help: "The maximum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "max"
    });
    const lagMean = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,
      help: "The mean of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagStddev = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,
      help: "The standard deviation of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP50 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P50,
      help: "The 50th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP90 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P90,
      help: "The 90th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP99 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P99,
      help: "The 99th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
  };
  module.exports.metricNames = [
    NODEJS_EVENTLOOP_LAG,
    NODEJS_EVENTLOOP_LAG_MIN,
    NODEJS_EVENTLOOP_LAG_MAX,
    NODEJS_EVENTLOOP_LAG_MEAN,
    NODEJS_EVENTLOOP_LAG_STDDEV,
    NODEJS_EVENTLOOP_LAG_P50,
    NODEJS_EVENTLOOP_LAG_P90,
    NODEJS_EVENTLOOP_LAG_P99
  ];
});

// node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js
var require_processMetricsHelpers = __commonJS((exports, module) => {
  var aggregateByObjectName = function(list) {
    const data = {};
    for (let i = 0;i < list.length; i++) {
      const listElement = list[i];
      if (!listElement || typeof listElement.constructor === "undefined") {
        continue;
      }
      if (Object.hasOwnProperty.call(data, listElement.constructor.name)) {
        data[listElement.constructor.name] += 1;
      } else {
        data[listElement.constructor.name] = 1;
      }
    }
    return data;
  };
  var updateMetrics = function(gauge, data, labels) {
    gauge.reset();
    for (const key in data) {
      gauge.set(Object.assign({ type: key }, labels || {}), data[key]);
    }
  };
  module.exports = {
    aggregateByObjectName,
    updateMetrics
  };
});

// node_modules/prom-client/lib/metrics/processHandles.js
var require_processHandles = __commonJS((exports, module) => {
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var Gauge = require_gauge();
  var NODEJS_ACTIVE_HANDLES = "nodejs_active_handles";
  var NODEJS_ACTIVE_HANDLES_TOTAL = "nodejs_active_handles_total";
  module.exports = (registry5, config = {}) => {
    if (typeof process._getActiveHandles !== "function") {
      return;
    }
    const registers = registry5 ? [registry5] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES,
      help: "Number of active libuv handles grouped by handle type. Every handle type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers,
      collect() {
        const handles = process._getActiveHandles();
        updateMetrics(this, aggregateByObjectName(handles), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,
      help: "Total number of active handles.",
      registers,
      labelNames,
      collect() {
        const handles = process._getActiveHandles();
        this.set(labels, handles.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_HANDLES,
    NODEJS_ACTIVE_HANDLES_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/processRequests.js
var require_processRequests = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_REQUESTS = "nodejs_active_requests";
  var NODEJS_ACTIVE_REQUESTS_TOTAL = "nodejs_active_requests_total";
  module.exports = (registry5, config = {}) => {
    if (typeof process._getActiveRequests !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS,
      help: "Number of active libuv requests grouped by request type. Every request type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers: registry5 ? [registry5] : undefined,
      collect() {
        const requests = process._getActiveRequests();
        updateMetrics(this, aggregateByObjectName(requests), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,
      help: "Total number of active requests.",
      registers: registry5 ? [registry5] : undefined,
      labelNames,
      collect() {
        const requests = process._getActiveRequests();
        this.set(labels, requests.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_REQUESTS,
    NODEJS_ACTIVE_REQUESTS_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/processResources.js
var require_processResources = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_RESOURCES = "nodejs_active_resources";
  var NODEJS_ACTIVE_RESOURCES_TOTAL = "nodejs_active_resources_total";
  module.exports = (registry5, config = {}) => {
    if (typeof process.getActiveResourcesInfo !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES,
      help: "Number of active resources that are currently keeping the event loop alive, grouped by async resource type.",
      labelNames: ["type", ...labelNames],
      registers: registry5 ? [registry5] : undefined,
      collect() {
        const resources = process.getActiveResourcesInfo();
        const data = {};
        for (let i = 0;i < resources.length; i++) {
          const resource = resources[i];
          if (Object.hasOwn(data, resource)) {
            data[resource] += 1;
          } else {
            data[resource] = 1;
          }
        }
        updateMetrics(this, data, labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,
      help: "Total number of active resources.",
      registers: registry5 ? [registry5] : undefined,
      labelNames,
      collect() {
        const resources = process.getActiveResourcesInfo();
        this.set(labels, resources.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_RESOURCES,
    NODEJS_ACTIVE_RESOURCES_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/heapSizeAndUsed.js
var require_heapSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var safeMemoryUsage = require_safeMemoryUsage();
  var NODEJS_HEAP_SIZE_TOTAL = "nodejs_heap_size_total_bytes";
  var NODEJS_HEAP_SIZE_USED = "nodejs_heap_size_used_bytes";
  var NODEJS_EXTERNAL_MEMORY = "nodejs_external_memory_bytes";
  module.exports = (registry5, config = {}) => {
    if (typeof process.memoryUsage !== "function") {
      return;
    }
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry5 ? [registry5] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const collect = () => {
      const memUsage = safeMemoryUsage();
      if (memUsage) {
        heapSizeTotal.set(labels, memUsage.heapTotal);
        heapSizeUsed.set(labels, memUsage.heapUsed);
        if (memUsage.external !== undefined) {
          externalMemUsed.set(labels, memUsage.external);
        }
      }
    };
    const heapSizeTotal = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_TOTAL,
      help: "Process heap size from Node.js in bytes.",
      registers,
      labelNames,
      collect
    });
    const heapSizeUsed = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_USED,
      help: "Process heap size used from Node.js in bytes.",
      registers,
      labelNames
    });
    const externalMemUsed = new Gauge({
      name: namePrefix + NODEJS_EXTERNAL_MEMORY,
      help: "Node.js external memory size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    NODEJS_HEAP_SIZE_TOTAL,
    NODEJS_HEAP_SIZE_USED,
    NODEJS_EXTERNAL_MEMORY
  ];
});

// node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js
var require_heapSpacesSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var v8 = import.meta.require("v8");
  var METRICS = ["total", "used", "available"];
  var NODEJS_HEAP_SIZE = {};
  METRICS.forEach((metricType) => {
    NODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;
  });
  module.exports = (registry5, config = {}) => {
    try {
      v8.getHeapSpaceStatistics();
    } catch (e) {
      if (e.code === "ERR_NOT_IMPLEMENTED") {
        return;
      }
      throw e;
    }
    const registers = registry5 ? [registry5] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = ["space", ...Object.keys(labels)];
    const gauges = {};
    METRICS.forEach((metricType) => {
      gauges[metricType] = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE[metricType],
        help: `Process heap space size ${metricType} from Node.js in bytes.`,
        labelNames,
        registers
      });
    });
    gauges.total.collect = () => {
      for (const space of v8.getHeapSpaceStatistics()) {
        const spaceName = space.space_name.substr(0, space.space_name.indexOf("_space"));
        gauges.total.set({ space: spaceName, ...labels }, space.space_size);
        gauges.used.set({ space: spaceName, ...labels }, space.space_used_size);
        gauges.available.set({ space: spaceName, ...labels }, space.space_available_size);
      }
    };
  };
  module.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);
});

// node_modules/prom-client/lib/metrics/version.js
var require_version3 = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var version2 = process.version;
  var versionSegments = version2.slice(1).split(".").map(Number);
  var NODE_VERSION_INFO = "nodejs_version_info";
  module.exports = (registry5, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODE_VERSION_INFO,
      help: "Node.js version info.",
      labelNames: ["version", "major", "minor", "patch", ...labelNames],
      registers: registry5 ? [registry5] : undefined,
      aggregator: "first",
      collect() {
        this.labels(version2, versionSegments[0], versionSegments[1], versionSegments[2], ...Object.values(labels)).set(1);
      }
    });
  };
  module.exports.metricNames = [NODE_VERSION_INFO];
});

// node_modules/prom-client/lib/metrics/gc.js
var require_gc = __commonJS((exports, module) => {
  var Histogram = require_histogram();
  var perf_hooks;
  try {
    perf_hooks = import.meta.require("perf_hooks");
  } catch {
  }
  var NODEJS_GC_DURATION_SECONDS = "nodejs_gc_duration_seconds";
  var DEFAULT_GC_DURATION_BUCKETS = [0.001, 0.01, 0.1, 1, 2, 5];
  var kinds = [];
  if (perf_hooks && perf_hooks.constants) {
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = "major";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = "minor";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = "incremental";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = "weakcb";
  }
  module.exports = (registry5, config = {}) => {
    if (!perf_hooks) {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const buckets = config.gcDurationBuckets ? config.gcDurationBuckets : DEFAULT_GC_DURATION_BUCKETS;
    const gcHistogram = new Histogram({
      name: namePrefix + NODEJS_GC_DURATION_SECONDS,
      help: "Garbage collection duration by kind, one of major, minor, incremental or weakcb.",
      labelNames: ["kind", ...labelNames],
      enableExemplars: false,
      buckets,
      registers: registry5 ? [registry5] : undefined
    });
    const obs = new perf_hooks.PerformanceObserver((list) => {
      const entry = list.getEntries()[0];
      const kind31 = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];
      gcHistogram.observe(Object.assign({ kind: kind31 }, labels), entry.duration / 1000);
    });
    obs.observe({ entryTypes: ["gc"] });
  };
  module.exports.metricNames = [NODEJS_GC_DURATION_SECONDS];
});

// node_modules/prom-client/lib/defaultMetrics.js
var require_defaultMetrics = __commonJS((exports, module) => {
  var { isObject: isObject2 } = require_util();
  var processCpuTotal = require_processCpuTotal();
  var processStartTime = require_processStartTime();
  var osMemoryHeap = require_osMemoryHeap();
  var processOpenFileDescriptors = require_processOpenFileDescriptors();
  var processMaxFileDescriptors = require_processMaxFileDescriptors();
  var eventLoopLag = require_eventLoopLag();
  var processHandles = require_processHandles();
  var processRequests = require_processRequests();
  var processResources = require_processResources();
  var heapSizeAndUsed = require_heapSizeAndUsed();
  var heapSpacesSizeAndUsed = require_heapSpacesSizeAndUsed();
  var version2 = require_version3();
  var gc = require_gc();
  var metrics = {
    processCpuTotal,
    processStartTime,
    osMemoryHeap,
    processOpenFileDescriptors,
    processMaxFileDescriptors,
    eventLoopLag,
    ...typeof process.getActiveResourcesInfo === "function" ? { processResources } : {},
    processHandles,
    processRequests,
    heapSizeAndUsed,
    heapSpacesSizeAndUsed,
    version: version2,
    gc
  };
  var metricsList = Object.keys(metrics);
  module.exports = function collectDefaultMetrics(config) {
    if (config !== null && config !== undefined && !isObject2(config)) {
      throw new TypeError("config must be null, undefined, or an object");
    }
    config = { eventLoopMonitoringPrecision: 10, ...config };
    for (const metric of Object.values(metrics)) {
      metric(config.register, config);
    }
  };
  module.exports.metricsList = metricsList;
});

// node_modules/prom-client/lib/metricAggregators.js
var require_metricAggregators = __commonJS((exports) => {
  var AggregatorFactory = function(aggregatorFn) {
    return (metrics) => {
      if (metrics.length === 0)
        return;
      const result = {
        help: metrics[0].help,
        name: metrics[0].name,
        type: metrics[0].type,
        values: [],
        aggregator: metrics[0].aggregator
      };
      const byLabels = new Grouper;
      metrics.forEach((metric) => {
        metric.values.forEach((value26) => {
          const key = hashObject(value26.labels);
          byLabels.add(`${value26.metricName}_${key}`, value26);
        });
      });
      byLabels.forEach((values) => {
        if (values.length === 0)
          return;
        const valObj = {
          value: aggregatorFn(values),
          labels: values[0].labels
        };
        if (values[0].metricName) {
          valObj.metricName = values[0].metricName;
        }
        result.values.push(valObj);
      });
      return result;
    };
  };
  var { Grouper, hashObject } = require_util();
  exports.AggregatorFactory = AggregatorFactory;
  exports.aggregators = {
    sum: AggregatorFactory((v) => v.reduce((p, c) => p + c.value, 0)),
    first: AggregatorFactory((v) => v[0].value),
    omit: () => {
    },
    average: AggregatorFactory((v) => v.reduce((p, c) => p + c.value, 0) / v.length),
    min: AggregatorFactory((v) => v.reduce((p, c) => Math.min(p, c.value), Infinity)),
    max: AggregatorFactory((v) => v.reduce((p, c) => Math.max(p, c.value), (-Infinity)))
  };
});

// node_modules/prom-client/lib/cluster.js
var require_cluster = __commonJS((exports, module) => {
  var addListeners = function() {
    if (listenersAdded)
      return;
    listenersAdded = true;
    if (cluster().isMaster) {
      cluster().on("message", (worker, message) => {
        if (message.type === GET_METRICS_RES) {
          const request = requests.get(message.requestId);
          if (message.error) {
            request.done(new Error(message.error));
            return;
          }
          message.metrics.forEach((registry5) => request.responses.push(registry5));
          request.pending--;
          if (request.pending === 0) {
            requests.delete(message.requestId);
            clearTimeout(request.errorTimeout);
            const registry5 = AggregatorRegistry.aggregate(request.responses);
            const promString = registry5.metrics();
            request.done(null, promString);
          }
        }
      });
    }
    if (cluster().isWorker) {
      process.on("message", (message) => {
        if (message.type === GET_METRICS_REQ) {
          Promise.all(registries.map((r) => r.getMetricsAsJSON())).then((metrics) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              metrics
            });
          }).catch((error23) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              error: error23.message
            });
          });
        }
      });
    }
  };
  var Registry = require_registry();
  var { Grouper } = require_util();
  var { aggregators } = require_metricAggregators();
  var cluster = () => {
    const data = import.meta.require("cluster");
    cluster = () => data;
    return data;
  };
  var GET_METRICS_REQ = "prom-client:getMetricsReq";
  var GET_METRICS_RES = "prom-client:getMetricsRes";
  var registries = [Registry.globalRegistry];
  var requestCtr = 0;
  var listenersAdded = false;
  var requests = new Map;

  class AggregatorRegistry extends Registry {
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {
      super(regContentType);
      addListeners();
    }
    clusterMetrics() {
      const requestId = requestCtr++;
      return new Promise((resolve2, reject) => {
        let settled = false;
        function done(err2, result) {
          if (settled)
            return;
          settled = true;
          if (err2)
            reject(err2);
          else
            resolve2(result);
        }
        const request = {
          responses: [],
          pending: 0,
          done,
          errorTimeout: setTimeout(() => {
            const err2 = new Error("Operation timed out.");
            request.done(err2);
          }, 5000)
        };
        requests.set(requestId, request);
        const message = {
          type: GET_METRICS_REQ,
          requestId
        };
        for (const id in cluster().workers) {
          if (cluster().workers[id].isConnected()) {
            cluster().workers[id].send(message);
            request.pending++;
          }
        }
        if (request.pending === 0) {
          clearTimeout(request.errorTimeout);
          process.nextTick(() => done(null, ""));
        }
      });
    }
    get contentType() {
      return super.contentType;
    }
    static aggregate(metricsArr, registryType = Registry.PROMETHEUS_CONTENT_TYPE) {
      const aggregatedRegistry = new Registry;
      const metricsByName = new Grouper;
      aggregatedRegistry.setContentType(registryType);
      metricsArr.forEach((metrics) => {
        metrics.forEach((metric) => {
          metricsByName.add(metric.name, metric);
        });
      });
      metricsByName.forEach((metrics) => {
        const aggregatorName = metrics[0].aggregator;
        const aggregatorFn = aggregators[aggregatorName];
        if (typeof aggregatorFn !== "function") {
          throw new Error(`'${aggregatorName}' is not a defined aggregator.`);
        }
        const aggregatedMetric = aggregatorFn(metrics);
        if (aggregatedMetric) {
          const aggregatedMetricWrapper = Object.assign({
            get: () => aggregatedMetric
          }, aggregatedMetric);
          aggregatedRegistry.registerMetric(aggregatedMetricWrapper);
        }
      });
      return aggregatedRegistry;
    }
    static setRegistries(regs) {
      if (!Array.isArray(regs))
        regs = [regs];
      regs.forEach((reg) => {
        if (!(reg instanceof Registry)) {
          throw new TypeError(`Expected Registry, got ${typeof reg}`);
        }
      });
      registries = regs;
    }
  }
  module.exports = AggregatorRegistry;
});

// node_modules/prom-client/index.js
var require_prom_client = __commonJS((exports) => {
  exports.register = require_registry().globalRegistry;
  exports.Registry = require_registry();
  Object.defineProperty(exports, "contentType", {
    configurable: false,
    enumerable: true,
    get() {
      return exports.register.contentType;
    },
    set(value26) {
      exports.register.setContentType(value26);
    }
  });
  exports.prometheusContentType = exports.Registry.PROMETHEUS_CONTENT_TYPE;
  exports.openMetricsContentType = exports.Registry.OPENMETRICS_CONTENT_TYPE;
  exports.validateMetricName = require_validation().validateMetricName;
  exports.Counter = require_counter();
  exports.Gauge = require_gauge();
  exports.Histogram = require_histogram();
  exports.Summary = require_summary();
  exports.Pushgateway = require_pushgateway();
  exports.linearBuckets = require_bucketGenerators().linearBuckets;
  exports.exponentialBuckets = require_bucketGenerators().exponentialBuckets;
  exports.collectDefaultMetrics = require_defaultMetrics();
  exports.aggregators = require_metricAggregators().aggregators;
  exports.AggregatorRegistry = require_cluster();
});

// node_modules/@redis/client/dist/lib/commands/APPEND.js
var require_APPEND = __commonJS((exports) => {
  var transformArguments = function(key, value26) {
    return ["APPEND", key, value26];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITCOUNT.js
var require_BITCOUNT = __commonJS((exports) => {
  var transformArguments = function(key, range) {
    const args = ["BITCOUNT", key];
    if (range) {
      args.push(range.start.toString(), range.end.toString());
      if (range.mode) {
        args.push(range.mode);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD_RO.js
var require_BITFIELD_RO = __commonJS((exports) => {
  var transformArguments = function(key, operations) {
    const args = ["BITFIELD_RO", key];
    for (const operation of operations) {
      args.push("GET", operation.encoding, operation.offset.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD.js
var require_BITFIELD = __commonJS((exports) => {
  var transformArguments = function(key, operations) {
    const args = ["BITFIELD", key];
    for (const options of operations) {
      switch (options.operation) {
        case "GET":
          args.push("GET", options.encoding, options.offset.toString());
          break;
        case "SET":
          args.push("SET", options.encoding, options.offset.toString(), options.value.toString());
          break;
        case "INCRBY":
          args.push("INCRBY", options.encoding, options.offset.toString(), options.increment.toString());
          break;
        case "OVERFLOW":
          args.push("OVERFLOW", options.behavior);
          break;
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/generic-transformers.js
var require_generic_transformers = __commonJS((exports) => {
  var transformBooleanReply = function(reply) {
    return reply === 1;
  };
  var transformBooleanArrayReply = function(reply) {
    return reply.map(transformBooleanReply);
  };
  var pushScanArguments = function(args, cursor, options) {
    args.push(cursor.toString());
    if (options?.MATCH) {
      args.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformNumberInfinityReply = function(reply) {
    switch (reply.toString()) {
      case "+inf":
        return Infinity;
      case "-inf":
        return (-Infinity);
      default:
        return Number(reply);
    }
  };
  var transformNumberInfinityNullReply = function(reply) {
    if (reply === null)
      return null;
    return transformNumberInfinityReply(reply);
  };
  var transformNumberInfinityNullArrayReply = function(reply) {
    return reply.map(transformNumberInfinityNullReply);
  };
  var transformNumberInfinityArgument = function(num) {
    switch (num) {
      case Infinity:
        return "+inf";
      case (-Infinity):
        return "-inf";
      default:
        return num.toString();
    }
  };
  var transformStringNumberInfinityArgument = function(num) {
    if (typeof num !== "number")
      return num;
    return transformNumberInfinityArgument(num);
  };
  var transformTuplesReply = function(reply) {
    const message = Object.create(null);
    for (let i = 0;i < reply.length; i += 2) {
      message[reply[i].toString()] = reply[i + 1];
    }
    return message;
  };
  var transformStreamMessageReply = function([id, message]) {
    return {
      id,
      message: transformTuplesReply(message)
    };
  };
  var transformStreamMessageNullReply = function(reply) {
    if (reply === null)
      return null;
    return transformStreamMessageReply(reply);
  };
  var transformStreamMessagesReply = function(reply) {
    return reply.map(transformStreamMessageReply);
  };
  var transformStreamMessagesNullReply = function(reply) {
    return reply.map(transformStreamMessageNullReply);
  };
  var transformStreamsMessagesReply = function(reply) {
    if (reply === null)
      return null;
    return reply.map(([name, rawMessages]) => ({
      name,
      messages: transformStreamMessagesReply(rawMessages)
    }));
  };
  var transformSortedSetMemberNullReply = function(reply) {
    if (!reply.length)
      return null;
    return transformSortedSetMemberReply(reply);
  };
  var transformSortedSetMemberReply = function(reply) {
    return {
      value: reply[0],
      score: transformNumberInfinityReply(reply[1])
    };
  };
  var transformSortedSetWithScoresReply = function(reply) {
    const members = [];
    for (let i = 0;i < reply.length; i += 2) {
      members.push({
        value: reply[i],
        score: transformNumberInfinityReply(reply[i + 1])
      });
    }
    return members;
  };
  var transformZMPopArguments = function(args, keys, side, options) {
    pushVerdictArgument(args, keys);
    args.push(side);
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformLMPopArguments = function(args, keys, side, options) {
    pushVerdictArgument(args, keys);
    args.push(side);
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var pushGeoCountArgument = function(args, count) {
    if (typeof count === "number") {
      args.push("COUNT", count.toString());
    } else if (count) {
      args.push("COUNT", count.value.toString());
      if (count.ANY) {
        args.push("ANY");
      }
    }
    return args;
  };
  var pushGeoSearchArguments = function(args, key, from, by, options) {
    args.push(key);
    if (typeof from === "string") {
      args.push("FROMMEMBER", from);
    } else {
      args.push("FROMLONLAT", from.longitude.toString(), from.latitude.toString());
    }
    if ("radius" in by) {
      args.push("BYRADIUS", by.radius.toString());
    } else {
      args.push("BYBOX", by.width.toString(), by.height.toString());
    }
    args.push(by.unit);
    if (options?.SORT) {
      args.push(options.SORT);
    }
    pushGeoCountArgument(args, options?.COUNT);
    return args;
  };
  var pushGeoRadiusArguments = function(args, key, from, radius, unit, options) {
    args.push(key);
    if (typeof from === "string") {
      args.push(from);
    } else {
      args.push(from.longitude.toString(), from.latitude.toString());
    }
    args.push(radius.toString(), unit);
    if (options?.SORT) {
      args.push(options.SORT);
    }
    pushGeoCountArgument(args, options?.COUNT);
    return args;
  };
  var pushGeoRadiusStoreArguments = function(args, key, from, radius, unit, destination, options) {
    pushGeoRadiusArguments(args, key, from, radius, unit, options);
    if (options?.STOREDIST) {
      args.push("STOREDIST", destination);
    } else {
      args.push("STORE", destination);
    }
    return args;
  };
  var transformGeoMembersWithReply = function(reply, replyWith) {
    const replyWithSet = new Set(replyWith);
    let index = 0;
    const distanceIndex = replyWithSet.has(GeoReplyWith.DISTANCE) && ++index, hashIndex = replyWithSet.has(GeoReplyWith.HASH) && ++index, coordinatesIndex = replyWithSet.has(GeoReplyWith.COORDINATES) && ++index;
    return reply.map((member) => {
      const transformedMember = {
        member: member[0]
      };
      if (distanceIndex) {
        transformedMember.distance = member[distanceIndex];
      }
      if (hashIndex) {
        transformedMember.hash = member[hashIndex];
      }
      if (coordinatesIndex) {
        const [longitude, latitude] = member[coordinatesIndex];
        transformedMember.coordinates = {
          longitude,
          latitude
        };
      }
      return transformedMember;
    });
  };
  var transformEXAT = function(EXAT) {
    return (typeof EXAT === "number" ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
  };
  var transformPXAT = function(PXAT) {
    return (typeof PXAT === "number" ? PXAT : PXAT.getTime()).toString();
  };
  var evalFirstKeyIndex = function(options) {
    return options?.keys?.[0];
  };
  var pushEvalArguments = function(args, options) {
    if (options?.keys) {
      args.push(options.keys.length.toString(), ...options.keys);
    } else {
      args.push("0");
    }
    if (options?.arguments) {
      args.push(...options.arguments);
    }
    return args;
  };
  var pushVerdictArguments = function(args, value26) {
    if (Array.isArray(value26)) {
      args = args.concat(value26);
    } else {
      args.push(value26);
    }
    return args;
  };
  var pushVerdictNumberArguments = function(args, value26) {
    if (Array.isArray(value26)) {
      for (const item of value26) {
        args.push(item.toString());
      }
    } else {
      args.push(value26.toString());
    }
    return args;
  };
  var pushVerdictArgument = function(args, value26) {
    if (Array.isArray(value26)) {
      args.push(value26.length.toString(), ...value26);
    } else {
      args.push("1", value26);
    }
    return args;
  };
  var pushOptionalVerdictArgument = function(args, name, value26) {
    if (value26 === undefined)
      return args;
    args.push(name);
    return pushVerdictArgument(args, value26);
  };
  var transformCommandReply = function([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
    return {
      name,
      arity,
      flags: new Set(flags),
      firstKeyIndex,
      lastKeyIndex,
      step,
      categories: new Set(categories)
    };
  };
  var transformFunctionListItemReply = function(reply) {
    return {
      libraryName: reply[1],
      engine: reply[3],
      functions: reply[5].map((fn) => ({
        name: fn[1],
        description: fn[3],
        flags: fn[5]
      }))
    };
  };
  var pushSortArguments = function(args, options) {
    if (options?.BY) {
      args.push("BY", options.BY);
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.GET) {
      for (const pattern2 of typeof options.GET === "string" ? [options.GET] : options.GET) {
        args.push("GET", pattern2);
      }
    }
    if (options?.DIRECTION) {
      args.push(options.DIRECTION);
    }
    if (options?.ALPHA) {
      args.push("ALPHA");
    }
    return args;
  };
  var pushSlotRangeArguments = function(args, range) {
    args.push(range.start.toString(), range.end.toString());
  };
  var pushSlotRangesArguments = function(args, ranges) {
    if (Array.isArray(ranges)) {
      for (const range of ranges) {
        pushSlotRangeArguments(args, range);
      }
    } else {
      pushSlotRangeArguments(args, ranges);
    }
    return args;
  };
  var transformRangeReply = function([start, end]) {
    return {
      start,
      end
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRangeReply = exports.pushSlotRangesArguments = exports.pushSortArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.pushOptionalVerdictArgument = exports.pushVerdictArgument = exports.pushVerdictNumberArguments = exports.pushVerdictArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformGeoMembersWithReply = exports.GeoReplyWith = exports.pushGeoRadiusStoreArguments = exports.pushGeoRadiusArguments = exports.pushGeoSearchArguments = exports.pushGeoCountArgument = exports.transformLMPopArguments = exports.transformZMPopArguments = exports.transformSortedSetWithScoresReply = exports.transformSortedSetMemberReply = exports.transformSortedSetMemberNullReply = exports.transformStreamsMessagesReply = exports.transformStreamMessagesNullReply = exports.transformStreamMessagesReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.transformTuplesReply = exports.transformStringNumberInfinityArgument = exports.transformNumberInfinityArgument = exports.transformNumberInfinityNullArrayReply = exports.transformNumberInfinityNullReply = exports.transformNumberInfinityReply = exports.pushScanArguments = exports.transformBooleanArrayReply = exports.transformBooleanReply = undefined;
  exports.transformBooleanReply = transformBooleanReply;
  exports.transformBooleanArrayReply = transformBooleanArrayReply;
  exports.pushScanArguments = pushScanArguments;
  exports.transformNumberInfinityReply = transformNumberInfinityReply;
  exports.transformNumberInfinityNullReply = transformNumberInfinityNullReply;
  exports.transformNumberInfinityNullArrayReply = transformNumberInfinityNullArrayReply;
  exports.transformNumberInfinityArgument = transformNumberInfinityArgument;
  exports.transformStringNumberInfinityArgument = transformStringNumberInfinityArgument;
  exports.transformTuplesReply = transformTuplesReply;
  exports.transformStreamMessageReply = transformStreamMessageReply;
  exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
  exports.transformStreamMessagesReply = transformStreamMessagesReply;
  exports.transformStreamMessagesNullReply = transformStreamMessagesNullReply;
  exports.transformStreamsMessagesReply = transformStreamsMessagesReply;
  exports.transformSortedSetMemberNullReply = transformSortedSetMemberNullReply;
  exports.transformSortedSetMemberReply = transformSortedSetMemberReply;
  exports.transformSortedSetWithScoresReply = transformSortedSetWithScoresReply;
  exports.transformZMPopArguments = transformZMPopArguments;
  exports.transformLMPopArguments = transformLMPopArguments;
  exports.pushGeoCountArgument = pushGeoCountArgument;
  exports.pushGeoSearchArguments = pushGeoSearchArguments;
  exports.pushGeoRadiusArguments = pushGeoRadiusArguments;
  exports.pushGeoRadiusStoreArguments = pushGeoRadiusStoreArguments;
  var GeoReplyWith;
  (function(GeoReplyWith2) {
    GeoReplyWith2["DISTANCE"] = "WITHDIST";
    GeoReplyWith2["HASH"] = "WITHHASH";
    GeoReplyWith2["COORDINATES"] = "WITHCOORD";
  })(GeoReplyWith || (exports.GeoReplyWith = GeoReplyWith = {}));
  exports.transformGeoMembersWithReply = transformGeoMembersWithReply;
  exports.transformEXAT = transformEXAT;
  exports.transformPXAT = transformPXAT;
  exports.evalFirstKeyIndex = evalFirstKeyIndex;
  exports.pushEvalArguments = pushEvalArguments;
  exports.pushVerdictArguments = pushVerdictArguments;
  exports.pushVerdictNumberArguments = pushVerdictNumberArguments;
  exports.pushVerdictArgument = pushVerdictArgument;
  exports.pushOptionalVerdictArgument = pushOptionalVerdictArgument;
  var CommandFlags;
  (function(CommandFlags2) {
    CommandFlags2["WRITE"] = "write";
    CommandFlags2["READONLY"] = "readonly";
    CommandFlags2["DENYOOM"] = "denyoom";
    CommandFlags2["ADMIN"] = "admin";
    CommandFlags2["PUBSUB"] = "pubsub";
    CommandFlags2["NOSCRIPT"] = "noscript";
    CommandFlags2["RANDOM"] = "random";
    CommandFlags2["SORT_FOR_SCRIPT"] = "sort_for_script";
    CommandFlags2["LOADING"] = "loading";
    CommandFlags2["STALE"] = "stale";
    CommandFlags2["SKIP_MONITOR"] = "skip_monitor";
    CommandFlags2["ASKING"] = "asking";
    CommandFlags2["FAST"] = "fast";
    CommandFlags2["MOVABLEKEYS"] = "movablekeys";
  })(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
  var CommandCategories;
  (function(CommandCategories2) {
    CommandCategories2["KEYSPACE"] = "@keyspace";
    CommandCategories2["READ"] = "@read";
    CommandCategories2["WRITE"] = "@write";
    CommandCategories2["SET"] = "@set";
    CommandCategories2["SORTEDSET"] = "@sortedset";
    CommandCategories2["LIST"] = "@list";
    CommandCategories2["HASH"] = "@hash";
    CommandCategories2["STRING"] = "@string";
    CommandCategories2["BITMAP"] = "@bitmap";
    CommandCategories2["HYPERLOGLOG"] = "@hyperloglog";
    CommandCategories2["GEO"] = "@geo";
    CommandCategories2["STREAM"] = "@stream";
    CommandCategories2["PUBSUB"] = "@pubsub";
    CommandCategories2["ADMIN"] = "@admin";
    CommandCategories2["FAST"] = "@fast";
    CommandCategories2["SLOW"] = "@slow";
    CommandCategories2["BLOCKING"] = "@blocking";
    CommandCategories2["DANGEROUS"] = "@dangerous";
    CommandCategories2["CONNECTION"] = "@connection";
    CommandCategories2["TRANSACTION"] = "@transaction";
    CommandCategories2["SCRIPTING"] = "@scripting";
  })(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
  exports.transformCommandReply = transformCommandReply;
  var RedisFunctionFlags;
  (function(RedisFunctionFlags2) {
    RedisFunctionFlags2["NO_WRITES"] = "no-writes";
    RedisFunctionFlags2["ALLOW_OOM"] = "allow-oom";
    RedisFunctionFlags2["ALLOW_STALE"] = "allow-stale";
    RedisFunctionFlags2["NO_CLUSTER"] = "no-cluster";
  })(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
  exports.transformFunctionListItemReply = transformFunctionListItemReply;
  exports.pushSortArguments = pushSortArguments;
  exports.pushSlotRangesArguments = pushSlotRangesArguments;
  exports.transformRangeReply = transformRangeReply;
});

// node_modules/@redis/client/dist/lib/commands/BITOP.js
var require_BITOP = __commonJS((exports) => {
  var transformArguments = function(operation, destKey, key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["BITOP", operation, destKey], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITPOS.js
var require_BITPOS = __commonJS((exports) => {
  var transformArguments = function(key, bit, start, end, mode) {
    const args = ["BITPOS", key, bit.toString()];
    if (typeof start === "number") {
      args.push(start.toString());
    }
    if (typeof end === "number") {
      args.push(end.toString());
    }
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BLMOVE.js
var require_BLMOVE = __commonJS((exports) => {
  var transformArguments = function(source, destination, sourceDirection, destinationDirection, timeout) {
    return [
      "BLMOVE",
      source,
      destination,
      sourceDirection,
      destinationDirection,
      timeout.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LMPOP.js
var require_LMPOP = __commonJS((exports) => {
  var transformArguments = function(keys, side, options) {
    return (0, generic_transformers_1.transformLMPopArguments)(["LMPOP"], keys, side, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BLMPOP.js
var require_BLMPOP = __commonJS((exports) => {
  var transformArguments = function(timeout, keys, side, options) {
    return (0, generic_transformers_1.transformLMPopArguments)(["BLMPOP", timeout.toString()], keys, side, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 3;
  exports.transformArguments = transformArguments;
  var LMPOP_1 = require_LMPOP();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return LMPOP_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/BLPOP.js
var require_BLPOP = __commonJS((exports) => {
  var transformArguments = function(keys, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BLPOP"], keys);
    args.push(timeout.toString());
    return args;
  };
  var transformReply = function(reply) {
    if (reply === null)
      return null;
    return {
      key: reply[0],
      element: reply[1]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/BRPOP.js
var require_BRPOP = __commonJS((exports) => {
  var transformArguments = function(key, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BRPOP"], key);
    args.push(timeout.toString());
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var BLPOP_1 = require_BLPOP();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return BLPOP_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/BRPOPLPUSH.js
var require_BRPOPLPUSH = __commonJS((exports) => {
  var transformArguments = function(source, destination, timeout) {
    return ["BRPOPLPUSH", source, destination, timeout.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZMPOP.js
var require_ZMPOP = __commonJS((exports) => {
  var transformArguments = function(keys, side, options) {
    return (0, generic_transformers_1.transformZMPopArguments)(["ZMPOP"], keys, side, options);
  };
  var transformReply = function(reply) {
    return reply === null ? null : {
      key: reply[0],
      elements: reply[1].map(generic_transformers_1.transformSortedSetMemberReply)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/BZMPOP.js
var require_BZMPOP = __commonJS((exports) => {
  var transformArguments = function(timeout, keys, side, options) {
    return (0, generic_transformers_1.transformZMPopArguments)(["BZMPOP", timeout.toString()], keys, side, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 3;
  exports.transformArguments = transformArguments;
  var ZMPOP_1 = require_ZMPOP();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return ZMPOP_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMAX.js
var require_BZPOPMAX = __commonJS((exports) => {
  var transformArguments = function(key, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BZPOPMAX"], key);
    args.push(timeout.toString());
    return args;
  };
  var transformReply = function(reply) {
    if (!reply)
      return null;
    return {
      key: reply[0],
      value: reply[1],
      score: (0, generic_transformers_1.transformNumberInfinityReply)(reply[2])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMIN.js
var require_BZPOPMIN = __commonJS((exports) => {
  var transformArguments = function(key, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BZPOPMIN"], key);
    args.push(timeout.toString());
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var BZPOPMAX_1 = require_BZPOPMAX();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return BZPOPMAX_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/COPY.js
var require_COPY = __commonJS((exports) => {
  var transformArguments = function(source, destination, options) {
    const args = ["COPY", source, destination];
    if (options?.destinationDb) {
      args.push("DB", options.destinationDb.toString());
    }
    if (options?.replace) {
      args.push("REPLACE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/DECR.js
var require_DECR = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["DECR", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DECRBY.js
var require_DECRBY = __commonJS((exports) => {
  var transformArguments = function(key, decrement) {
    return ["DECRBY", key, decrement.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DEL.js
var require_DEL = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["DEL"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DUMP.js
var require_DUMP = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["DUMP", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVAL_RO.js
var require_EVAL_RO = __commonJS((exports) => {
  var transformArguments = function(script, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVAL_RO", script], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVAL.js
var require_EVAL = __commonJS((exports) => {
  var transformArguments = function(script, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVAL", script], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA_RO.js
var require_EVALSHA_RO = __commonJS((exports) => {
  var transformArguments = function(sha1, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVALSHA_RO", sha1], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA.js
var require_EVALSHA = __commonJS((exports) => {
  var transformArguments = function(sha1, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVALSHA", sha1], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EXISTS.js
var require_EXISTS = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["EXISTS"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EXPIRE.js
var require_EXPIRE = __commonJS((exports) => {
  var transformArguments = function(key, seconds, mode) {
    const args = ["EXPIRE", key, seconds.toString()];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/EXPIREAT.js
var require_EXPIREAT = __commonJS((exports) => {
  var transformArguments = function(key, timestamp, mode) {
    const args = [
      "EXPIREAT",
      key,
      (0, generic_transformers_1.transformEXAT)(timestamp)
    ];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/EXPIRETIME.js
var require_EXPIRETIME = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["EXPIRETIME", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FCALL_RO.js
var require_FCALL_RO = __commonJS((exports) => {
  var transformArguments = function(fn, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["FCALL_RO", fn], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FCALL.js
var require_FCALL = __commonJS((exports) => {
  var transformArguments = function(fn, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["FCALL", fn], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOADD.js
var require_GEOADD = __commonJS((exports) => {
  var transformArguments = function(key, toAdd, options) {
    const args = ["GEOADD", key];
    if (options?.NX) {
      args.push("NX");
    } else if (options?.XX) {
      args.push("XX");
    }
    if (options?.CH) {
      args.push("CH");
    }
    for (const { longitude, latitude, member } of Array.isArray(toAdd) ? toAdd : [toAdd]) {
      args.push(longitude.toString(), latitude.toString(), member);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEODIST.js
var require_GEODIST = __commonJS((exports) => {
  var transformArguments = function(key, member1, member2, unit) {
    const args = ["GEODIST", key, member1, member2];
    if (unit) {
      args.push(unit);
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply === null ? null : Number(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/GEOHASH.js
var require_GEOHASH = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["GEOHASH", key], member);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOPOS.js
var require_GEOPOS = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["GEOPOS", key], member);
  };
  var transformReply = function(reply) {
    return reply.map((coordinates) => coordinates === null ? null : {
      longitude: coordinates[0],
      latitude: coordinates[1]
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO.js
var require_GEORADIUS_RO = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUS_RO"], key, coordinates, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO_WITH.js
var require_GEORADIUS_RO_WITH = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, replyWith, options) {
    const args = (0, GEORADIUS_RO_1.transformArguments)(key, coordinates, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUS_RO_1 = require_GEORADIUS_RO();
  var GEORADIUS_RO_2 = require_GEORADIUS_RO();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUS_RO_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUS_RO_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS.js
var require_GEORADIUS = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUS"], key, coordinates, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_WITH.js
var require_GEORADIUS_WITH = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, replyWith, options) {
    const args = (0, GEORADIUS_1.transformArguments)(key, coordinates, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUS_1 = require_GEORADIUS();
  var GEORADIUS_2 = require_GEORADIUS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO.js
var require_GEORADIUSBYMEMBER_RO = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUSBYMEMBER_RO"], key, member, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO_WITH.js
var require_GEORADIUSBYMEMBER_RO_WITH = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, replyWith, options) {
    const args = (0, GEORADIUSBYMEMBER_RO_1.transformArguments)(key, member, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUSBYMEMBER_RO_1 = require_GEORADIUSBYMEMBER_RO();
  var GEORADIUSBYMEMBER_RO_2 = require_GEORADIUSBYMEMBER_RO();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_RO_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_RO_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER.js
var require_GEORADIUSBYMEMBER = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUSBYMEMBER"], key, member, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_WITH.js
var require_GEORADIUSBYMEMBER_WITH = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, replyWith, options) {
    const args = (0, GEORADIUSBYMEMBER_1.transformArguments)(key, member, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUSBYMEMBER_1 = require_GEORADIUSBYMEMBER();
  var GEORADIUSBYMEMBER_2 = require_GEORADIUSBYMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBERSTORE.js
var require_GEORADIUSBYMEMBERSTORE = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, destination, options) {
    return (0, generic_transformers_1.pushGeoRadiusStoreArguments)(["GEORADIUSBYMEMBER"], key, member, radius, unit, destination, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var GEORADIUSBYMEMBER_1 = require_GEORADIUSBYMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSSTORE.js
var require_GEORADIUSSTORE = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, destination, options) {
    return (0, generic_transformers_1.pushGeoRadiusStoreArguments)(["GEORADIUS"], key, coordinates, radius, unit, destination, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var GEORADIUS_1 = require_GEORADIUS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUS_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUS_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH.js
var require_GEOSEARCH = __commonJS((exports) => {
  var transformArguments = function(key, from, by, options) {
    return (0, generic_transformers_1.pushGeoSearchArguments)(["GEOSEARCH"], key, from, by, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH_WITH.js
var require_GEOSEARCH_WITH = __commonJS((exports) => {
  var transformArguments = function(key, from, by, replyWith, options) {
    const args = (0, GEOSEARCH_1.transformArguments)(key, from, by, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  var GEOSEARCH_2 = require_GEOSEARCH();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEOSEARCH_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEOSEARCH_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCHSTORE.js
var require_GEOSEARCHSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, source, from, by, options) {
    const args = (0, generic_transformers_1.pushGeoSearchArguments)(["GEOSEARCHSTORE", destination], source, from, by, options);
    if (options?.STOREDIST) {
      args.push("STOREDIST");
    }
    return args;
  };
  var transformReply = function(reply) {
    if (typeof reply !== "number") {
      throw new TypeError(`https://github.com/redis/redis/issues/9261`);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var GEOSEARCH_1 = require_GEOSEARCH();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEOSEARCH_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEOSEARCH_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/GET.js
var require_GET = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GET", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETBIT.js
var require_GETBIT = __commonJS((exports) => {
  var transformArguments = function(key, offset) {
    return ["GETBIT", key, offset.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETDEL.js
var require_GETDEL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GETDEL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETEX.js
var require_GETEX = __commonJS((exports) => {
  var transformArguments = function(key, mode) {
    const args = ["GETEX", key];
    if ("EX" in mode) {
      args.push("EX", mode.EX.toString());
    } else if ("PX" in mode) {
      args.push("PX", mode.PX.toString());
    } else if ("EXAT" in mode) {
      args.push("EXAT", (0, generic_transformers_1.transformEXAT)(mode.EXAT));
    } else if ("PXAT" in mode) {
      args.push("PXAT", (0, generic_transformers_1.transformPXAT)(mode.PXAT));
    } else {
      args.push("PERSIST");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETRANGE.js
var require_GETRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, end) {
    return ["GETRANGE", key, start.toString(), end.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETSET.js
var require_GETSET = __commonJS((exports) => {
  var transformArguments = function(key, value26) {
    return ["GETSET", key, value26];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HDEL.js
var require_HDEL = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return (0, generic_transformers_1.pushVerdictArguments)(["HDEL", key], field);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HEXISTS.js
var require_HEXISTS = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return ["HEXISTS", key, field];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HEXPIRE.js
var require_HEXPIRE = __commonJS((exports) => {
  var transformArguments = function(key, fields, seconds, mode) {
    const args = ["HEXPIRE", key, seconds.toString()];
    if (mode) {
      args.push(mode);
    }
    args.push("FIELDS");
    return (0, generic_transformers_1.pushVerdictArgument)(args, fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = exports.HASH_EXPIRATION = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.HASH_EXPIRATION = {
    FIELD_NOT_EXISTS: -2,
    CONDITION_NOT_MET: 0,
    UPDATED: 1,
    DELETED: 2
  };
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HEXPIREAT.js
var require_HEXPIREAT = __commonJS((exports) => {
  var transformArguments = function(key, fields, timestamp, mode) {
    const args = [
      "HEXPIREAT",
      key,
      (0, generic_transformers_1.transformEXAT)(timestamp)
    ];
    if (mode) {
      args.push(mode);
    }
    args.push("FIELDS");
    return (0, generic_transformers_1.pushVerdictArgument)(args, fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HEXPIRETIME.js
var require_HEXPIRETIME = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArgument)(["HEXPIRETIME", key, "FIELDS"], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = exports.HASH_EXPIRATION_TIME = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.HASH_EXPIRATION_TIME = {
    FIELD_NOT_EXISTS: -2,
    NO_EXPIRATION: -1
  };
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HGET.js
var require_HGET = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return ["HGET", key, field];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HGETALL.js
var require_HGETALL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HGETALL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.TRANSFORM_LEGACY_REPLY = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.TRANSFORM_LEGACY_REPLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformTuplesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HINCRBY.js
var require_HINCRBY = __commonJS((exports) => {
  var transformArguments = function(key, field, increment) {
    return ["HINCRBY", key, field, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HINCRBYFLOAT.js
var require_HINCRBYFLOAT = __commonJS((exports) => {
  var transformArguments = function(key, field, increment) {
    return ["HINCRBYFLOAT", key, field, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HKEYS.js
var require_HKEYS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HKEYS", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HLEN.js
var require_HLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HMGET.js
var require_HMGET = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArguments)(["HMGET", key], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HPERSIST.js
var require_HPERSIST = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArgument)(["HPERSIST", key, "FIELDS"], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIRE.js
var require_HPEXPIRE = __commonJS((exports) => {
  var transformArguments = function(key, fields, ms, mode) {
    const args = ["HPEXPIRE", key, ms.toString()];
    if (mode) {
      args.push(mode);
    }
    args.push("FIELDS");
    return (0, generic_transformers_1.pushVerdictArgument)(args, fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIREAT.js
var require_HPEXPIREAT = __commonJS((exports) => {
  var transformArguments = function(key, fields, timestamp, mode) {
    const args = ["HPEXPIREAT", key, (0, generic_transformers_1.transformPXAT)(timestamp)];
    if (mode) {
      args.push(mode);
    }
    args.push("FIELDS");
    return (0, generic_transformers_1.pushVerdictArgument)(args, fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIRETIME.js
var require_HPEXPIRETIME = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArgument)(["HPEXPIRETIME", key, "FIELDS"], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HPTTL.js
var require_HPTTL = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArgument)(["HPTTL", key, "FIELDS"], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD.js
var require_HRANDFIELD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HRANDFIELD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT.js
var require_HRANDFIELD_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, HRANDFIELD_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var HRANDFIELD_1 = require_HRANDFIELD();
  var HRANDFIELD_2 = require_HRANDFIELD();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return HRANDFIELD_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return HRANDFIELD_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT_WITHVALUES.js
var require_HRANDFIELD_COUNT_WITHVALUES = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, HRANDFIELD_COUNT_1.transformArguments)(key, count),
      "WITHVALUES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var HRANDFIELD_COUNT_1 = require_HRANDFIELD_COUNT();
  var HRANDFIELD_COUNT_2 = require_HRANDFIELD_COUNT();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return HRANDFIELD_COUNT_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return HRANDFIELD_COUNT_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformTuplesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HSCAN.js
var require_HSCAN = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    return (0, generic_transformers_1.pushScanArguments)([
      "HSCAN",
      key
    ], cursor, options);
  };
  var transformReply = function([cursor, rawTuples]) {
    const parsedTuples = [];
    for (let i = 0;i < rawTuples.length; i += 2) {
      parsedTuples.push({
        field: rawTuples[i],
        value: rawTuples[i + 1]
      });
    }
    return {
      cursor: Number(cursor),
      tuples: parsedTuples
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/HSCAN_NOVALUES.js
var require_HSCAN_NOVALUES = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    const args = (0, HSCAN_1.transformArguments)(key, cursor, options);
    args.push("NOVALUES");
    return args;
  };
  var transformReply = function([cursor, rawData]) {
    return {
      cursor: Number(cursor),
      keys: rawData
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var HSCAN_1 = require_HSCAN();
  var HSCAN_2 = require_HSCAN();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return HSCAN_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return HSCAN_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/HSET.js
var require_HSET = __commonJS((exports) => {
  var transformArguments = function(...[key, value26, fieldValue]) {
    const args = ["HSET", key];
    if (typeof value26 === "string" || typeof value26 === "number" || Buffer.isBuffer(value26)) {
      args.push(convertValue(value26), convertValue(fieldValue));
    } else if (value26 instanceof Map) {
      pushMap(args, value26);
    } else if (Array.isArray(value26)) {
      pushTuples(args, value26);
    } else {
      pushObject(args, value26);
    }
    return args;
  };
  var pushMap = function(args, map3) {
    for (const [key, value26] of map3.entries()) {
      args.push(convertValue(key), convertValue(value26));
    }
  };
  var pushTuples = function(args, tuples) {
    for (const tuple6 of tuples) {
      if (Array.isArray(tuple6)) {
        pushTuples(args, tuple6);
        continue;
      }
      args.push(convertValue(tuple6));
    }
  };
  var pushObject = function(args, object12) {
    for (const key of Object.keys(object12)) {
      args.push(convertValue(key), convertValue(object12[key]));
    }
  };
  var convertValue = function(value26) {
    return typeof value26 === "number" ? value26.toString() : value26;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HSETNX.js
var require_HSETNX = __commonJS((exports) => {
  var transformArguments = function(key, field, value26) {
    return ["HSETNX", key, field, value26];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HSTRLEN.js
var require_HSTRLEN = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return ["HSTRLEN", key, field];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HTTL.js
var require_HTTL = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArgument)(["HTTL", key, "FIELDS"], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HVALS.js
var require_HVALS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HVALS", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/INCR.js
var require_INCR = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["INCR", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/INCRBY.js
var require_INCRBY = __commonJS((exports) => {
  var transformArguments = function(key, increment) {
    return ["INCRBY", key, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/INCRBYFLOAT.js
var require_INCRBYFLOAT = __commonJS((exports) => {
  var transformArguments = function(key, increment) {
    return ["INCRBYFLOAT", key, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LCS.js
var require_LCS = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    return [
      "LCS",
      key1,
      key2
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX_WITHMATCHLEN.js
var require_LCS_IDX_WITHMATCHLEN = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    const args = (0, LCS_1.transformArguments)(key1, key2);
    args.push("IDX", "WITHMATCHLEN");
    return args;
  };
  var transformReply = function(reply) {
    return {
      matches: reply[1].map(([key1, key2, length]) => ({
        key1: (0, generic_transformers_1.transformRangeReply)(key1),
        key2: (0, generic_transformers_1.transformRangeReply)(key2),
        length
      })),
      length: reply[3]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var LCS_1 = require_LCS();
  var LCS_2 = require_LCS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LCS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LCS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX.js
var require_LCS_IDX = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    const args = (0, LCS_1.transformArguments)(key1, key2);
    args.push("IDX");
    return args;
  };
  var transformReply = function(reply) {
    return {
      matches: reply[1].map(([key1, key2]) => ({
        key1: (0, generic_transformers_1.transformRangeReply)(key1),
        key2: (0, generic_transformers_1.transformRangeReply)(key2)
      })),
      length: reply[3]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var LCS_1 = require_LCS();
  var LCS_2 = require_LCS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LCS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LCS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/LCS_LEN.js
var require_LCS_LEN = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    const args = (0, LCS_1.transformArguments)(key1, key2);
    args.push("LEN");
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var LCS_1 = require_LCS();
  var LCS_2 = require_LCS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LCS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LCS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LINDEX.js
var require_LINDEX = __commonJS((exports) => {
  var transformArguments = function(key, index) {
    return ["LINDEX", key, index.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LINSERT.js
var require_LINSERT = __commonJS((exports) => {
  var transformArguments = function(key, position, pivot, element) {
    return [
      "LINSERT",
      key,
      position,
      pivot,
      element
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LLEN.js
var require_LLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["LLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LMOVE.js
var require_LMOVE = __commonJS((exports) => {
  var transformArguments = function(source, destination, sourceSide, destinationSide) {
    return [
      "LMOVE",
      source,
      destination,
      sourceSide,
      destinationSide
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOP_COUNT.js
var require_LPOP_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return ["LPOP", key, count.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOP.js
var require_LPOP = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["LPOP", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOS.js
var require_LPOS = __commonJS((exports) => {
  var transformArguments = function(key, element, options) {
    const args = ["LPOS", key, element];
    if (typeof options?.RANK === "number") {
      args.push("RANK", options.RANK.toString());
    }
    if (typeof options?.MAXLEN === "number") {
      args.push("MAXLEN", options.MAXLEN.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOS_COUNT.js
var require_LPOS_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, element, count, options) {
    const args = ["LPOS", key, element];
    if (typeof options?.RANK === "number") {
      args.push("RANK", options.RANK.toString());
    }
    args.push("COUNT", count.toString());
    if (typeof options?.MAXLEN === "number") {
      args.push("MAXLEN", options.MAXLEN.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var LPOS_1 = require_LPOS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LPOS_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LPOS_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPUSH.js
var require_LPUSH = __commonJS((exports) => {
  var transformArguments = function(key, elements) {
    return (0, generic_transformers_1.pushVerdictArguments)(["LPUSH", key], elements);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPUSHX.js
var require_LPUSHX = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["LPUSHX", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LRANGE.js
var require_LRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, stop) {
    return [
      "LRANGE",
      key,
      start.toString(),
      stop.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LREM.js
var require_LREM = __commonJS((exports) => {
  var transformArguments = function(key, count, element) {
    return [
      "LREM",
      key,
      count.toString(),
      element
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LSET.js
var require_LSET = __commonJS((exports) => {
  var transformArguments = function(key, index, element) {
    return [
      "LSET",
      key,
      index.toString(),
      element
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LTRIM.js
var require_LTRIM = __commonJS((exports) => {
  var transformArguments = function(key, start, stop) {
    return [
      "LTRIM",
      key,
      start.toString(),
      stop.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MGET.js
var require_MGET = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return ["MGET", ...keys];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MIGRATE.js
var require_MIGRATE = __commonJS((exports) => {
  var transformArguments = function(host, port, key, destinationDb, timeout, options) {
    const args = ["MIGRATE", host, port.toString()], isKeyArray = Array.isArray(key);
    if (isKeyArray) {
      args.push("");
    } else {
      args.push(key);
    }
    args.push(destinationDb.toString(), timeout.toString());
    if (options?.COPY) {
      args.push("COPY");
    }
    if (options?.REPLACE) {
      args.push("REPLACE");
    }
    if (options?.AUTH) {
      if (options.AUTH.username) {
        args.push("AUTH2", options.AUTH.username, options.AUTH.password);
      } else {
        args.push("AUTH", options.AUTH.password);
      }
    }
    if (isKeyArray) {
      args.push("KEYS", ...key);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MSET.js
var require_MSET = __commonJS((exports) => {
  var transformArguments = function(toSet) {
    const args = ["MSET"];
    if (Array.isArray(toSet)) {
      args.push(...toSet.flat());
    } else {
      for (const key of Object.keys(toSet)) {
        args.push(key, toSet[key]);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MSETNX.js
var require_MSETNX = __commonJS((exports) => {
  var transformArguments = function(toSet) {
    const args = ["MSETNX"];
    if (Array.isArray(toSet)) {
      args.push(...toSet.flat());
    } else {
      for (const key of Object.keys(toSet)) {
        args.push(key, toSet[key]);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_ENCODING.js
var require_OBJECT_ENCODING = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "ENCODING", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_FREQ.js
var require_OBJECT_FREQ = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "FREQ", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_IDLETIME.js
var require_OBJECT_IDLETIME = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "IDLETIME", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_REFCOUNT.js
var require_OBJECT_REFCOUNT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "REFCOUNT", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PERSIST.js
var require_PERSIST = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["PERSIST", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRE.js
var require_PEXPIRE = __commonJS((exports) => {
  var transformArguments = function(key, milliseconds, mode) {
    const args = ["PEXPIRE", key, milliseconds.toString()];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PEXPIREAT.js
var require_PEXPIREAT = __commonJS((exports) => {
  var transformArguments = function(key, millisecondsTimestamp, mode) {
    const args = [
      "PEXPIREAT",
      key,
      (0, generic_transformers_1.transformPXAT)(millisecondsTimestamp)
    ];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRETIME.js
var require_PEXPIRETIME = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["PEXPIRETIME", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PFADD.js
var require_PFADD = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["PFADD", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PFCOUNT.js
var require_PFCOUNT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["PFCOUNT"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PFMERGE.js
var require_PFMERGE = __commonJS((exports) => {
  var transformArguments = function(destination, source) {
    return (0, generic_transformers_1.pushVerdictArguments)(["PFMERGE", destination], source);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PSETEX.js
var require_PSETEX = __commonJS((exports) => {
  var transformArguments = function(key, milliseconds, value26) {
    return [
      "PSETEX",
      key,
      milliseconds.toString(),
      value26
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PTTL.js
var require_PTTL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["PTTL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBLISH.js
var require_PUBLISH = __commonJS((exports) => {
  var transformArguments = function(channel, message) {
    return ["PUBLISH", channel, message];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RENAME.js
var require_RENAME = __commonJS((exports) => {
  var transformArguments = function(key, newKey) {
    return ["RENAME", key, newKey];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RENAMENX.js
var require_RENAMENX = __commonJS((exports) => {
  var transformArguments = function(key, newKey) {
    return ["RENAMENX", key, newKey];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/RESTORE.js
var require_RESTORE = __commonJS((exports) => {
  var transformArguments = function(key, ttl, serializedValue, options) {
    const args = ["RESTORE", key, ttl.toString(), serializedValue];
    if (options?.REPLACE) {
      args.push("REPLACE");
    }
    if (options?.ABSTTL) {
      args.push("ABSTTL");
    }
    if (options?.IDLETIME) {
      args.push("IDLETIME", options.IDLETIME.toString());
    }
    if (options?.FREQ) {
      args.push("FREQ", options.FREQ.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPOP_COUNT.js
var require_RPOP_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return ["RPOP", key, count.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPOP.js
var require_RPOP = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["RPOP", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPOPLPUSH.js
var require_RPOPLPUSH = __commonJS((exports) => {
  var transformArguments = function(source, destination) {
    return ["RPOPLPUSH", source, destination];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPUSH.js
var require_RPUSH = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["RPUSH", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPUSHX.js
var require_RPUSHX = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["RPUSHX", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SADD.js
var require_SADD = __commonJS((exports) => {
  var transformArguments = function(key, members) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SADD", key], members);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCARD.js
var require_SCARD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["SCARD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SDIFF.js
var require_SDIFF = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SDIFF"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SDIFFSTORE.js
var require_SDIFFSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SDIFFSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SET.js
var require_SET = __commonJS((exports) => {
  var transformArguments = function(key, value26, options) {
    const args = [
      "SET",
      key,
      typeof value26 === "number" ? value26.toString() : value26
    ];
    if (options?.EX !== undefined) {
      args.push("EX", options.EX.toString());
    } else if (options?.PX !== undefined) {
      args.push("PX", options.PX.toString());
    } else if (options?.EXAT !== undefined) {
      args.push("EXAT", options.EXAT.toString());
    } else if (options?.PXAT !== undefined) {
      args.push("PXAT", options.PXAT.toString());
    } else if (options?.KEEPTTL) {
      args.push("KEEPTTL");
    }
    if (options?.NX) {
      args.push("NX");
    } else if (options?.XX) {
      args.push("XX");
    }
    if (options?.GET) {
      args.push("GET");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SETBIT.js
var require_SETBIT = __commonJS((exports) => {
  var transformArguments = function(key, offset, value26) {
    return ["SETBIT", key, offset.toString(), value26.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SETEX.js
var require_SETEX = __commonJS((exports) => {
  var transformArguments = function(key, seconds, value26) {
    return [
      "SETEX",
      key,
      seconds.toString(),
      value26
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SETNX.js
var require_SETNX = __commonJS((exports) => {
  var transformArguments = function(key, value26) {
    return ["SETNX", key, value26];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SETRANGE.js
var require_SETRANGE = __commonJS((exports) => {
  var transformArguments = function(key, offset, value26) {
    return ["SETRANGE", key, offset.toString(), value26];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SINTER.js
var require_SINTER = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SINTER"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SINTERCARD.js
var require_SINTERCARD = __commonJS((exports) => {
  var transformArguments = function(keys, limit) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["SINTERCARD"], keys);
    if (limit) {
      args.push("LIMIT", limit.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SINTERSTORE.js
var require_SINTERSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SINTERSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SISMEMBER.js
var require_SISMEMBER = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["SISMEMBER", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SMEMBERS.js
var require_SMEMBERS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["SMEMBERS", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SMISMEMBER.js
var require_SMISMEMBER = __commonJS((exports) => {
  var transformArguments = function(key, members) {
    return ["SMISMEMBER", key, ...members];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SMOVE.js
var require_SMOVE = __commonJS((exports) => {
  var transformArguments = function(source, destination, member) {
    return ["SMOVE", source, destination, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SORT_RO.js
var require_SORT_RO = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, generic_transformers_1.pushSortArguments)(["SORT_RO", key], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SORT.js
var require_SORT = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, generic_transformers_1.pushSortArguments)(["SORT", key], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SORT_STORE.js
var require_SORT_STORE = __commonJS((exports) => {
  var transformArguments = function(source, destination, options) {
    const args = (0, SORT_1.transformArguments)(source, options);
    args.push("STORE", destination);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var SORT_1 = require_SORT();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SPOP.js
var require_SPOP = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    const args = ["SPOP", key];
    if (typeof count === "number") {
      args.push(count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SPUBLISH.js
var require_SPUBLISH = __commonJS((exports) => {
  var transformArguments = function(channel, message) {
    return ["SPUBLISH", channel, message];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER.js
var require_SRANDMEMBER = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["SRANDMEMBER", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER_COUNT.js
var require_SRANDMEMBER_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, SRANDMEMBER_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var SRANDMEMBER_1 = require_SRANDMEMBER();
  var SRANDMEMBER_2 = require_SRANDMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return SRANDMEMBER_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SREM.js
var require_SREM = __commonJS((exports) => {
  var transformArguments = function(key, members) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SREM", key], members);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SSCAN.js
var require_SSCAN = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    return (0, generic_transformers_1.pushScanArguments)([
      "SSCAN",
      key
    ], cursor, options);
  };
  var transformReply = function([cursor, members]) {
    return {
      cursor: Number(cursor),
      members
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/STRLEN.js
var require_STRLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["STRLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SUNION.js
var require_SUNION = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SUNION"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SUNIONSTORE.js
var require_SUNIONSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SUNIONSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TOUCH.js
var require_TOUCH = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOUCH"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TTL.js
var require_TTL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TTL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TYPE.js
var require_TYPE = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TYPE", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/UNLINK.js
var require_UNLINK = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["UNLINK"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/WATCH.js
var require_WATCH = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["WATCH"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XACK.js
var require_XACK = __commonJS((exports) => {
  var transformArguments = function(key, group, id) {
    return (0, generic_transformers_1.pushVerdictArguments)(["XACK", key, group], id);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XADD.js
var require_XADD = __commonJS((exports) => {
  var transformArguments = function(key, id, message, options) {
    const args = ["XADD", key];
    if (options?.NOMKSTREAM) {
      args.push("NOMKSTREAM");
    }
    if (options?.TRIM) {
      if (options.TRIM.strategy) {
        args.push(options.TRIM.strategy);
      }
      if (options.TRIM.strategyModifier) {
        args.push(options.TRIM.strategyModifier);
      }
      args.push(options.TRIM.threshold.toString());
      if (options.TRIM.limit) {
        args.push("LIMIT", options.TRIM.limit.toString());
      }
    }
    args.push(id);
    for (const [key2, value26] of Object.entries(message)) {
      args.push(key2, value26);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM.js
var require_XAUTOCLAIM = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer, minIdleTime, start, options) {
    const args = ["XAUTOCLAIM", key, group, consumer, minIdleTime.toString(), start];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformReply = function(reply) {
    return {
      nextId: reply[0],
      messages: (0, generic_transformers_1.transformStreamMessagesNullReply)(reply[1])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM_JUSTID.js
var require_XAUTOCLAIM_JUSTID = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, XAUTOCLAIM_1.transformArguments)(...args),
      "JUSTID"
    ];
  };
  var transformReply = function(reply) {
    return {
      nextId: reply[0],
      messages: reply[1]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var XAUTOCLAIM_1 = require_XAUTOCLAIM();
  var XAUTOCLAIM_2 = require_XAUTOCLAIM();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return XAUTOCLAIM_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM.js
var require_XCLAIM = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer, minIdleTime, id, options) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["XCLAIM", key, group, consumer, minIdleTime.toString()], id);
    if (options?.IDLE) {
      args.push("IDLE", options.IDLE.toString());
    }
    if (options?.TIME) {
      args.push("TIME", (typeof options.TIME === "number" ? options.TIME : options.TIME.getTime()).toString());
    }
    if (options?.RETRYCOUNT) {
      args.push("RETRYCOUNT", options.RETRYCOUNT.toString());
    }
    if (options?.FORCE) {
      args.push("FORCE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformStreamMessagesNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM_JUSTID.js
var require_XCLAIM_JUSTID = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, XCLAIM_1.transformArguments)(...args),
      "JUSTID"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var XCLAIM_1 = require_XCLAIM();
  var XCLAIM_2 = require_XCLAIM();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return XCLAIM_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XDEL.js
var require_XDEL = __commonJS((exports) => {
  var transformArguments = function(key, id) {
    return (0, generic_transformers_1.pushVerdictArguments)(["XDEL", key], id);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATE.js
var require_XGROUP_CREATE = __commonJS((exports) => {
  var transformArguments = function(key, group, id, options) {
    const args = ["XGROUP", "CREATE", key, group, id];
    if (options?.MKSTREAM) {
      args.push("MKSTREAM");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATECONSUMER.js
var require_XGROUP_CREATECONSUMER = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer) {
    return ["XGROUP", "CREATECONSUMER", key, group, consumer];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DELCONSUMER.js
var require_XGROUP_DELCONSUMER = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer) {
    return ["XGROUP", "DELCONSUMER", key, group, consumer];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DESTROY.js
var require_XGROUP_DESTROY = __commonJS((exports) => {
  var transformArguments = function(key, group) {
    return ["XGROUP", "DESTROY", key, group];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_SETID.js
var require_XGROUP_SETID = __commonJS((exports) => {
  var transformArguments = function(key, group, id) {
    return ["XGROUP", "SETID", key, group, id];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XINFO_CONSUMERS.js
var require_XINFO_CONSUMERS = __commonJS((exports) => {
  var transformArguments = function(key, group) {
    return ["XINFO", "CONSUMERS", key, group];
  };
  var transformReply = function(rawReply) {
    return rawReply.map((consumer) => ({
      name: consumer[1],
      pending: consumer[3],
      idle: consumer[5],
      inactive: consumer[7]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XINFO_GROUPS.js
var require_XINFO_GROUPS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["XINFO", "GROUPS", key];
  };
  var transformReply = function(rawReply) {
    return rawReply.map((group) => ({
      name: group[1],
      consumers: group[3],
      pending: group[5],
      lastDeliveredId: group[7]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XINFO_STREAM.js
var require_XINFO_STREAM = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["XINFO", "STREAM", key];
  };
  var transformReply = function(rawReply) {
    const parsedReply = {};
    for (let i = 0;i < rawReply.length; i += 2) {
      switch (rawReply[i]) {
        case "length":
          parsedReply.length = rawReply[i + 1];
          break;
        case "radix-tree-keys":
          parsedReply.radixTreeKeys = rawReply[i + 1];
          break;
        case "radix-tree-nodes":
          parsedReply.radixTreeNodes = rawReply[i + 1];
          break;
        case "groups":
          parsedReply.groups = rawReply[i + 1];
          break;
        case "last-generated-id":
          parsedReply.lastGeneratedId = rawReply[i + 1];
          break;
        case "first-entry":
          parsedReply.firstEntry = rawReply[i + 1] ? {
            id: rawReply[i + 1][0],
            message: (0, generic_transformers_1.transformTuplesReply)(rawReply[i + 1][1])
          } : null;
          break;
        case "last-entry":
          parsedReply.lastEntry = rawReply[i + 1] ? {
            id: rawReply[i + 1][0],
            message: (0, generic_transformers_1.transformTuplesReply)(rawReply[i + 1][1])
          } : null;
          break;
      }
    }
    return parsedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XLEN.js
var require_XLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["XLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XPENDING_RANGE.js
var require_XPENDING_RANGE = __commonJS((exports) => {
  var transformArguments = function(key, group, start, end, count, options) {
    const args = ["XPENDING", key, group];
    if (options?.IDLE) {
      args.push("IDLE", options.IDLE.toString());
    }
    args.push(start, end, count.toString());
    if (options?.consumer) {
      args.push(options.consumer);
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply.map(([id, owner, millisecondsSinceLastDelivery, deliveriesCounter]) => ({
      id,
      owner,
      millisecondsSinceLastDelivery,
      deliveriesCounter
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XPENDING.js
var require_XPENDING = __commonJS((exports) => {
  var transformArguments = function(key, group) {
    return ["XPENDING", key, group];
  };
  var transformReply = function(reply) {
    return {
      pending: reply[0],
      firstId: reply[1],
      lastId: reply[2],
      consumers: reply[3] === null ? null : reply[3].map(([name, deliveriesCounter]) => ({
        name,
        deliveriesCounter: Number(deliveriesCounter)
      }))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XRANGE.js
var require_XRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, end, options) {
    const args = ["XRANGE", key, start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XREAD.js
var require_XREAD = __commonJS((exports) => {
  var transformArguments = function(streams, options) {
    const args = ["XREAD"];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    if (typeof options?.BLOCK === "number") {
      args.push("BLOCK", options.BLOCK.toString());
    }
    args.push("STREAMS");
    const streamsArray = Array.isArray(streams) ? streams : [streams], argsLength = args.length;
    for (let i = 0;i < streamsArray.length; i++) {
      const stream7 = streamsArray[i];
      args[argsLength + i] = stream7.key;
      args[argsLength + streamsArray.length + i] = stream7.id;
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var FIRST_KEY_INDEX = (streams) => {
    return Array.isArray(streams) ? streams[0].key : streams.key;
  };
  exports.FIRST_KEY_INDEX = FIRST_KEY_INDEX;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamsMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XREADGROUP.js
var require_XREADGROUP = __commonJS((exports) => {
  var transformArguments = function(group, consumer, streams, options) {
    const args = ["XREADGROUP", "GROUP", group, consumer];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    if (typeof options?.BLOCK === "number") {
      args.push("BLOCK", options.BLOCK.toString());
    }
    if (options?.NOACK) {
      args.push("NOACK");
    }
    args.push("STREAMS");
    const streamsArray = Array.isArray(streams) ? streams : [streams], argsLength = args.length;
    for (let i = 0;i < streamsArray.length; i++) {
      const stream7 = streamsArray[i];
      args[argsLength + i] = stream7.key;
      args[argsLength + streamsArray.length + i] = stream7.id;
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var FIRST_KEY_INDEX = (_group, _consumer, streams) => {
    return Array.isArray(streams) ? streams[0].key : streams.key;
  };
  exports.FIRST_KEY_INDEX = FIRST_KEY_INDEX;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamsMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XREVRANGE.js
var require_XREVRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, end, options) {
    const args = ["XREVRANGE", key, start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XSETID.js
var require_XSETID = __commonJS((exports) => {
  var transformArguments = function(key, lastId, options) {
    const args = ["XSETID", key, lastId];
    if (options?.ENTRIESADDED) {
      args.push("ENTRIESADDED", options.ENTRIESADDED.toString());
    }
    if (options?.MAXDELETEDID) {
      args.push("MAXDELETEDID", options.MAXDELETEDID);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XTRIM.js
var require_XTRIM = __commonJS((exports) => {
  var transformArguments = function(key, strategy, threshold, options) {
    const args = ["XTRIM", key, strategy];
    if (options?.strategyModifier) {
      args.push(options.strategyModifier);
    }
    args.push(threshold.toString());
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZADD.js
var require_ZADD = __commonJS((exports) => {
  var transformArguments = function(key, members, options) {
    const args = ["ZADD", key];
    if (options?.NX) {
      args.push("NX");
    } else {
      if (options?.XX) {
        args.push("XX");
      }
      if (options?.GT) {
        args.push("GT");
      } else if (options?.LT) {
        args.push("LT");
      }
    }
    if (options?.CH) {
      args.push("CH");
    }
    if (options?.INCR) {
      args.push("INCR");
    }
    for (const { score, value: value26 } of Array.isArray(members) ? members : [members]) {
      args.push((0, generic_transformers_1.transformNumberInfinityArgument)(score), value26);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformNumberInfinityReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZCARD.js
var require_ZCARD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["ZCARD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZCOUNT.js
var require_ZCOUNT = __commonJS((exports) => {
  var transformArguments = function(key, min, max2) {
    return [
      "ZCOUNT",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF.js
var require_ZDIFF = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArgument)(["ZDIFF"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF_WITHSCORES.js
var require_ZDIFF_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZDIFF_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZDIFF_1 = require_ZDIFF();
  var ZDIFF_2 = require_ZDIFF();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZDIFF_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZDIFF_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZDIFFSTORE.js
var require_ZDIFFSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArgument)(["ZDIFFSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZINCRBY.js
var require_ZINCRBY = __commonJS((exports) => {
  var transformArguments = function(key, increment, member) {
    return [
      "ZINCRBY",
      key,
      (0, generic_transformers_1.transformNumberInfinityArgument)(increment),
      member
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformNumberInfinityReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZINTER.js
var require_ZINTER = __commonJS((exports) => {
  var transformArguments = function(keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZINTER"], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZINTER_WITHSCORES.js
var require_ZINTER_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZINTER_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZINTER_1 = require_ZINTER();
  var ZINTER_2 = require_ZINTER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZINTER_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZINTER_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZINTERCARD.js
var require_ZINTERCARD = __commonJS((exports) => {
  var transformArguments = function(keys, limit) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZINTERCARD"], keys);
    if (limit) {
      args.push("LIMIT", limit.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZINTERSTORE.js
var require_ZINTERSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZINTERSTORE", destination], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZLEXCOUNT.js
var require_ZLEXCOUNT = __commonJS((exports) => {
  var transformArguments = function(key, min, max2) {
    return [
      "ZLEXCOUNT",
      key,
      min,
      max2
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZMSCORE.js
var require_ZMSCORE = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ZMSCORE", key], member);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformNumberInfinityNullArrayReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX.js
var require_ZPOPMAX = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "ZPOPMAX",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetMemberNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX_COUNT.js
var require_ZPOPMAX_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, ZPOPMAX_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var ZPOPMAX_1 = require_ZPOPMAX();
  var ZPOPMAX_2 = require_ZPOPMAX();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZPOPMAX_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN.js
var require_ZPOPMIN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "ZPOPMIN",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetMemberNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN_COUNT.js
var require_ZPOPMIN_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, ZPOPMIN_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var ZPOPMIN_1 = require_ZPOPMIN();
  var ZPOPMIN_2 = require_ZPOPMIN();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZPOPMIN_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER.js
var require_ZRANDMEMBER = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["ZRANDMEMBER", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT.js
var require_ZRANDMEMBER_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, ZRANDMEMBER_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANDMEMBER_1 = require_ZRANDMEMBER();
  var ZRANDMEMBER_2 = require_ZRANDMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANDMEMBER_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANDMEMBER_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT_WITHSCORES.js
var require_ZRANDMEMBER_COUNT_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZRANDMEMBER_COUNT_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANDMEMBER_COUNT_1 = require_ZRANDMEMBER_COUNT();
  var ZRANDMEMBER_COUNT_2 = require_ZRANDMEMBER_COUNT();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANDMEMBER_COUNT_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANDMEMBER_COUNT_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE.js
var require_ZRANGE = __commonJS((exports) => {
  var transformArguments = function(key, min, max2, options) {
    const args = [
      "ZRANGE",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE_WITHSCORES.js
var require_ZRANGE_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZRANGE_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANGE_1 = require_ZRANGE();
  var ZRANGE_2 = require_ZRANGE();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANGE_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANGE_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYLEX.js
var require_ZRANGEBYLEX = __commonJS((exports) => {
  var transformArguments = function(key, min, max2, options) {
    const args = [
      "ZRANGEBYLEX",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE.js
var require_ZRANGEBYSCORE = __commonJS((exports) => {
  var transformArguments = function(key, min, max2, options) {
    const args = [
      "ZRANGEBYSCORE",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE_WITHSCORES.js
var require_ZRANGEBYSCORE_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(key, min, max2, options) {
    return [
      ...(0, ZRANGEBYSCORE_1.transformArguments)(key, min, max2, options),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANGEBYSCORE_1 = require_ZRANGEBYSCORE();
  var ZRANGEBYSCORE_2 = require_ZRANGEBYSCORE();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANGEBYSCORE_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANGEBYSCORE_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANGESTORE.js
var require_ZRANGESTORE = __commonJS((exports) => {
  var transformArguments = function(dst, src, min, max2, options) {
    const args = [
      "ZRANGESTORE",
      dst,
      src,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.WITHSCORES) {
      args.push("WITHSCORES");
    }
    return args;
  };
  var transformReply = function(reply) {
    if (typeof reply !== "number") {
      throw new TypeError(`Upgrade to Redis 6.2.5 and up (https://github.com/redis/redis/pull/9089)`);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ZRANK.js
var require_ZRANK = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["ZRANK", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREM.js
var require_ZREM = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ZREM", key], member);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYLEX.js
var require_ZREMRANGEBYLEX = __commonJS((exports) => {
  var transformArguments = function(key, min, max2) {
    return [
      "ZREMRANGEBYLEX",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYRANK.js
var require_ZREMRANGEBYRANK = __commonJS((exports) => {
  var transformArguments = function(key, start, stop) {
    return ["ZREMRANGEBYRANK", key, start.toString(), stop.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYSCORE.js
var require_ZREMRANGEBYSCORE = __commonJS((exports) => {
  var transformArguments = function(key, min, max2) {
    return [
      "ZREMRANGEBYSCORE",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max2)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREVRANK.js
var require_ZREVRANK = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["ZREVRANK", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZSCAN.js
var require_ZSCAN = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    return (0, generic_transformers_1.pushScanArguments)([
      "ZSCAN",
      key
    ], cursor, options);
  };
  var transformReply = function([cursor, rawMembers]) {
    const parsedMembers = [];
    for (let i = 0;i < rawMembers.length; i += 2) {
      parsedMembers.push({
        value: rawMembers[i],
        score: (0, generic_transformers_1.transformNumberInfinityReply)(rawMembers[i + 1])
      });
    }
    return {
      cursor: Number(cursor),
      members: parsedMembers
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ZSCORE.js
var require_ZSCORE = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["ZSCORE", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformNumberInfinityNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZUNION.js
var require_ZUNION = __commonJS((exports) => {
  var transformArguments = function(keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZUNION"], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZUNION_WITHSCORES.js
var require_ZUNION_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZUNION_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZUNION_1 = require_ZUNION();
  var ZUNION_2 = require_ZUNION();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZUNION_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZUNION_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZUNIONSTORE.js
var require_ZUNIONSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZUNIONSTORE", destination], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/cluster/commands.js
var require_commands = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var APPEND = require_APPEND();
  var BITCOUNT = require_BITCOUNT();
  var BITFIELD_RO = require_BITFIELD_RO();
  var BITFIELD = require_BITFIELD();
  var BITOP = require_BITOP();
  var BITPOS = require_BITPOS();
  var BLMOVE = require_BLMOVE();
  var BLMPOP = require_BLMPOP();
  var BLPOP = require_BLPOP();
  var BRPOP = require_BRPOP();
  var BRPOPLPUSH = require_BRPOPLPUSH();
  var BZMPOP = require_BZMPOP();
  var BZPOPMAX = require_BZPOPMAX();
  var BZPOPMIN = require_BZPOPMIN();
  var COPY = require_COPY();
  var DECR = require_DECR();
  var DECRBY = require_DECRBY();
  var DEL = require_DEL();
  var DUMP = require_DUMP();
  var EVAL_RO = require_EVAL_RO();
  var EVAL = require_EVAL();
  var EVALSHA_RO = require_EVALSHA_RO();
  var EVALSHA = require_EVALSHA();
  var EXISTS = require_EXISTS();
  var EXPIRE = require_EXPIRE();
  var EXPIREAT = require_EXPIREAT();
  var EXPIRETIME = require_EXPIRETIME();
  var FCALL_RO = require_FCALL_RO();
  var FCALL = require_FCALL();
  var GEOADD = require_GEOADD();
  var GEODIST = require_GEODIST();
  var GEOHASH = require_GEOHASH();
  var GEOPOS = require_GEOPOS();
  var GEORADIUS_RO_WITH = require_GEORADIUS_RO_WITH();
  var GEORADIUS_RO = require_GEORADIUS_RO();
  var GEORADIUS_WITH = require_GEORADIUS_WITH();
  var GEORADIUS = require_GEORADIUS();
  var GEORADIUSBYMEMBER_RO_WITH = require_GEORADIUSBYMEMBER_RO_WITH();
  var GEORADIUSBYMEMBER_RO = require_GEORADIUSBYMEMBER_RO();
  var GEORADIUSBYMEMBER_WITH = require_GEORADIUSBYMEMBER_WITH();
  var GEORADIUSBYMEMBER = require_GEORADIUSBYMEMBER();
  var GEORADIUSBYMEMBERSTORE = require_GEORADIUSBYMEMBERSTORE();
  var GEORADIUSSTORE = require_GEORADIUSSTORE();
  var GEOSEARCH_WITH = require_GEOSEARCH_WITH();
  var GEOSEARCH = require_GEOSEARCH();
  var GEOSEARCHSTORE = require_GEOSEARCHSTORE();
  var GET = require_GET();
  var GETBIT = require_GETBIT();
  var GETDEL = require_GETDEL();
  var GETEX = require_GETEX();
  var GETRANGE = require_GETRANGE();
  var GETSET = require_GETSET();
  var HDEL = require_HDEL();
  var HEXISTS = require_HEXISTS();
  var HEXPIRE = require_HEXPIRE();
  var HEXPIREAT = require_HEXPIREAT();
  var HEXPIRETIME = require_HEXPIRETIME();
  var HGET = require_HGET();
  var HGETALL = require_HGETALL();
  var HINCRBY = require_HINCRBY();
  var HINCRBYFLOAT = require_HINCRBYFLOAT();
  var HKEYS = require_HKEYS();
  var HLEN = require_HLEN();
  var HMGET = require_HMGET();
  var HPERSIST = require_HPERSIST();
  var HPEXPIRE = require_HPEXPIRE();
  var HPEXPIREAT = require_HPEXPIREAT();
  var HPEXPIRETIME = require_HPEXPIRETIME();
  var HPTTL = require_HPTTL();
  var HRANDFIELD_COUNT_WITHVALUES = require_HRANDFIELD_COUNT_WITHVALUES();
  var HRANDFIELD_COUNT = require_HRANDFIELD_COUNT();
  var HRANDFIELD = require_HRANDFIELD();
  var HSCAN = require_HSCAN();
  var HSCAN_NOVALUES = require_HSCAN_NOVALUES();
  var HSET = require_HSET();
  var HSETNX = require_HSETNX();
  var HSTRLEN = require_HSTRLEN();
  var HTTL = require_HTTL();
  var HVALS = require_HVALS();
  var INCR = require_INCR();
  var INCRBY = require_INCRBY();
  var INCRBYFLOAT = require_INCRBYFLOAT();
  var LCS_IDX_WITHMATCHLEN = require_LCS_IDX_WITHMATCHLEN();
  var LCS_IDX = require_LCS_IDX();
  var LCS_LEN = require_LCS_LEN();
  var LCS = require_LCS();
  var LINDEX = require_LINDEX();
  var LINSERT = require_LINSERT();
  var LLEN = require_LLEN();
  var LMOVE = require_LMOVE();
  var LMPOP = require_LMPOP();
  var LPOP_COUNT = require_LPOP_COUNT();
  var LPOP = require_LPOP();
  var LPOS_COUNT = require_LPOS_COUNT();
  var LPOS = require_LPOS();
  var LPUSH = require_LPUSH();
  var LPUSHX = require_LPUSHX();
  var LRANGE = require_LRANGE();
  var LREM = require_LREM();
  var LSET = require_LSET();
  var LTRIM = require_LTRIM();
  var MGET = require_MGET();
  var MIGRATE = require_MIGRATE();
  var MSET = require_MSET();
  var MSETNX = require_MSETNX();
  var OBJECT_ENCODING = require_OBJECT_ENCODING();
  var OBJECT_FREQ = require_OBJECT_FREQ();
  var OBJECT_IDLETIME = require_OBJECT_IDLETIME();
  var OBJECT_REFCOUNT = require_OBJECT_REFCOUNT();
  var PERSIST = require_PERSIST();
  var PEXPIRE = require_PEXPIRE();
  var PEXPIREAT = require_PEXPIREAT();
  var PEXPIRETIME = require_PEXPIRETIME();
  var PFADD = require_PFADD();
  var PFCOUNT = require_PFCOUNT();
  var PFMERGE = require_PFMERGE();
  var PSETEX = require_PSETEX();
  var PTTL = require_PTTL();
  var PUBLISH = require_PUBLISH();
  var RENAME = require_RENAME();
  var RENAMENX = require_RENAMENX();
  var RESTORE = require_RESTORE();
  var RPOP_COUNT = require_RPOP_COUNT();
  var RPOP = require_RPOP();
  var RPOPLPUSH = require_RPOPLPUSH();
  var RPUSH = require_RPUSH();
  var RPUSHX = require_RPUSHX();
  var SADD = require_SADD();
  var SCARD = require_SCARD();
  var SDIFF = require_SDIFF();
  var SDIFFSTORE = require_SDIFFSTORE();
  var SET = require_SET();
  var SETBIT = require_SETBIT();
  var SETEX = require_SETEX();
  var SETNX = require_SETNX();
  var SETRANGE = require_SETRANGE();
  var SINTER = require_SINTER();
  var SINTERCARD = require_SINTERCARD();
  var SINTERSTORE = require_SINTERSTORE();
  var SISMEMBER = require_SISMEMBER();
  var SMEMBERS = require_SMEMBERS();
  var SMISMEMBER = require_SMISMEMBER();
  var SMOVE = require_SMOVE();
  var SORT_RO = require_SORT_RO();
  var SORT_STORE = require_SORT_STORE();
  var SORT = require_SORT();
  var SPOP = require_SPOP();
  var SPUBLISH = require_SPUBLISH();
  var SRANDMEMBER_COUNT = require_SRANDMEMBER_COUNT();
  var SRANDMEMBER = require_SRANDMEMBER();
  var SREM = require_SREM();
  var SSCAN = require_SSCAN();
  var STRLEN = require_STRLEN();
  var SUNION = require_SUNION();
  var SUNIONSTORE = require_SUNIONSTORE();
  var TOUCH = require_TOUCH();
  var TTL = require_TTL();
  var TYPE = require_TYPE();
  var UNLINK = require_UNLINK();
  var WATCH = require_WATCH();
  var XACK = require_XACK();
  var XADD = require_XADD();
  var XAUTOCLAIM_JUSTID = require_XAUTOCLAIM_JUSTID();
  var XAUTOCLAIM = require_XAUTOCLAIM();
  var XCLAIM_JUSTID = require_XCLAIM_JUSTID();
  var XCLAIM = require_XCLAIM();
  var XDEL = require_XDEL();
  var XGROUP_CREATE = require_XGROUP_CREATE();
  var XGROUP_CREATECONSUMER = require_XGROUP_CREATECONSUMER();
  var XGROUP_DELCONSUMER = require_XGROUP_DELCONSUMER();
  var XGROUP_DESTROY = require_XGROUP_DESTROY();
  var XGROUP_SETID = require_XGROUP_SETID();
  var XINFO_CONSUMERS = require_XINFO_CONSUMERS();
  var XINFO_GROUPS = require_XINFO_GROUPS();
  var XINFO_STREAM = require_XINFO_STREAM();
  var XLEN = require_XLEN();
  var XPENDING_RANGE = require_XPENDING_RANGE();
  var XPENDING = require_XPENDING();
  var XRANGE = require_XRANGE();
  var XREAD = require_XREAD();
  var XREADGROUP = require_XREADGROUP();
  var XREVRANGE = require_XREVRANGE();
  var XSETID = require_XSETID();
  var XTRIM = require_XTRIM();
  var ZADD = require_ZADD();
  var ZCARD = require_ZCARD();
  var ZCOUNT = require_ZCOUNT();
  var ZDIFF_WITHSCORES = require_ZDIFF_WITHSCORES();
  var ZDIFF = require_ZDIFF();
  var ZDIFFSTORE = require_ZDIFFSTORE();
  var ZINCRBY = require_ZINCRBY();
  var ZINTER_WITHSCORES = require_ZINTER_WITHSCORES();
  var ZINTER = require_ZINTER();
  var ZINTERCARD = require_ZINTERCARD();
  var ZINTERSTORE = require_ZINTERSTORE();
  var ZLEXCOUNT = require_ZLEXCOUNT();
  var ZMPOP = require_ZMPOP();
  var ZMSCORE = require_ZMSCORE();
  var ZPOPMAX_COUNT = require_ZPOPMAX_COUNT();
  var ZPOPMAX = require_ZPOPMAX();
  var ZPOPMIN_COUNT = require_ZPOPMIN_COUNT();
  var ZPOPMIN = require_ZPOPMIN();
  var ZRANDMEMBER_COUNT_WITHSCORES = require_ZRANDMEMBER_COUNT_WITHSCORES();
  var ZRANDMEMBER_COUNT = require_ZRANDMEMBER_COUNT();
  var ZRANDMEMBER = require_ZRANDMEMBER();
  var ZRANGE_WITHSCORES = require_ZRANGE_WITHSCORES();
  var ZRANGE = require_ZRANGE();
  var ZRANGEBYLEX = require_ZRANGEBYLEX();
  var ZRANGEBYSCORE_WITHSCORES = require_ZRANGEBYSCORE_WITHSCORES();
  var ZRANGEBYSCORE = require_ZRANGEBYSCORE();
  var ZRANGESTORE = require_ZRANGESTORE();
  var ZRANK = require_ZRANK();
  var ZREM = require_ZREM();
  var ZREMRANGEBYLEX = require_ZREMRANGEBYLEX();
  var ZREMRANGEBYRANK = require_ZREMRANGEBYRANK();
  var ZREMRANGEBYSCORE = require_ZREMRANGEBYSCORE();
  var ZREVRANK = require_ZREVRANK();
  var ZSCAN = require_ZSCAN();
  var ZSCORE = require_ZSCORE();
  var ZUNION_WITHSCORES = require_ZUNION_WITHSCORES();
  var ZUNION = require_ZUNION();
  var ZUNIONSTORE = require_ZUNIONSTORE();
  exports.default = {
    APPEND,
    append: APPEND,
    BITCOUNT,
    bitCount: BITCOUNT,
    BITFIELD_RO,
    bitFieldRo: BITFIELD_RO,
    BITFIELD,
    bitField: BITFIELD,
    BITOP,
    bitOp: BITOP,
    BITPOS,
    bitPos: BITPOS,
    BLMOVE,
    blMove: BLMOVE,
    BLMPOP,
    blmPop: BLMPOP,
    BLPOP,
    blPop: BLPOP,
    BRPOP,
    brPop: BRPOP,
    BRPOPLPUSH,
    brPopLPush: BRPOPLPUSH,
    BZMPOP,
    bzmPop: BZMPOP,
    BZPOPMAX,
    bzPopMax: BZPOPMAX,
    BZPOPMIN,
    bzPopMin: BZPOPMIN,
    COPY,
    copy: COPY,
    DECR,
    decr: DECR,
    DECRBY,
    decrBy: DECRBY,
    DEL,
    del: DEL,
    DUMP,
    dump: DUMP,
    EVAL_RO,
    evalRo: EVAL_RO,
    EVAL,
    eval: EVAL,
    EVALSHA,
    evalSha: EVALSHA,
    EVALSHA_RO,
    evalShaRo: EVALSHA_RO,
    EXISTS,
    exists: EXISTS,
    EXPIRE,
    expire: EXPIRE,
    EXPIREAT,
    expireAt: EXPIREAT,
    EXPIRETIME,
    expireTime: EXPIRETIME,
    FCALL_RO,
    fCallRo: FCALL_RO,
    FCALL,
    fCall: FCALL,
    GEOADD,
    geoAdd: GEOADD,
    GEODIST,
    geoDist: GEODIST,
    GEOHASH,
    geoHash: GEOHASH,
    GEOPOS,
    geoPos: GEOPOS,
    GEORADIUS_RO_WITH,
    geoRadiusRoWith: GEORADIUS_RO_WITH,
    GEORADIUS_RO,
    geoRadiusRo: GEORADIUS_RO,
    GEORADIUS_WITH,
    geoRadiusWith: GEORADIUS_WITH,
    GEORADIUS,
    geoRadius: GEORADIUS,
    GEORADIUSBYMEMBER_RO_WITH,
    geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH,
    GEORADIUSBYMEMBER_RO,
    geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO,
    GEORADIUSBYMEMBER_WITH,
    geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH,
    GEORADIUSBYMEMBER,
    geoRadiusByMember: GEORADIUSBYMEMBER,
    GEORADIUSBYMEMBERSTORE,
    geoRadiusByMemberStore: GEORADIUSBYMEMBERSTORE,
    GEORADIUSSTORE,
    geoRadiusStore: GEORADIUSSTORE,
    GEOSEARCH_WITH,
    geoSearchWith: GEOSEARCH_WITH,
    GEOSEARCH,
    geoSearch: GEOSEARCH,
    GEOSEARCHSTORE,
    geoSearchStore: GEOSEARCHSTORE,
    GET,
    get: GET,
    GETBIT,
    getBit: GETBIT,
    GETDEL,
    getDel: GETDEL,
    GETEX,
    getEx: GETEX,
    GETRANGE,
    getRange: GETRANGE,
    GETSET,
    getSet: GETSET,
    HDEL,
    hDel: HDEL,
    HEXISTS,
    hExists: HEXISTS,
    HEXPIRE,
    hExpire: HEXPIRE,
    HEXPIREAT,
    hExpireAt: HEXPIREAT,
    HEXPIRETIME,
    hExpireTime: HEXPIRETIME,
    HGET,
    hGet: HGET,
    HGETALL,
    hGetAll: HGETALL,
    HINCRBY,
    hIncrBy: HINCRBY,
    HINCRBYFLOAT,
    hIncrByFloat: HINCRBYFLOAT,
    HKEYS,
    hKeys: HKEYS,
    HLEN,
    hLen: HLEN,
    HMGET,
    hmGet: HMGET,
    HPERSIST,
    hPersist: HPERSIST,
    HPEXPIRE,
    hpExpire: HPEXPIRE,
    HPEXPIREAT,
    hpExpireAt: HPEXPIREAT,
    HPEXPIRETIME,
    hpExpireTime: HPEXPIRETIME,
    HPTTL,
    hpTTL: HPTTL,
    HRANDFIELD_COUNT_WITHVALUES,
    hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES,
    HRANDFIELD_COUNT,
    hRandFieldCount: HRANDFIELD_COUNT,
    HRANDFIELD,
    hRandField: HRANDFIELD,
    HSCAN,
    hScan: HSCAN,
    HSCAN_NOVALUES,
    hScanNoValues: HSCAN_NOVALUES,
    HSET,
    hSet: HSET,
    HSETNX,
    hSetNX: HSETNX,
    HSTRLEN,
    hStrLen: HSTRLEN,
    HTTL,
    hTTL: HTTL,
    HVALS,
    hVals: HVALS,
    INCR,
    incr: INCR,
    INCRBY,
    incrBy: INCRBY,
    INCRBYFLOAT,
    incrByFloat: INCRBYFLOAT,
    LCS_IDX_WITHMATCHLEN,
    lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN,
    LCS_IDX,
    lcsIdx: LCS_IDX,
    LCS_LEN,
    lcsLen: LCS_LEN,
    LCS,
    lcs: LCS,
    LINDEX,
    lIndex: LINDEX,
    LINSERT,
    lInsert: LINSERT,
    LLEN,
    lLen: LLEN,
    LMOVE,
    lMove: LMOVE,
    LMPOP,
    lmPop: LMPOP,
    LPOP_COUNT,
    lPopCount: LPOP_COUNT,
    LPOP,
    lPop: LPOP,
    LPOS_COUNT,
    lPosCount: LPOS_COUNT,
    LPOS,
    lPos: LPOS,
    LPUSH,
    lPush: LPUSH,
    LPUSHX,
    lPushX: LPUSHX,
    LRANGE,
    lRange: LRANGE,
    LREM,
    lRem: LREM,
    LSET,
    lSet: LSET,
    LTRIM,
    lTrim: LTRIM,
    MGET,
    mGet: MGET,
    MIGRATE,
    migrate: MIGRATE,
    MSET,
    mSet: MSET,
    MSETNX,
    mSetNX: MSETNX,
    OBJECT_ENCODING,
    objectEncoding: OBJECT_ENCODING,
    OBJECT_FREQ,
    objectFreq: OBJECT_FREQ,
    OBJECT_IDLETIME,
    objectIdleTime: OBJECT_IDLETIME,
    OBJECT_REFCOUNT,
    objectRefCount: OBJECT_REFCOUNT,
    PERSIST,
    persist: PERSIST,
    PEXPIRE,
    pExpire: PEXPIRE,
    PEXPIREAT,
    pExpireAt: PEXPIREAT,
    PEXPIRETIME,
    pExpireTime: PEXPIRETIME,
    PFADD,
    pfAdd: PFADD,
    PFCOUNT,
    pfCount: PFCOUNT,
    PFMERGE,
    pfMerge: PFMERGE,
    PSETEX,
    pSetEx: PSETEX,
    PTTL,
    pTTL: PTTL,
    PUBLISH,
    publish: PUBLISH,
    RENAME,
    rename: RENAME,
    RENAMENX,
    renameNX: RENAMENX,
    RESTORE,
    restore: RESTORE,
    RPOP_COUNT,
    rPopCount: RPOP_COUNT,
    RPOP,
    rPop: RPOP,
    RPOPLPUSH,
    rPopLPush: RPOPLPUSH,
    RPUSH,
    rPush: RPUSH,
    RPUSHX,
    rPushX: RPUSHX,
    SADD,
    sAdd: SADD,
    SCARD,
    sCard: SCARD,
    SDIFF,
    sDiff: SDIFF,
    SDIFFSTORE,
    sDiffStore: SDIFFSTORE,
    SINTER,
    sInter: SINTER,
    SINTERCARD,
    sInterCard: SINTERCARD,
    SINTERSTORE,
    sInterStore: SINTERSTORE,
    SET,
    set: SET,
    SETBIT,
    setBit: SETBIT,
    SETEX,
    setEx: SETEX,
    SETNX,
    setNX: SETNX,
    SETRANGE,
    setRange: SETRANGE,
    SISMEMBER,
    sIsMember: SISMEMBER,
    SMEMBERS,
    sMembers: SMEMBERS,
    SMISMEMBER,
    smIsMember: SMISMEMBER,
    SMOVE,
    sMove: SMOVE,
    SORT_RO,
    sortRo: SORT_RO,
    SORT_STORE,
    sortStore: SORT_STORE,
    SORT,
    sort: SORT,
    SPOP,
    sPop: SPOP,
    SPUBLISH,
    sPublish: SPUBLISH,
    SRANDMEMBER_COUNT,
    sRandMemberCount: SRANDMEMBER_COUNT,
    SRANDMEMBER,
    sRandMember: SRANDMEMBER,
    SREM,
    sRem: SREM,
    SSCAN,
    sScan: SSCAN,
    STRLEN,
    strLen: STRLEN,
    SUNION,
    sUnion: SUNION,
    SUNIONSTORE,
    sUnionStore: SUNIONSTORE,
    TOUCH,
    touch: TOUCH,
    TTL,
    ttl: TTL,
    TYPE,
    type: TYPE,
    UNLINK,
    unlink: UNLINK,
    WATCH,
    watch: WATCH,
    XACK,
    xAck: XACK,
    XADD,
    xAdd: XADD,
    XAUTOCLAIM_JUSTID,
    xAutoClaimJustId: XAUTOCLAIM_JUSTID,
    XAUTOCLAIM,
    xAutoClaim: XAUTOCLAIM,
    XCLAIM,
    xClaim: XCLAIM,
    XCLAIM_JUSTID,
    xClaimJustId: XCLAIM_JUSTID,
    XDEL,
    xDel: XDEL,
    XGROUP_CREATE,
    xGroupCreate: XGROUP_CREATE,
    XGROUP_CREATECONSUMER,
    xGroupCreateConsumer: XGROUP_CREATECONSUMER,
    XGROUP_DELCONSUMER,
    xGroupDelConsumer: XGROUP_DELCONSUMER,
    XGROUP_DESTROY,
    xGroupDestroy: XGROUP_DESTROY,
    XGROUP_SETID,
    xGroupSetId: XGROUP_SETID,
    XINFO_CONSUMERS,
    xInfoConsumers: XINFO_CONSUMERS,
    XINFO_GROUPS,
    xInfoGroups: XINFO_GROUPS,
    XINFO_STREAM,
    xInfoStream: XINFO_STREAM,
    XLEN,
    xLen: XLEN,
    XPENDING_RANGE,
    xPendingRange: XPENDING_RANGE,
    XPENDING,
    xPending: XPENDING,
    XRANGE,
    xRange: XRANGE,
    XREAD,
    xRead: XREAD,
    XREADGROUP,
    xReadGroup: XREADGROUP,
    XREVRANGE,
    xRevRange: XREVRANGE,
    XSETID,
    xSetId: XSETID,
    XTRIM,
    xTrim: XTRIM,
    ZADD,
    zAdd: ZADD,
    ZCARD,
    zCard: ZCARD,
    ZCOUNT,
    zCount: ZCOUNT,
    ZDIFF_WITHSCORES,
    zDiffWithScores: ZDIFF_WITHSCORES,
    ZDIFF,
    zDiff: ZDIFF,
    ZDIFFSTORE,
    zDiffStore: ZDIFFSTORE,
    ZINCRBY,
    zIncrBy: ZINCRBY,
    ZINTER_WITHSCORES,
    zInterWithScores: ZINTER_WITHSCORES,
    ZINTER,
    zInter: ZINTER,
    ZINTERCARD,
    zInterCard: ZINTERCARD,
    ZINTERSTORE,
    zInterStore: ZINTERSTORE,
    ZLEXCOUNT,
    zLexCount: ZLEXCOUNT,
    ZMPOP,
    zmPop: ZMPOP,
    ZMSCORE,
    zmScore: ZMSCORE,
    ZPOPMAX_COUNT,
    zPopMaxCount: ZPOPMAX_COUNT,
    ZPOPMAX,
    zPopMax: ZPOPMAX,
    ZPOPMIN_COUNT,
    zPopMinCount: ZPOPMIN_COUNT,
    ZPOPMIN,
    zPopMin: ZPOPMIN,
    ZRANDMEMBER_COUNT_WITHSCORES,
    zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES,
    ZRANDMEMBER_COUNT,
    zRandMemberCount: ZRANDMEMBER_COUNT,
    ZRANDMEMBER,
    zRandMember: ZRANDMEMBER,
    ZRANGE_WITHSCORES,
    zRangeWithScores: ZRANGE_WITHSCORES,
    ZRANGE,
    zRange: ZRANGE,
    ZRANGEBYLEX,
    zRangeByLex: ZRANGEBYLEX,
    ZRANGEBYSCORE_WITHSCORES,
    zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES,
    ZRANGEBYSCORE,
    zRangeByScore: ZRANGEBYSCORE,
    ZRANGESTORE,
    zRangeStore: ZRANGESTORE,
    ZRANK,
    zRank: ZRANK,
    ZREM,
    zRem: ZREM,
    ZREMRANGEBYLEX,
    zRemRangeByLex: ZREMRANGEBYLEX,
    ZREMRANGEBYRANK,
    zRemRangeByRank: ZREMRANGEBYRANK,
    ZREMRANGEBYSCORE,
    zRemRangeByScore: ZREMRANGEBYSCORE,
    ZREVRANK,
    zRevRank: ZREVRANK,
    ZSCAN,
    zScan: ZSCAN,
    ZSCORE,
    zScore: ZSCORE,
    ZUNION_WITHSCORES,
    zUnionWithScores: ZUNION_WITHSCORES,
    ZUNION,
    zUnion: ZUNION,
    ZUNIONSTORE,
    zUnionStore: ZUNIONSTORE
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_CAT.js
var require_ACL_CAT = __commonJS((exports) => {
  var transformArguments = function(categoryName) {
    const args = ["ACL", "CAT"];
    if (categoryName) {
      args.push(categoryName);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_DELUSER.js
var require_ACL_DELUSER = __commonJS((exports) => {
  var transformArguments = function(username) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ACL", "DELUSER"], username);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_DRYRUN.js
var require_ACL_DRYRUN = __commonJS((exports) => {
  var transformArguments = function(username, command) {
    return [
      "ACL",
      "DRYRUN",
      username,
      ...command
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_GENPASS.js
var require_ACL_GENPASS = __commonJS((exports) => {
  var transformArguments = function(bits2) {
    const args = ["ACL", "GENPASS"];
    if (bits2) {
      args.push(bits2.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_GETUSER.js
var require_ACL_GETUSER = __commonJS((exports) => {
  var transformArguments = function(username) {
    return ["ACL", "GETUSER", username];
  };
  var transformReply = function(reply) {
    return {
      flags: reply[1],
      passwords: reply[3],
      commands: reply[5],
      keys: reply[7],
      channels: reply[9],
      selectors: reply[11]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LIST.js
var require_ACL_LIST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOAD.js
var require_ACL_LOAD = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "LOAD"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG_RESET.js
var require_ACL_LOG_RESET = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "LOG", "RESET"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG.js
var require_ACL_LOG = __commonJS((exports) => {
  var transformArguments = function(count) {
    const args = ["ACL", "LOG"];
    if (count) {
      args.push(count.toString());
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply.map((log) => ({
      count: log[1],
      reason: log[3],
      context: log[5],
      object: log[7],
      username: log[9],
      ageSeconds: Number(log[11]),
      clientInfo: log[13]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ACL_SAVE.js
var require_ACL_SAVE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "SAVE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_SETUSER.js
var require_ACL_SETUSER = __commonJS((exports) => {
  var transformArguments = function(username, rule) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ACL", "SETUSER", username], rule);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_USERS.js
var require_ACL_USERS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "USERS"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_WHOAMI.js
var require_ACL_WHOAMI = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "WHOAMI"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ASKING.js
var require_ASKING = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ASKING"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/AUTH.js
var require_AUTH = __commonJS((exports) => {
  var transformArguments = function({ username, password }) {
    if (!username) {
      return ["AUTH", password];
    }
    return ["AUTH", username, password];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BGREWRITEAOF.js
var require_BGREWRITEAOF = __commonJS((exports) => {
  var transformArguments = function() {
    return ["BGREWRITEAOF"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BGSAVE.js
var require_BGSAVE = __commonJS((exports) => {
  var transformArguments = function(options) {
    const args = ["BGSAVE"];
    if (options?.SCHEDULE) {
      args.push("SCHEDULE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_CACHING.js
var require_CLIENT_CACHING = __commonJS((exports) => {
  var transformArguments = function(value26) {
    return [
      "CLIENT",
      "CACHING",
      value26 ? "YES" : "NO"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETNAME.js
var require_CLIENT_GETNAME = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "GETNAME"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETREDIR.js
var require_CLIENT_GETREDIR = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "GETREDIR"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_ID.js
var require_CLIENT_ID = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "ID"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_KILL.js
var require_CLIENT_KILL = __commonJS((exports) => {
  var transformArguments = function(filters) {
    const args = ["CLIENT", "KILL"];
    if (Array.isArray(filters)) {
      for (const filter of filters) {
        pushFilter(args, filter);
      }
    } else {
      pushFilter(args, filters);
    }
    return args;
  };
  var pushFilter = function(args, filter) {
    if (filter === ClientKillFilters.SKIP_ME) {
      args.push("SKIPME");
      return;
    }
    args.push(filter.filter);
    switch (filter.filter) {
      case ClientKillFilters.ADDRESS:
        args.push(filter.address);
        break;
      case ClientKillFilters.LOCAL_ADDRESS:
        args.push(filter.localAddress);
        break;
      case ClientKillFilters.ID:
        args.push(typeof filter.id === "number" ? filter.id.toString() : filter.id);
        break;
      case ClientKillFilters.TYPE:
        args.push(filter.type);
        break;
      case ClientKillFilters.USER:
        args.push(filter.username);
        break;
      case ClientKillFilters.SKIP_ME:
        args.push(filter.skipMe ? "yes" : "no");
        break;
      case ClientKillFilters.MAXAGE:
        args.push(filter.maxAge.toString());
        break;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.ClientKillFilters = undefined;
  var ClientKillFilters;
  (function(ClientKillFilters2) {
    ClientKillFilters2["ADDRESS"] = "ADDR";
    ClientKillFilters2["LOCAL_ADDRESS"] = "LADDR";
    ClientKillFilters2["ID"] = "ID";
    ClientKillFilters2["TYPE"] = "TYPE";
    ClientKillFilters2["USER"] = "USER";
    ClientKillFilters2["SKIP_ME"] = "SKIPME";
    ClientKillFilters2["MAXAGE"] = "MAXAGE";
  })(ClientKillFilters || (exports.ClientKillFilters = ClientKillFilters = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_INFO.js
var require_CLIENT_INFO = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "INFO"];
  };
  var transformReply = function(rawReply) {
    const map3 = {};
    for (const item of rawReply.matchAll(CLIENT_INFO_REGEX)) {
      map3[item[1]] = item[2];
    }
    const reply = {
      id: Number(map3.id),
      addr: map3.addr,
      fd: Number(map3.fd),
      name: map3.name,
      age: Number(map3.age),
      idle: Number(map3.idle),
      flags: map3.flags,
      db: Number(map3.db),
      sub: Number(map3.sub),
      psub: Number(map3.psub),
      multi: Number(map3.multi),
      qbuf: Number(map3.qbuf),
      qbufFree: Number(map3["qbuf-free"]),
      argvMem: Number(map3["argv-mem"]),
      obl: Number(map3.obl),
      oll: Number(map3.oll),
      omem: Number(map3.omem),
      totMem: Number(map3["tot-mem"]),
      events: map3.events,
      cmd: map3.cmd,
      user: map3.user,
      libName: map3["lib-name"],
      libVer: map3["lib-ver"]
    };
    if (map3.laddr !== undefined) {
      reply.laddr = map3.laddr;
    }
    if (map3.redir !== undefined) {
      reply.redir = Number(map3.redir);
    }
    if (map3.ssub !== undefined) {
      reply.ssub = Number(map3.ssub);
    }
    if (map3["multi-mem"] !== undefined) {
      reply.multiMem = Number(map3["multi-mem"]);
    }
    if (map3.resp !== undefined) {
      reply.resp = Number(map3.resp);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_LIST.js
var require_CLIENT_LIST = __commonJS((exports) => {
  var transformArguments = function(filter) {
    let args = ["CLIENT", "LIST"];
    if (filter) {
      if (filter.TYPE !== undefined) {
        args.push("TYPE", filter.TYPE);
      } else {
        args.push("ID");
        args = (0, generic_transformers_1.pushVerdictArguments)(args, filter.ID);
      }
    }
    return args;
  };
  var transformReply = function(rawReply) {
    const split = rawReply.split("\n"), length = split.length - 1, reply = [];
    for (let i = 0;i < length; i++) {
      reply.push((0, CLIENT_INFO_1.transformReply)(split[i]));
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var CLIENT_INFO_1 = require_CLIENT_INFO();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-EVICT.js
var require_CLIENT_NO_EVICT = __commonJS((exports) => {
  var transformArguments = function(value26) {
    return [
      "CLIENT",
      "NO-EVICT",
      value26 ? "ON" : "OFF"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-TOUCH.js
var require_CLIENT_NO_TOUCH = __commonJS((exports) => {
  var transformArguments = function(value26) {
    return [
      "CLIENT",
      "NO-TOUCH",
      value26 ? "ON" : "OFF"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_PAUSE.js
var require_CLIENT_PAUSE = __commonJS((exports) => {
  var transformArguments = function(timeout, mode) {
    const args = [
      "CLIENT",
      "PAUSE",
      timeout.toString()
    ];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_SETNAME.js
var require_CLIENT_SETNAME = __commonJS((exports) => {
  var transformArguments = function(name) {
    return ["CLIENT", "SETNAME", name];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKING.js
var require_CLIENT_TRACKING = __commonJS((exports) => {
  var transformArguments = function(mode, options) {
    const args = [
      "CLIENT",
      "TRACKING",
      mode ? "ON" : "OFF"
    ];
    if (mode) {
      if (options?.REDIRECT) {
        args.push("REDIRECT", options.REDIRECT.toString());
      }
      if (isBroadcast(options)) {
        args.push("BCAST");
        if (options?.PREFIX) {
          if (Array.isArray(options.PREFIX)) {
            for (const prefix of options.PREFIX) {
              args.push("PREFIX", prefix);
            }
          } else {
            args.push("PREFIX", options.PREFIX);
          }
        }
      } else if (isOptIn(options)) {
        args.push("OPTIN");
      } else if (isOptOut(options)) {
        args.push("OPTOUT");
      }
      if (options?.NOLOOP) {
        args.push("NOLOOP");
      }
    }
    return args;
  };
  var isBroadcast = function(options) {
    return options?.BCAST === true;
  };
  var isOptIn = function(options) {
    return options?.OPTIN === true;
  };
  var isOptOut = function(options) {
    return options?.OPTOUT === true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKINGINFO.js
var require_CLIENT_TRACKINGINFO = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "TRACKINGINFO"];
  };
  var transformReply = function(reply) {
    return {
      flags: new Set(reply[1]),
      redirect: reply[3],
      prefixes: reply[5]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_UNPAUSE.js
var require_CLIENT_UNPAUSE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "UNPAUSE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTS.js
var require_CLUSTER_ADDSLOTS = __commonJS((exports) => {
  var transformArguments = function(slots) {
    return (0, generic_transformers_1.pushVerdictNumberArguments)(["CLUSTER", "ADDSLOTS"], slots);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTSRANGE.js
var require_CLUSTER_ADDSLOTSRANGE = __commonJS((exports) => {
  var transformArguments = function(ranges) {
    return (0, generic_transformers_1.pushSlotRangesArguments)(["CLUSTER", "ADDSLOTSRANGE"], ranges);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_BUMPEPOCH.js
var require_CLUSTER_BUMPEPOCH = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "BUMPEPOCH"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNT-FAILURE-REPORTS.js
var require_CLUSTER_COUNT_FAILURE_REPORTS = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "COUNT-FAILURE-REPORTS", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNTKEYSINSLOT.js
var require_CLUSTER_COUNTKEYSINSLOT = __commonJS((exports) => {
  var transformArguments = function(slot) {
    return ["CLUSTER", "COUNTKEYSINSLOT", slot.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTS.js
var require_CLUSTER_DELSLOTS = __commonJS((exports) => {
  var transformArguments = function(slots) {
    return (0, generic_transformers_1.pushVerdictNumberArguments)(["CLUSTER", "DELSLOTS"], slots);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTSRANGE.js
var require_CLUSTER_DELSLOTSRANGE = __commonJS((exports) => {
  var transformArguments = function(ranges) {
    return (0, generic_transformers_1.pushSlotRangesArguments)(["CLUSTER", "DELSLOTSRANGE"], ranges);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FAILOVER.js
var require_CLUSTER_FAILOVER = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["CLUSTER", "FAILOVER"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FailoverModes = undefined;
  var FailoverModes;
  (function(FailoverModes2) {
    FailoverModes2["FORCE"] = "FORCE";
    FailoverModes2["TAKEOVER"] = "TAKEOVER";
  })(FailoverModes || (exports.FailoverModes = FailoverModes = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FLUSHSLOTS.js
var require_CLUSTER_FLUSHSLOTS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "FLUSHSLOTS"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FORGET.js
var require_CLUSTER_FORGET = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "FORGET", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_GETKEYSINSLOT.js
var require_CLUSTER_GETKEYSINSLOT = __commonJS((exports) => {
  var transformArguments = function(slot, count) {
    return ["CLUSTER", "GETKEYSINSLOT", slot.toString(), count.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_INFO.js
var require_CLUSTER_INFO = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "INFO"];
  };
  var transformReply = function(reply) {
    const lines = reply.split("\r\n");
    return {
      state: extractLineValue(lines[0]),
      slots: {
        assigned: Number(extractLineValue(lines[1])),
        ok: Number(extractLineValue(lines[2])),
        pfail: Number(extractLineValue(lines[3])),
        fail: Number(extractLineValue(lines[4]))
      },
      knownNodes: Number(extractLineValue(lines[5])),
      size: Number(extractLineValue(lines[6])),
      currentEpoch: Number(extractLineValue(lines[7])),
      myEpoch: Number(extractLineValue(lines[8])),
      stats: {
        messagesSent: Number(extractLineValue(lines[9])),
        messagesReceived: Number(extractLineValue(lines[10]))
      }
    };
  };
  var extractLineValue = function(line) {
    return line.substring(line.indexOf(":") + 1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractLineValue = exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
  exports.extractLineValue = extractLineValue;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_KEYSLOT.js
var require_CLUSTER_KEYSLOT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["CLUSTER", "KEYSLOT", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_LINKS.js
var require_CLUSTER_LINKS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "LINKS"];
  };
  var transformReply = function(reply) {
    return reply.map((peerLink) => ({
      direction: peerLink[1],
      node: peerLink[3],
      createTime: Number(peerLink[5]),
      events: peerLink[7],
      sendBufferAllocated: Number(peerLink[9]),
      sendBufferUsed: Number(peerLink[11])
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MEET.js
var require_CLUSTER_MEET = __commonJS((exports) => {
  var transformArguments = function(ip, port) {
    return ["CLUSTER", "MEET", ip, port.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYID.js
var require_CLUSTER_MYID = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "MYID"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYSHARDID.js
var require_CLUSTER_MYSHARDID = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "MYSHARDID"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_NODES.js
var require_CLUSTER_NODES = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "NODES"];
  };
  var transformReply = function(reply) {
    const lines = reply.split("\n");
    lines.pop();
    const mastersMap = new Map, replicasMap = new Map;
    for (const line of lines) {
      const [id, address, flags, masterId, pingSent, pongRecv, configEpoch, linkState, ...slots] = line.split(" "), node = {
        id,
        address,
        ...transformNodeAddress(address),
        flags: flags.split(","),
        pingSent: Number(pingSent),
        pongRecv: Number(pongRecv),
        configEpoch: Number(configEpoch),
        linkState
      };
      if (masterId === "-") {
        let replicas = replicasMap.get(id);
        if (!replicas) {
          replicas = [];
          replicasMap.set(id, replicas);
        }
        mastersMap.set(id, {
          ...node,
          slots: slots.map((slot) => {
            const [fromString, toString] = slot.split("-", 2), from = Number(fromString);
            return {
              from,
              to: toString ? Number(toString) : from
            };
          }),
          replicas
        });
      } else {
        const replicas = replicasMap.get(masterId);
        if (!replicas) {
          replicasMap.set(masterId, [node]);
        } else {
          replicas.push(node);
        }
      }
    }
    return [...mastersMap.values()];
  };
  var transformNodeAddress = function(address) {
    const indexOfColon = address.lastIndexOf(":"), indexOfAt = address.indexOf("@", indexOfColon), host = address.substring(0, indexOfColon);
    if (indexOfAt === -1) {
      return {
        host,
        port: Number(address.substring(indexOfColon + 1)),
        cport: null
      };
    }
    return {
      host: address.substring(0, indexOfColon),
      port: Number(address.substring(indexOfColon + 1, indexOfAt)),
      cport: Number(address.substring(indexOfAt + 1))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.RedisClusterNodeLinkStates = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var RedisClusterNodeLinkStates;
  (function(RedisClusterNodeLinkStates2) {
    RedisClusterNodeLinkStates2["CONNECTED"] = "connected";
    RedisClusterNodeLinkStates2["DISCONNECTED"] = "disconnected";
  })(RedisClusterNodeLinkStates || (exports.RedisClusterNodeLinkStates = RedisClusterNodeLinkStates = {}));
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICAS.js
var require_CLUSTER_REPLICAS = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "REPLICAS", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var CLUSTER_NODES_1 = require_CLUSTER_NODES();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return CLUSTER_NODES_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICATE.js
var require_CLUSTER_REPLICATE = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "REPLICATE", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_RESET.js
var require_CLUSTER_RESET = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["CLUSTER", "RESET"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SAVECONFIG.js
var require_CLUSTER_SAVECONFIG = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "SAVECONFIG"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SET-CONFIG-EPOCH.js
var require_CLUSTER_SET_CONFIG_EPOCH = __commonJS((exports) => {
  var transformArguments = function(configEpoch) {
    return ["CLUSTER", "SET-CONFIG-EPOCH", configEpoch.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SETSLOT.js
var require_CLUSTER_SETSLOT = __commonJS((exports) => {
  var transformArguments = function(slot, state, nodeId) {
    const args = ["CLUSTER", "SETSLOT", slot.toString(), state];
    if (nodeId) {
      args.push(nodeId);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.ClusterSlotStates = undefined;
  var ClusterSlotStates;
  (function(ClusterSlotStates2) {
    ClusterSlotStates2["IMPORTING"] = "IMPORTING";
    ClusterSlotStates2["MIGRATING"] = "MIGRATING";
    ClusterSlotStates2["STABLE"] = "STABLE";
    ClusterSlotStates2["NODE"] = "NODE";
  })(ClusterSlotStates || (exports.ClusterSlotStates = ClusterSlotStates = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SLOTS.js
var require_CLUSTER_SLOTS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "SLOTS"];
  };
  var transformReply = function(reply) {
    return reply.map(([from, to, master, ...replicas]) => {
      return {
        from,
        to,
        master: transformNode(master),
        replicas: replicas.map(transformNode)
      };
    });
  };
  var transformNode = function([ip, port, id]) {
    return {
      ip,
      port,
      id
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_COUNT.js
var require_COMMAND_COUNT = __commonJS((exports) => {
  var transformArguments = function() {
    return ["COMMAND", "COUNT"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYS.js
var require_COMMAND_GETKEYS = __commonJS((exports) => {
  var transformArguments = function(args) {
    return ["COMMAND", "GETKEYS", ...args];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYSANDFLAGS.js
var require_COMMAND_GETKEYSANDFLAGS = __commonJS((exports) => {
  var transformArguments = function(args) {
    return ["COMMAND", "GETKEYSANDFLAGS", ...args];
  };
  var transformReply = function(reply) {
    return reply.map(([key, flags]) => ({
      key,
      flags
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_INFO.js
var require_COMMAND_INFO = __commonJS((exports) => {
  var transformArguments = function(commands) {
    return ["COMMAND", "INFO", ...commands];
  };
  var transformReply = function(reply) {
    return reply.map((command) => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_LIST.js
var require_COMMAND_LIST = __commonJS((exports) => {
  var transformArguments = function(filter) {
    const args = ["COMMAND", "LIST"];
    if (filter) {
      args.push("FILTERBY", filter.filterBy, filter.value);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FilterBy = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  var FilterBy;
  (function(FilterBy2) {
    FilterBy2["MODULE"] = "MODULE";
    FilterBy2["ACLCAT"] = "ACLCAT";
    FilterBy2["PATTERN"] = "PATTERN";
  })(FilterBy || (exports.FilterBy = FilterBy = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND.js
var require_COMMAND = __commonJS((exports) => {
  var transformArguments = function() {
    return ["COMMAND"];
  };
  var transformReply = function(reply) {
    return reply.map(generic_transformers_1.transformCommandReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET = __commonJS((exports) => {
  var transformArguments = function(parameter) {
    return ["CONFIG", "GET", parameter];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformTuplesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_RESETSTAT.js
var require_CONFIG_RESETSTAT = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CONFIG", "RESETSTAT"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_REWRITE.js
var require_CONFIG_REWRITE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CONFIG", "REWRITE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET = __commonJS((exports) => {
  var transformArguments = function(...[parameterOrConfig, value26]) {
    const args = ["CONFIG", "SET"];
    if (typeof parameterOrConfig === "string") {
      args.push(parameterOrConfig, value26);
    } else {
      for (const [key, value27] of Object.entries(parameterOrConfig)) {
        args.push(key, value27);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DBSIZE.js
var require_DBSIZE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["DBSIZE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DISCARD.js
var require_DISCARD = __commonJS((exports) => {
  var transformArguments = function() {
    return ["DISCARD"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ECHO.js
var require_ECHO = __commonJS((exports) => {
  var transformArguments = function(message) {
    return ["ECHO", message];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FAILOVER.js
var require_FAILOVER = __commonJS((exports) => {
  var transformArguments = function(options) {
    const args = ["FAILOVER"];
    if (options?.TO) {
      args.push("TO", options.TO.host, options.TO.port.toString());
      if (options.TO.FORCE) {
        args.push("FORCE");
      }
    }
    if (options?.ABORT) {
      args.push("ABORT");
    }
    if (options?.TIMEOUT) {
      args.push("TIMEOUT", options.TIMEOUT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FLUSHALL.js
var require_FLUSHALL = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["FLUSHALL"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.RedisFlushModes = undefined;
  var RedisFlushModes;
  (function(RedisFlushModes2) {
    RedisFlushModes2["ASYNC"] = "ASYNC";
    RedisFlushModes2["SYNC"] = "SYNC";
  })(RedisFlushModes || (exports.RedisFlushModes = RedisFlushModes = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FLUSHDB.js
var require_FLUSHDB = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["FLUSHDB"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DELETE.js
var require_FUNCTION_DELETE = __commonJS((exports) => {
  var transformArguments = function(library) {
    return ["FUNCTION", "DELETE", library];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DUMP.js
var require_FUNCTION_DUMP = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FUNCTION", "DUMP"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_FLUSH.js
var require_FUNCTION_FLUSH = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["FUNCTION", "FLUSH"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_KILL.js
var require_FUNCTION_KILL = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FUNCTION", "KILL"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST.js
var require_FUNCTION_LIST = __commonJS((exports) => {
  var transformArguments = function(pattern2) {
    const args = ["FUNCTION", "LIST"];
    if (pattern2) {
      args.push(pattern2);
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply.map(generic_transformers_1.transformFunctionListItemReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST_WITHCODE.js
var require_FUNCTION_LIST_WITHCODE = __commonJS((exports) => {
  var transformArguments = function(pattern2) {
    const args = (0, FUNCTION_LIST_1.transformArguments)(pattern2);
    args.push("WITHCODE");
    return args;
  };
  var transformReply = function(reply) {
    return reply.map((library) => ({
      ...(0, generic_transformers_1.transformFunctionListItemReply)(library),
      libraryCode: library[7]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var FUNCTION_LIST_1 = require_FUNCTION_LIST();
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LOAD.js
var require_FUNCTION_LOAD = __commonJS((exports) => {
  var transformArguments = function(code, options) {
    const args = ["FUNCTION", "LOAD"];
    if (options?.REPLACE) {
      args.push("REPLACE");
    }
    args.push(code);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_RESTORE.js
var require_FUNCTION_RESTORE = __commonJS((exports) => {
  var transformArguments = function(dump, mode) {
    const args = ["FUNCTION", "RESTORE", dump];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_STATS.js
var require_FUNCTION_STATS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FUNCTION", "STATS"];
  };
  var transformReply = function(reply) {
    const engines = Object.create(null);
    for (let i = 0;i < reply[3].length; i++) {
      engines[reply[3][i]] = {
        librariesCount: reply[3][++i][1],
        functionsCount: reply[3][i][3]
      };
    }
    return {
      runningScript: reply[1] === null ? null : {
        name: reply[1][1],
        command: reply[1][3],
        durationMs: reply[1][5]
      },
      engines
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/HELLO.js
var require_HELLO = __commonJS((exports) => {
  var transformArguments = function(options) {
    const args = ["HELLO"];
    if (options) {
      args.push(options.protover.toString());
      if (options.auth) {
        args.push("AUTH", options.auth.username, options.auth.password);
      }
      if (options.clientName) {
        args.push("SETNAME", options.clientName);
      }
    }
    return args;
  };
  var transformReply = function(reply) {
    return {
      server: reply[1],
      version: reply[3],
      proto: reply[5],
      id: reply[7],
      mode: reply[9],
      role: reply[11],
      modules: reply[13]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/INFO.js
var require_INFO = __commonJS((exports) => {
  var transformArguments = function(section) {
    const args = ["INFO"];
    if (section) {
      args.push(section);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/KEYS.js
var require_KEYS = __commonJS((exports) => {
  var transformArguments = function(pattern2) {
    return ["KEYS", pattern2];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LASTSAVE.js
var require_LASTSAVE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["LASTSAVE"];
  };
  var transformReply = function(reply) {
    return new Date(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_DOCTOR.js
var require_LATENCY_DOCTOR = __commonJS((exports) => {
  var transformArguments = function() {
    return ["LATENCY", "DOCTOR"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_GRAPH.js
var require_LATENCY_GRAPH = __commonJS((exports) => {
  var transformArguments = function(event) {
    return ["LATENCY", "GRAPH", event];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_HISTORY.js
var require_LATENCY_HISTORY = __commonJS((exports) => {
  var transformArguments = function(event) {
    return ["LATENCY", "HISTORY", event];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_LATEST.js
var require_LATENCY_LATEST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["LATENCY", "LATEST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LOLWUT.js
var require_LOLWUT = __commonJS((exports) => {
  var transformArguments = function(version2, ...optionalArguments) {
    const args = ["LOLWUT"];
    if (version2) {
      args.push("VERSION", version2.toString(), ...optionalArguments.map(String));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_DOCTOR.js
var require_MEMORY_DOCTOR = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "DOCTOR"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_MALLOC-STATS.js
var require_MEMORY_MALLOC_STATS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "MALLOC-STATS"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_PURGE.js
var require_MEMORY_PURGE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "PURGE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_STATS.js
var require_MEMORY_STATS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "STATS"];
  };
  var transformReply = function(rawReply) {
    const reply = {
      db: {}
    };
    for (let i = 0;i < rawReply.length; i += 2) {
      const key = rawReply[i];
      if (key.startsWith("db.")) {
        const dbTuples = rawReply[i + 1], db = {};
        for (let j = 0;j < dbTuples.length; j += 2) {
          db[DB_FIELDS_MAPPING[dbTuples[j]]] = dbTuples[j + 1];
        }
        reply.db[key.substring(3)] = db;
        continue;
      }
      reply[FIELDS_MAPPING[key]] = Number(rawReply[i + 1]);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var FIELDS_MAPPING = {
    "peak.allocated": "peakAllocated",
    "total.allocated": "totalAllocated",
    "startup.allocated": "startupAllocated",
    "replication.backlog": "replicationBacklog",
    "clients.slaves": "clientsReplicas",
    "clients.normal": "clientsNormal",
    "aof.buffer": "aofBuffer",
    "lua.caches": "luaCaches",
    "overhead.total": "overheadTotal",
    "keys.count": "keysCount",
    "keys.bytes-per-key": "keysBytesPerKey",
    "dataset.bytes": "datasetBytes",
    "dataset.percentage": "datasetPercentage",
    "peak.percentage": "peakPercentage",
    "allocator.allocated": "allocatorAllocated",
    "allocator.active": "allocatorActive",
    "allocator.resident": "allocatorResident",
    "allocator-fragmentation.ratio": "allocatorFragmentationRatio",
    "allocator-fragmentation.bytes": "allocatorFragmentationBytes",
    "allocator-rss.ratio": "allocatorRssRatio",
    "allocator-rss.bytes": "allocatorRssBytes",
    "rss-overhead.ratio": "rssOverheadRatio",
    "rss-overhead.bytes": "rssOverheadBytes",
    fragmentation: "fragmentation",
    "fragmentation.bytes": "fragmentationBytes"
  };
  var DB_FIELDS_MAPPING = {
    "overhead.hashtable.main": "overheadHashtableMain",
    "overhead.hashtable.expires": "overheadHashtableExpires"
  };
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_USAGE.js
var require_MEMORY_USAGE = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    const args = ["MEMORY", "USAGE", key];
    if (options?.SAMPLES) {
      args.push("SAMPLES", options.SAMPLES.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LIST.js
var require_MODULE_LIST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MODULE", "LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LOAD.js
var require_MODULE_LOAD = __commonJS((exports) => {
  var transformArguments = function(path, moduleArgs) {
    const args = ["MODULE", "LOAD", path];
    if (moduleArgs) {
      args.push(...moduleArgs);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MODULE_UNLOAD.js
var require_MODULE_UNLOAD = __commonJS((exports) => {
  var transformArguments = function(name) {
    return ["MODULE", "UNLOAD", name];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MOVE.js
var require_MOVE = __commonJS((exports) => {
  var transformArguments = function(key, db) {
    return ["MOVE", key, db.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PING.js
var require_PING = __commonJS((exports) => {
  var transformArguments = function(message) {
    const args = ["PING"];
    if (message) {
      args.push(message);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_CHANNELS.js
var require_PUBSUB_CHANNELS = __commonJS((exports) => {
  var transformArguments = function(pattern2) {
    const args = ["PUBSUB", "CHANNELS"];
    if (pattern2) {
      args.push(pattern2);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMPAT.js
var require_PUBSUB_NUMPAT = __commonJS((exports) => {
  var transformArguments = function() {
    return ["PUBSUB", "NUMPAT"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMSUB.js
var require_PUBSUB_NUMSUB = __commonJS((exports) => {
  var transformArguments = function(channels) {
    const args = ["PUBSUB", "NUMSUB"];
    if (channels)
      return (0, generic_transformers_1.pushVerdictArguments)(args, channels);
    return args;
  };
  var transformReply = function(rawReply) {
    const transformedReply = Object.create(null);
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply[rawReply[i]] = rawReply[i + 1];
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDCHANNELS.js
var require_PUBSUB_SHARDCHANNELS = __commonJS((exports) => {
  var transformArguments = function(pattern2) {
    const args = ["PUBSUB", "SHARDCHANNELS"];
    if (pattern2)
      args.push(pattern2);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDNUMSUB.js
var require_PUBSUB_SHARDNUMSUB = __commonJS((exports) => {
  var transformArguments = function(channels) {
    const args = ["PUBSUB", "SHARDNUMSUB"];
    if (channels)
      return (0, generic_transformers_1.pushVerdictArguments)(args, channels);
    return args;
  };
  var transformReply = function(rawReply) {
    const transformedReply = Object.create(null);
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply[rawReply[i]] = rawReply[i + 1];
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/RANDOMKEY.js
var require_RANDOMKEY = __commonJS((exports) => {
  var transformArguments = function() {
    return ["RANDOMKEY"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/READONLY.js
var require_READONLY = __commonJS((exports) => {
  var transformArguments = function() {
    return ["READONLY"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/READWRITE.js
var require_READWRITE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["READWRITE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/REPLICAOF.js
var require_REPLICAOF = __commonJS((exports) => {
  var transformArguments = function(host, port) {
    return ["REPLICAOF", host, port.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RESTORE-ASKING.js
var require_RESTORE_ASKING = __commonJS((exports) => {
  var transformArguments = function() {
    return ["RESTORE-ASKING"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ROLE.js
var require_ROLE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ROLE"];
  };
  var transformReply = function(reply) {
    switch (reply[0]) {
      case "master":
        return {
          role: "master",
          replicationOffest: reply[1],
          replicas: reply[2].map(([ip, port, replicationOffest]) => ({
            ip,
            port: Number(port),
            replicationOffest: Number(replicationOffest)
          }))
        };
      case "slave":
        return {
          role: "slave",
          master: {
            ip: reply[1],
            port: reply[2]
          },
          state: reply[3],
          dataReceived: reply[4]
        };
      case "sentinel":
        return {
          role: "sentinel",
          masterNames: reply[1]
        };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/SAVE.js
var require_SAVE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["SAVE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCAN.js
var require_SCAN = __commonJS((exports) => {
  var transformArguments = function(cursor, options) {
    const args = (0, generic_transformers_1.pushScanArguments)(["SCAN"], cursor, options);
    if (options?.TYPE) {
      args.push("TYPE", options.TYPE);
    }
    return args;
  };
  var transformReply = function([cursor, keys]) {
    return {
      cursor: Number(cursor),
      keys
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_DEBUG.js
var require_SCRIPT_DEBUG = __commonJS((exports) => {
  var transformArguments = function(mode) {
    return ["SCRIPT", "DEBUG", mode];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_EXISTS.js
var require_SCRIPT_EXISTS = __commonJS((exports) => {
  var transformArguments = function(sha1) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SCRIPT", "EXISTS"], sha1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_FLUSH.js
var require_SCRIPT_FLUSH = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["SCRIPT", "FLUSH"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_KILL.js
var require_SCRIPT_KILL = __commonJS((exports) => {
  var transformArguments = function() {
    return ["SCRIPT", "KILL"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_LOAD.js
var require_SCRIPT_LOAD = __commonJS((exports) => {
  var transformArguments = function(script) {
    return ["SCRIPT", "LOAD", script];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SHUTDOWN.js
var require_SHUTDOWN = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["SHUTDOWN"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SWAPDB.js
var require_SWAPDB = __commonJS((exports) => {
  var transformArguments = function(index1, index2) {
    return ["SWAPDB", index1.toString(), index2.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TIME.js
var require_TIME = __commonJS((exports) => {
  var transformArguments = function() {
    return ["TIME"];
  };
  var transformReply = function(reply) {
    const seconds = Number(reply[0]), microseconds = Number(reply[1]), d = new Date(seconds * 1000 + microseconds / 1000);
    d.microseconds = microseconds;
    return d;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/UNWATCH.js
var require_UNWATCH = __commonJS((exports) => {
  var transformArguments = function() {
    return ["UNWATCH"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/WAIT.js
var require_WAIT = __commonJS((exports) => {
  var transformArguments = function(numberOfReplicas, timeout) {
    return ["WAIT", numberOfReplicas.toString(), timeout.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/client/commands.js
var require_commands2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands();
  var ACL_CAT = require_ACL_CAT();
  var ACL_DELUSER = require_ACL_DELUSER();
  var ACL_DRYRUN = require_ACL_DRYRUN();
  var ACL_GENPASS = require_ACL_GENPASS();
  var ACL_GETUSER = require_ACL_GETUSER();
  var ACL_LIST = require_ACL_LIST();
  var ACL_LOAD = require_ACL_LOAD();
  var ACL_LOG_RESET = require_ACL_LOG_RESET();
  var ACL_LOG = require_ACL_LOG();
  var ACL_SAVE = require_ACL_SAVE();
  var ACL_SETUSER = require_ACL_SETUSER();
  var ACL_USERS = require_ACL_USERS();
  var ACL_WHOAMI = require_ACL_WHOAMI();
  var ASKING = require_ASKING();
  var AUTH = require_AUTH();
  var BGREWRITEAOF = require_BGREWRITEAOF();
  var BGSAVE = require_BGSAVE();
  var CLIENT_CACHING = require_CLIENT_CACHING();
  var CLIENT_GETNAME = require_CLIENT_GETNAME();
  var CLIENT_GETREDIR = require_CLIENT_GETREDIR();
  var CLIENT_ID = require_CLIENT_ID();
  var CLIENT_KILL = require_CLIENT_KILL();
  var CLIENT_LIST = require_CLIENT_LIST();
  var CLIENT_NO_EVICT = require_CLIENT_NO_EVICT();
  var CLIENT_NO_TOUCH = require_CLIENT_NO_TOUCH();
  var CLIENT_PAUSE = require_CLIENT_PAUSE();
  var CLIENT_SETNAME = require_CLIENT_SETNAME();
  var CLIENT_TRACKING = require_CLIENT_TRACKING();
  var CLIENT_TRACKINGINFO = require_CLIENT_TRACKINGINFO();
  var CLIENT_UNPAUSE = require_CLIENT_UNPAUSE();
  var CLIENT_INFO = require_CLIENT_INFO();
  var CLUSTER_ADDSLOTS = require_CLUSTER_ADDSLOTS();
  var CLUSTER_ADDSLOTSRANGE = require_CLUSTER_ADDSLOTSRANGE();
  var CLUSTER_BUMPEPOCH = require_CLUSTER_BUMPEPOCH();
  var CLUSTER_COUNT_FAILURE_REPORTS = require_CLUSTER_COUNT_FAILURE_REPORTS();
  var CLUSTER_COUNTKEYSINSLOT = require_CLUSTER_COUNTKEYSINSLOT();
  var CLUSTER_DELSLOTS = require_CLUSTER_DELSLOTS();
  var CLUSTER_DELSLOTSRANGE = require_CLUSTER_DELSLOTSRANGE();
  var CLUSTER_FAILOVER = require_CLUSTER_FAILOVER();
  var CLUSTER_FLUSHSLOTS = require_CLUSTER_FLUSHSLOTS();
  var CLUSTER_FORGET = require_CLUSTER_FORGET();
  var CLUSTER_GETKEYSINSLOT = require_CLUSTER_GETKEYSINSLOT();
  var CLUSTER_INFO = require_CLUSTER_INFO();
  var CLUSTER_KEYSLOT = require_CLUSTER_KEYSLOT();
  var CLUSTER_LINKS = require_CLUSTER_LINKS();
  var CLUSTER_MEET = require_CLUSTER_MEET();
  var CLUSTER_MYID = require_CLUSTER_MYID();
  var CLUSTER_MYSHARDID = require_CLUSTER_MYSHARDID();
  var CLUSTER_NODES = require_CLUSTER_NODES();
  var CLUSTER_REPLICAS = require_CLUSTER_REPLICAS();
  var CLUSTER_REPLICATE = require_CLUSTER_REPLICATE();
  var CLUSTER_RESET = require_CLUSTER_RESET();
  var CLUSTER_SAVECONFIG = require_CLUSTER_SAVECONFIG();
  var CLUSTER_SET_CONFIG_EPOCH = require_CLUSTER_SET_CONFIG_EPOCH();
  var CLUSTER_SETSLOT = require_CLUSTER_SETSLOT();
  var CLUSTER_SLOTS = require_CLUSTER_SLOTS();
  var COMMAND_COUNT = require_COMMAND_COUNT();
  var COMMAND_GETKEYS = require_COMMAND_GETKEYS();
  var COMMAND_GETKEYSANDFLAGS = require_COMMAND_GETKEYSANDFLAGS();
  var COMMAND_INFO = require_COMMAND_INFO();
  var COMMAND_LIST = require_COMMAND_LIST();
  var COMMAND = require_COMMAND();
  var CONFIG_GET = require_CONFIG_GET();
  var CONFIG_RESETASTAT = require_CONFIG_RESETSTAT();
  var CONFIG_REWRITE = require_CONFIG_REWRITE();
  var CONFIG_SET = require_CONFIG_SET();
  var DBSIZE = require_DBSIZE();
  var DISCARD = require_DISCARD();
  var ECHO = require_ECHO();
  var FAILOVER = require_FAILOVER();
  var FLUSHALL = require_FLUSHALL();
  var FLUSHDB = require_FLUSHDB();
  var FUNCTION_DELETE = require_FUNCTION_DELETE();
  var FUNCTION_DUMP = require_FUNCTION_DUMP();
  var FUNCTION_FLUSH = require_FUNCTION_FLUSH();
  var FUNCTION_KILL = require_FUNCTION_KILL();
  var FUNCTION_LIST_WITHCODE = require_FUNCTION_LIST_WITHCODE();
  var FUNCTION_LIST = require_FUNCTION_LIST();
  var FUNCTION_LOAD = require_FUNCTION_LOAD();
  var FUNCTION_RESTORE = require_FUNCTION_RESTORE();
  var FUNCTION_STATS = require_FUNCTION_STATS();
  var HELLO = require_HELLO();
  var INFO = require_INFO();
  var KEYS = require_KEYS();
  var LASTSAVE = require_LASTSAVE();
  var LATENCY_DOCTOR = require_LATENCY_DOCTOR();
  var LATENCY_GRAPH = require_LATENCY_GRAPH();
  var LATENCY_HISTORY = require_LATENCY_HISTORY();
  var LATENCY_LATEST = require_LATENCY_LATEST();
  var LOLWUT = require_LOLWUT();
  var MEMORY_DOCTOR = require_MEMORY_DOCTOR();
  var MEMORY_MALLOC_STATS = require_MEMORY_MALLOC_STATS();
  var MEMORY_PURGE = require_MEMORY_PURGE();
  var MEMORY_STATS = require_MEMORY_STATS();
  var MEMORY_USAGE = require_MEMORY_USAGE();
  var MODULE_LIST = require_MODULE_LIST();
  var MODULE_LOAD = require_MODULE_LOAD();
  var MODULE_UNLOAD = require_MODULE_UNLOAD();
  var MOVE = require_MOVE();
  var PING = require_PING();
  var PUBSUB_CHANNELS = require_PUBSUB_CHANNELS();
  var PUBSUB_NUMPAT = require_PUBSUB_NUMPAT();
  var PUBSUB_NUMSUB = require_PUBSUB_NUMSUB();
  var PUBSUB_SHARDCHANNELS = require_PUBSUB_SHARDCHANNELS();
  var PUBSUB_SHARDNUMSUB = require_PUBSUB_SHARDNUMSUB();
  var RANDOMKEY = require_RANDOMKEY();
  var READONLY = require_READONLY();
  var READWRITE = require_READWRITE();
  var REPLICAOF = require_REPLICAOF();
  var RESTORE_ASKING = require_RESTORE_ASKING();
  var ROLE = require_ROLE();
  var SAVE = require_SAVE();
  var SCAN = require_SCAN();
  var SCRIPT_DEBUG = require_SCRIPT_DEBUG();
  var SCRIPT_EXISTS = require_SCRIPT_EXISTS();
  var SCRIPT_FLUSH = require_SCRIPT_FLUSH();
  var SCRIPT_KILL = require_SCRIPT_KILL();
  var SCRIPT_LOAD = require_SCRIPT_LOAD();
  var SHUTDOWN = require_SHUTDOWN();
  var SWAPDB = require_SWAPDB();
  var TIME2 = require_TIME();
  var UNWATCH = require_UNWATCH();
  var WAIT = require_WAIT();
  exports.default = {
    ...commands_1.default,
    ACL_CAT,
    aclCat: ACL_CAT,
    ACL_DELUSER,
    aclDelUser: ACL_DELUSER,
    ACL_DRYRUN,
    aclDryRun: ACL_DRYRUN,
    ACL_GENPASS,
    aclGenPass: ACL_GENPASS,
    ACL_GETUSER,
    aclGetUser: ACL_GETUSER,
    ACL_LIST,
    aclList: ACL_LIST,
    ACL_LOAD,
    aclLoad: ACL_LOAD,
    ACL_LOG_RESET,
    aclLogReset: ACL_LOG_RESET,
    ACL_LOG,
    aclLog: ACL_LOG,
    ACL_SAVE,
    aclSave: ACL_SAVE,
    ACL_SETUSER,
    aclSetUser: ACL_SETUSER,
    ACL_USERS,
    aclUsers: ACL_USERS,
    ACL_WHOAMI,
    aclWhoAmI: ACL_WHOAMI,
    ASKING,
    asking: ASKING,
    AUTH,
    auth: AUTH,
    BGREWRITEAOF,
    bgRewriteAof: BGREWRITEAOF,
    BGSAVE,
    bgSave: BGSAVE,
    CLIENT_CACHING,
    clientCaching: CLIENT_CACHING,
    CLIENT_GETNAME,
    clientGetName: CLIENT_GETNAME,
    CLIENT_GETREDIR,
    clientGetRedir: CLIENT_GETREDIR,
    CLIENT_ID,
    clientId: CLIENT_ID,
    CLIENT_KILL,
    clientKill: CLIENT_KILL,
    "CLIENT_NO-EVICT": CLIENT_NO_EVICT,
    clientNoEvict: CLIENT_NO_EVICT,
    "CLIENT_NO-TOUCH": CLIENT_NO_TOUCH,
    clientNoTouch: CLIENT_NO_TOUCH,
    CLIENT_LIST,
    clientList: CLIENT_LIST,
    CLIENT_PAUSE,
    clientPause: CLIENT_PAUSE,
    CLIENT_SETNAME,
    clientSetName: CLIENT_SETNAME,
    CLIENT_TRACKING,
    clientTracking: CLIENT_TRACKING,
    CLIENT_TRACKINGINFO,
    clientTrackingInfo: CLIENT_TRACKINGINFO,
    CLIENT_UNPAUSE,
    clientUnpause: CLIENT_UNPAUSE,
    CLIENT_INFO,
    clientInfo: CLIENT_INFO,
    CLUSTER_ADDSLOTS,
    clusterAddSlots: CLUSTER_ADDSLOTS,
    CLUSTER_ADDSLOTSRANGE,
    clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE,
    CLUSTER_BUMPEPOCH,
    clusterBumpEpoch: CLUSTER_BUMPEPOCH,
    CLUSTER_COUNT_FAILURE_REPORTS,
    clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS,
    CLUSTER_COUNTKEYSINSLOT,
    clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT,
    CLUSTER_DELSLOTS,
    clusterDelSlots: CLUSTER_DELSLOTS,
    CLUSTER_DELSLOTSRANGE,
    clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE,
    CLUSTER_FAILOVER,
    clusterFailover: CLUSTER_FAILOVER,
    CLUSTER_FLUSHSLOTS,
    clusterFlushSlots: CLUSTER_FLUSHSLOTS,
    CLUSTER_FORGET,
    clusterForget: CLUSTER_FORGET,
    CLUSTER_GETKEYSINSLOT,
    clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT,
    CLUSTER_INFO,
    clusterInfo: CLUSTER_INFO,
    CLUSTER_KEYSLOT,
    clusterKeySlot: CLUSTER_KEYSLOT,
    CLUSTER_LINKS,
    clusterLinks: CLUSTER_LINKS,
    CLUSTER_MEET,
    clusterMeet: CLUSTER_MEET,
    CLUSTER_MYID,
    clusterMyId: CLUSTER_MYID,
    CLUSTER_MYSHARDID,
    clusterMyShardId: CLUSTER_MYSHARDID,
    CLUSTER_NODES,
    clusterNodes: CLUSTER_NODES,
    CLUSTER_REPLICAS,
    clusterReplicas: CLUSTER_REPLICAS,
    CLUSTER_REPLICATE,
    clusterReplicate: CLUSTER_REPLICATE,
    CLUSTER_RESET,
    clusterReset: CLUSTER_RESET,
    CLUSTER_SAVECONFIG,
    clusterSaveConfig: CLUSTER_SAVECONFIG,
    CLUSTER_SET_CONFIG_EPOCH,
    clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH,
    CLUSTER_SETSLOT,
    clusterSetSlot: CLUSTER_SETSLOT,
    CLUSTER_SLOTS,
    clusterSlots: CLUSTER_SLOTS,
    COMMAND_COUNT,
    commandCount: COMMAND_COUNT,
    COMMAND_GETKEYS,
    commandGetKeys: COMMAND_GETKEYS,
    COMMAND_GETKEYSANDFLAGS,
    commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS,
    COMMAND_INFO,
    commandInfo: COMMAND_INFO,
    COMMAND_LIST,
    commandList: COMMAND_LIST,
    COMMAND,
    command: COMMAND,
    CONFIG_GET,
    configGet: CONFIG_GET,
    CONFIG_RESETASTAT,
    configResetStat: CONFIG_RESETASTAT,
    CONFIG_REWRITE,
    configRewrite: CONFIG_REWRITE,
    CONFIG_SET,
    configSet: CONFIG_SET,
    DBSIZE,
    dbSize: DBSIZE,
    DISCARD,
    discard: DISCARD,
    ECHO,
    echo: ECHO,
    FAILOVER,
    failover: FAILOVER,
    FLUSHALL,
    flushAll: FLUSHALL,
    FLUSHDB,
    flushDb: FLUSHDB,
    FUNCTION_DELETE,
    functionDelete: FUNCTION_DELETE,
    FUNCTION_DUMP,
    functionDump: FUNCTION_DUMP,
    FUNCTION_FLUSH,
    functionFlush: FUNCTION_FLUSH,
    FUNCTION_KILL,
    functionKill: FUNCTION_KILL,
    FUNCTION_LIST_WITHCODE,
    functionListWithCode: FUNCTION_LIST_WITHCODE,
    FUNCTION_LIST,
    functionList: FUNCTION_LIST,
    FUNCTION_LOAD,
    functionLoad: FUNCTION_LOAD,
    FUNCTION_RESTORE,
    functionRestore: FUNCTION_RESTORE,
    FUNCTION_STATS,
    functionStats: FUNCTION_STATS,
    HELLO,
    hello: HELLO,
    INFO,
    info: INFO,
    KEYS,
    keys: KEYS,
    LASTSAVE,
    lastSave: LASTSAVE,
    LATENCY_DOCTOR,
    latencyDoctor: LATENCY_DOCTOR,
    LATENCY_GRAPH,
    latencyGraph: LATENCY_GRAPH,
    LATENCY_HISTORY,
    latencyHistory: LATENCY_HISTORY,
    LATENCY_LATEST,
    latencyLatest: LATENCY_LATEST,
    LOLWUT,
    lolwut: LOLWUT,
    MEMORY_DOCTOR,
    memoryDoctor: MEMORY_DOCTOR,
    "MEMORY_MALLOC-STATS": MEMORY_MALLOC_STATS,
    memoryMallocStats: MEMORY_MALLOC_STATS,
    MEMORY_PURGE,
    memoryPurge: MEMORY_PURGE,
    MEMORY_STATS,
    memoryStats: MEMORY_STATS,
    MEMORY_USAGE,
    memoryUsage: MEMORY_USAGE,
    MODULE_LIST,
    moduleList: MODULE_LIST,
    MODULE_LOAD,
    moduleLoad: MODULE_LOAD,
    MODULE_UNLOAD,
    moduleUnload: MODULE_UNLOAD,
    MOVE,
    move: MOVE,
    PING,
    ping: PING,
    PUBSUB_CHANNELS,
    pubSubChannels: PUBSUB_CHANNELS,
    PUBSUB_NUMPAT,
    pubSubNumPat: PUBSUB_NUMPAT,
    PUBSUB_NUMSUB,
    pubSubNumSub: PUBSUB_NUMSUB,
    PUBSUB_SHARDCHANNELS,
    pubSubShardChannels: PUBSUB_SHARDCHANNELS,
    PUBSUB_SHARDNUMSUB,
    pubSubShardNumSub: PUBSUB_SHARDNUMSUB,
    RANDOMKEY,
    randomKey: RANDOMKEY,
    READONLY,
    readonly: READONLY,
    READWRITE,
    readwrite: READWRITE,
    REPLICAOF,
    replicaOf: REPLICAOF,
    "RESTORE-ASKING": RESTORE_ASKING,
    restoreAsking: RESTORE_ASKING,
    ROLE,
    role: ROLE,
    SAVE,
    save: SAVE,
    SCAN,
    scan: SCAN,
    SCRIPT_DEBUG,
    scriptDebug: SCRIPT_DEBUG,
    SCRIPT_EXISTS,
    scriptExists: SCRIPT_EXISTS,
    SCRIPT_FLUSH,
    scriptFlush: SCRIPT_FLUSH,
    SCRIPT_KILL,
    scriptKill: SCRIPT_KILL,
    SCRIPT_LOAD,
    scriptLoad: SCRIPT_LOAD,
    SHUTDOWN,
    shutdown: SHUTDOWN,
    SWAPDB,
    swapDb: SWAPDB,
    TIME: TIME2,
    time: TIME2,
    UNWATCH,
    unwatch: UNWATCH,
    WAIT,
    wait: WAIT
  };
});

// node_modules/@redis/client/dist/lib/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiErrorReply = exports.ErrorReply = exports.ReconnectStrategyError = exports.RootNodesUnavailableError = exports.SocketClosedUnexpectedlyError = exports.DisconnectsClientError = exports.ClientOfflineError = exports.ClientClosedError = exports.ConnectionTimeoutError = exports.WatchError = exports.AbortError = undefined;

  class AbortError2 extends Error {
    constructor() {
      super("The command was aborted");
    }
  }
  exports.AbortError = AbortError2;

  class WatchError extends Error {
    constructor() {
      super("One (or more) of the watched keys has been changed");
    }
  }
  exports.WatchError = WatchError;

  class ConnectionTimeoutError extends Error {
    constructor() {
      super("Connection timeout");
    }
  }
  exports.ConnectionTimeoutError = ConnectionTimeoutError;

  class ClientClosedError extends Error {
    constructor() {
      super("The client is closed");
    }
  }
  exports.ClientClosedError = ClientClosedError;

  class ClientOfflineError extends Error {
    constructor() {
      super("The client is offline");
    }
  }
  exports.ClientOfflineError = ClientOfflineError;

  class DisconnectsClientError extends Error {
    constructor() {
      super("Disconnects client");
    }
  }
  exports.DisconnectsClientError = DisconnectsClientError;

  class SocketClosedUnexpectedlyError extends Error {
    constructor() {
      super("Socket closed unexpectedly");
    }
  }
  exports.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;

  class RootNodesUnavailableError extends Error {
    constructor() {
      super("All the root nodes are unavailable");
    }
  }
  exports.RootNodesUnavailableError = RootNodesUnavailableError;

  class ReconnectStrategyError extends Error {
    constructor(originalError, socketError) {
      super(originalError.message);
      Object.defineProperty(this, "originalError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "socketError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.originalError = originalError;
      this.socketError = socketError;
    }
  }
  exports.ReconnectStrategyError = ReconnectStrategyError;

  class ErrorReply extends Error {
    constructor(message) {
      super(message);
      this.stack = undefined;
    }
  }
  exports.ErrorReply = ErrorReply;

  class MultiErrorReply extends ErrorReply {
    constructor(replies, errorIndexes) {
      super(`${errorIndexes.length} commands failed, see .replies and .errorIndexes for more information`);
      Object.defineProperty(this, "replies", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "errorIndexes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.replies = replies;
      this.errorIndexes = errorIndexes;
    }
    *errors() {
      for (const index of this.errorIndexes) {
        yield this.replies[index];
      }
    }
  }
  exports.MultiErrorReply = MultiErrorReply;
});

// node_modules/@redis/client/dist/lib/utils.js
var require_utils3 = __commonJS((exports) => {
  var promiseTimeout = function(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.promiseTimeout = undefined;
  exports.promiseTimeout = promiseTimeout;
});

// node_modules/@redis/client/dist/lib/client/socket.js
var require_socket = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var _RedisSocket_instances;
  var _a2;
  var _RedisSocket_initiateOptions;
  var _RedisSocket_isTlsSocket;
  var _RedisSocket_initiator;
  var _RedisSocket_options;
  var _RedisSocket_socket;
  var _RedisSocket_isOpen;
  var _RedisSocket_isReady;
  var _RedisSocket_writableNeedDrain;
  var _RedisSocket_isSocketUnrefed;
  var _RedisSocket_reconnectStrategy;
  var _RedisSocket_shouldReconnect;
  var _RedisSocket_connect;
  var _RedisSocket_createSocket;
  var _RedisSocket_createNetSocket;
  var _RedisSocket_createTlsSocket;
  var _RedisSocket_onSocketError;
  var _RedisSocket_disconnect;
  var _RedisSocket_isCorked;
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = import.meta.require("events");
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var errors_1 = require_errors3();
  var utils_1 = require_utils3();

  class RedisSocket extends events_1.EventEmitter {
    get isOpen() {
      return __classPrivateFieldGet2(this, _RedisSocket_isOpen, "f");
    }
    get isReady() {
      return __classPrivateFieldGet2(this, _RedisSocket_isReady, "f");
    }
    get writableNeedDrain() {
      return __classPrivateFieldGet2(this, _RedisSocket_writableNeedDrain, "f");
    }
    constructor(initiator, options) {
      super();
      _RedisSocket_instances.add(this);
      _RedisSocket_initiator.set(this, undefined);
      _RedisSocket_options.set(this, undefined);
      _RedisSocket_socket.set(this, undefined);
      _RedisSocket_isOpen.set(this, false);
      _RedisSocket_isReady.set(this, false);
      _RedisSocket_writableNeedDrain.set(this, false);
      _RedisSocket_isSocketUnrefed.set(this, false);
      _RedisSocket_isCorked.set(this, false);
      __classPrivateFieldSet2(this, _RedisSocket_initiator, initiator, "f");
      __classPrivateFieldSet2(this, _RedisSocket_options, __classPrivateFieldGet2(_a2, _a2, "m", _RedisSocket_initiateOptions).call(_a2, options), "f");
    }
    async connect() {
      if (__classPrivateFieldGet2(this, _RedisSocket_isOpen, "f")) {
        throw new Error("Socket already opened");
      }
      __classPrivateFieldSet2(this, _RedisSocket_isOpen, true, "f");
      return __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_connect).call(this);
    }
    writeCommand(args) {
      if (!__classPrivateFieldGet2(this, _RedisSocket_socket, "f")) {
        throw new errors_1.ClientClosedError;
      }
      for (const toWrite of args) {
        __classPrivateFieldSet2(this, _RedisSocket_writableNeedDrain, !__classPrivateFieldGet2(this, _RedisSocket_socket, "f").write(toWrite), "f");
      }
    }
    disconnect() {
      if (!__classPrivateFieldGet2(this, _RedisSocket_isOpen, "f")) {
        throw new errors_1.ClientClosedError;
      }
      __classPrivateFieldSet2(this, _RedisSocket_isOpen, false, "f");
      __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_disconnect).call(this);
    }
    async quit(fn) {
      if (!__classPrivateFieldGet2(this, _RedisSocket_isOpen, "f")) {
        throw new errors_1.ClientClosedError;
      }
      __classPrivateFieldSet2(this, _RedisSocket_isOpen, false, "f");
      const reply = await fn();
      __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_disconnect).call(this);
      return reply;
    }
    cork() {
      if (!__classPrivateFieldGet2(this, _RedisSocket_socket, "f") || __classPrivateFieldGet2(this, _RedisSocket_isCorked, "f")) {
        return;
      }
      __classPrivateFieldGet2(this, _RedisSocket_socket, "f").cork();
      __classPrivateFieldSet2(this, _RedisSocket_isCorked, true, "f");
      setImmediate(() => {
        __classPrivateFieldGet2(this, _RedisSocket_socket, "f")?.uncork();
        __classPrivateFieldSet2(this, _RedisSocket_isCorked, false, "f");
      });
    }
    ref() {
      __classPrivateFieldSet2(this, _RedisSocket_isSocketUnrefed, false, "f");
      __classPrivateFieldGet2(this, _RedisSocket_socket, "f")?.ref();
    }
    unref() {
      __classPrivateFieldSet2(this, _RedisSocket_isSocketUnrefed, true, "f");
      __classPrivateFieldGet2(this, _RedisSocket_socket, "f")?.unref();
    }
  }
  _a2 = RedisSocket, _RedisSocket_initiator = new WeakMap, _RedisSocket_options = new WeakMap, _RedisSocket_socket = new WeakMap, _RedisSocket_isOpen = new WeakMap, _RedisSocket_isReady = new WeakMap, _RedisSocket_writableNeedDrain = new WeakMap, _RedisSocket_isSocketUnrefed = new WeakMap, _RedisSocket_isCorked = new WeakMap, _RedisSocket_instances = new WeakSet, _RedisSocket_initiateOptions = function _RedisSocket_initiateOptions(options) {
    var _b2, _c;
    options ?? (options = {});
    if (!options.path) {
      (_b2 = options).port ?? (_b2.port = 6379);
      (_c = options).host ?? (_c.host = "localhost");
    }
    options.connectTimeout ?? (options.connectTimeout = 5000);
    options.keepAlive ?? (options.keepAlive = 5000);
    options.noDelay ?? (options.noDelay = true);
    return options;
  }, _RedisSocket_isTlsSocket = function _RedisSocket_isTlsSocket(options) {
    return options.tls === true;
  }, _RedisSocket_reconnectStrategy = function _RedisSocket_reconnectStrategy(retries, cause) {
    if (__classPrivateFieldGet2(this, _RedisSocket_options, "f").reconnectStrategy === false) {
      return false;
    } else if (typeof __classPrivateFieldGet2(this, _RedisSocket_options, "f").reconnectStrategy === "number") {
      return __classPrivateFieldGet2(this, _RedisSocket_options, "f").reconnectStrategy;
    } else if (__classPrivateFieldGet2(this, _RedisSocket_options, "f").reconnectStrategy) {
      try {
        const retryIn = __classPrivateFieldGet2(this, _RedisSocket_options, "f").reconnectStrategy(retries, cause);
        if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== "number") {
          throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
        }
        return retryIn;
      } catch (err2) {
        this.emit("error", err2);
      }
    }
    return Math.min(retries * 50, 500);
  }, _RedisSocket_shouldReconnect = function _RedisSocket_shouldReconnect(retries, cause) {
    const retryIn = __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_reconnectStrategy).call(this, retries, cause);
    if (retryIn === false) {
      __classPrivateFieldSet2(this, _RedisSocket_isOpen, false, "f");
      this.emit("error", cause);
      return cause;
    } else if (retryIn instanceof Error) {
      __classPrivateFieldSet2(this, _RedisSocket_isOpen, false, "f");
      this.emit("error", cause);
      return new errors_1.ReconnectStrategyError(retryIn, cause);
    }
    return retryIn;
  }, _RedisSocket_connect = async function _RedisSocket_connect() {
    let retries = 0;
    do {
      try {
        __classPrivateFieldSet2(this, _RedisSocket_socket, await __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_createSocket).call(this), "f");
        __classPrivateFieldSet2(this, _RedisSocket_writableNeedDrain, false, "f");
        this.emit("connect");
        try {
          await __classPrivateFieldGet2(this, _RedisSocket_initiator, "f").call(this);
        } catch (err2) {
          __classPrivateFieldGet2(this, _RedisSocket_socket, "f").destroy();
          __classPrivateFieldSet2(this, _RedisSocket_socket, undefined, "f");
          throw err2;
        }
        __classPrivateFieldSet2(this, _RedisSocket_isReady, true, "f");
        this.emit("ready");
      } catch (err2) {
        const retryIn = __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_shouldReconnect).call(this, retries++, err2);
        if (typeof retryIn !== "number") {
          throw retryIn;
        }
        this.emit("error", err2);
        await (0, utils_1.promiseTimeout)(retryIn);
        this.emit("reconnecting");
      }
    } while (__classPrivateFieldGet2(this, _RedisSocket_isOpen, "f") && !__classPrivateFieldGet2(this, _RedisSocket_isReady, "f"));
  }, _RedisSocket_createSocket = function _RedisSocket_createSocket() {
    return new Promise((resolve2, reject) => {
      const { connectEvent, socket } = __classPrivateFieldGet2(_a2, _a2, "m", _RedisSocket_isTlsSocket).call(_a2, __classPrivateFieldGet2(this, _RedisSocket_options, "f")) ? __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_createTlsSocket).call(this) : __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_createNetSocket).call(this);
      if (__classPrivateFieldGet2(this, _RedisSocket_options, "f").connectTimeout) {
        socket.setTimeout(__classPrivateFieldGet2(this, _RedisSocket_options, "f").connectTimeout, () => socket.destroy(new errors_1.ConnectionTimeoutError));
      }
      if (__classPrivateFieldGet2(this, _RedisSocket_isSocketUnrefed, "f")) {
        socket.unref();
      }
      socket.setNoDelay(__classPrivateFieldGet2(this, _RedisSocket_options, "f").noDelay).once("error", reject).once(connectEvent, () => {
        socket.setTimeout(0).setKeepAlive(__classPrivateFieldGet2(this, _RedisSocket_options, "f").keepAlive !== false, __classPrivateFieldGet2(this, _RedisSocket_options, "f").keepAlive || 0).off("error", reject).once("error", (err2) => __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_onSocketError).call(this, err2)).once("close", (hadError) => {
          if (!hadError && __classPrivateFieldGet2(this, _RedisSocket_isOpen, "f") && __classPrivateFieldGet2(this, _RedisSocket_socket, "f") === socket) {
            __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_onSocketError).call(this, new errors_1.SocketClosedUnexpectedlyError);
          }
        }).on("drain", () => {
          __classPrivateFieldSet2(this, _RedisSocket_writableNeedDrain, false, "f");
          this.emit("drain");
        }).on("data", (data) => this.emit("data", data));
        resolve2(socket);
      });
    });
  }, _RedisSocket_createNetSocket = function _RedisSocket_createNetSocket() {
    return {
      connectEvent: "connect",
      socket: net.connect(__classPrivateFieldGet2(this, _RedisSocket_options, "f"))
    };
  }, _RedisSocket_createTlsSocket = function _RedisSocket_createTlsSocket() {
    return {
      connectEvent: "secureConnect",
      socket: tls.connect(__classPrivateFieldGet2(this, _RedisSocket_options, "f"))
    };
  }, _RedisSocket_onSocketError = function _RedisSocket_onSocketError(err2) {
    const wasReady = __classPrivateFieldGet2(this, _RedisSocket_isReady, "f");
    __classPrivateFieldSet2(this, _RedisSocket_isReady, false, "f");
    this.emit("error", err2);
    if (!wasReady || !__classPrivateFieldGet2(this, _RedisSocket_isOpen, "f") || typeof __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_shouldReconnect).call(this, 0, err2) !== "number")
      return;
    this.emit("reconnecting");
    __classPrivateFieldGet2(this, _RedisSocket_instances, "m", _RedisSocket_connect).call(this).catch(() => {
    });
  }, _RedisSocket_disconnect = function _RedisSocket_disconnect() {
    __classPrivateFieldSet2(this, _RedisSocket_isReady, false, "f");
    if (__classPrivateFieldGet2(this, _RedisSocket_socket, "f")) {
      __classPrivateFieldGet2(this, _RedisSocket_socket, "f").destroy();
      __classPrivateFieldSet2(this, _RedisSocket_socket, undefined, "f");
    }
    this.emit("end");
  };
  exports.default = RedisSocket;
});

// node_modules/yallist/iterator.js
var require_iterator2 = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node, value26) {
    var inserted = node === self2.head ? new Node(value26, null, node, self2) : new Node(value26, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value26, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value26, prev, next, list);
    }
    this.list = list;
    this.value = value26;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret2 = new Yallist;
    if (to < from || to < 0) {
      return ret2;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret2.push(walker.value);
    }
    return ret2;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret2 = new Yallist;
    if (to < from || to < 0) {
      return ret2;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret2.push(walker.value);
    }
    return ret2;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret2 = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret2.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret2;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator2()(Yallist);
  } catch (er) {
  }
});

// node_modules/@redis/client/dist/lib/client/RESP2/composers/buffer.js
var require_buffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class BufferComposer {
    constructor() {
      Object.defineProperty(this, "chunks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
    }
    write(buffer) {
      this.chunks.push(buffer);
    }
    end(buffer) {
      this.write(buffer);
      return Buffer.concat(this.chunks.splice(0));
    }
    reset() {
      this.chunks = [];
    }
  }
  exports.default = BufferComposer;
});

// node_modules/@redis/client/dist/lib/client/RESP2/composers/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var string_decoder_1 = import.meta.require("string_decoder");

  class StringComposer {
    constructor() {
      Object.defineProperty(this, "decoder", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new string_decoder_1.StringDecoder
      });
      Object.defineProperty(this, "string", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ""
      });
    }
    write(buffer) {
      this.string += this.decoder.write(buffer);
    }
    end(buffer) {
      const string5 = this.string + this.decoder.end(buffer);
      this.string = "";
      return string5;
    }
    reset() {
      this.string = "";
    }
  }
  exports.default = StringComposer;
});

// node_modules/@redis/client/dist/lib/client/RESP2/decoder.js
var require_decoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors3();
  var buffer_1 = require_buffer();
  var string_1 = require_string();
  var Types;
  (function(Types2) {
    Types2[Types2["SIMPLE_STRING"] = 43] = "SIMPLE_STRING";
    Types2[Types2["ERROR"] = 45] = "ERROR";
    Types2[Types2["INTEGER"] = 58] = "INTEGER";
    Types2[Types2["BULK_STRING"] = 36] = "BULK_STRING";
    Types2[Types2["ARRAY"] = 42] = "ARRAY";
  })(Types || (Types = {}));
  var ASCII;
  (function(ASCII2) {
    ASCII2[ASCII2["CR"] = 13] = "CR";
    ASCII2[ASCII2["ZERO"] = 48] = "ZERO";
    ASCII2[ASCII2["MINUS"] = 45] = "MINUS";
  })(ASCII || (ASCII = {}));

  class RESP2Decoder {
    constructor(options) {
      Object.defineProperty(this, "options", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: options
      });
      Object.defineProperty(this, "cursor", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
      });
      Object.defineProperty(this, "type", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "bufferComposer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new buffer_1.default
      });
      Object.defineProperty(this, "stringComposer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new string_1.default
      });
      Object.defineProperty(this, "currentStringComposer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.stringComposer
      });
      Object.defineProperty(this, "integer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
      });
      Object.defineProperty(this, "isNegativeInteger", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "bulkStringRemainingLength", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "arraysInProcess", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "initializeArray", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "arrayItemType", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
    }
    reset() {
      this.cursor = 0;
      this.type = undefined;
      this.bufferComposer.reset();
      this.stringComposer.reset();
      this.currentStringComposer = this.stringComposer;
    }
    write(chunk) {
      while (this.cursor < chunk.length) {
        if (!this.type) {
          this.currentStringComposer = this.options.returnStringsAsBuffers() ? this.bufferComposer : this.stringComposer;
          this.type = chunk[this.cursor];
          if (++this.cursor >= chunk.length)
            break;
        }
        const reply = this.parseType(chunk, this.type);
        if (reply === undefined)
          break;
        this.type = undefined;
        this.options.onReply(reply);
      }
      this.cursor -= chunk.length;
    }
    parseType(chunk, type54, arraysToKeep) {
      switch (type54) {
        case Types.SIMPLE_STRING:
          return this.parseSimpleString(chunk);
        case Types.ERROR:
          return this.parseError(chunk);
        case Types.INTEGER:
          return this.parseInteger(chunk);
        case Types.BULK_STRING:
          return this.parseBulkString(chunk);
        case Types.ARRAY:
          return this.parseArray(chunk, arraysToKeep);
      }
    }
    compose(chunk, composer) {
      for (let i = this.cursor;i < chunk.length; i++) {
        if (chunk[i] === ASCII.CR) {
          const reply = composer.end(chunk.subarray(this.cursor, i));
          this.cursor = i + 2;
          return reply;
        }
      }
      const toWrite = chunk.subarray(this.cursor);
      composer.write(toWrite);
      this.cursor = chunk.length;
    }
    parseSimpleString(chunk) {
      return this.compose(chunk, this.currentStringComposer);
    }
    parseError(chunk) {
      const message = this.compose(chunk, this.stringComposer);
      if (message !== undefined) {
        return new errors_1.ErrorReply(message);
      }
    }
    parseInteger(chunk) {
      if (this.isNegativeInteger === undefined) {
        this.isNegativeInteger = chunk[this.cursor] === ASCII.MINUS;
        if (this.isNegativeInteger && ++this.cursor === chunk.length)
          return;
      }
      do {
        const byte2 = chunk[this.cursor];
        if (byte2 === ASCII.CR) {
          const integer = this.isNegativeInteger ? -this.integer : this.integer;
          this.integer = 0;
          this.isNegativeInteger = undefined;
          this.cursor += 2;
          return integer;
        }
        this.integer = this.integer * 10 + byte2 - ASCII.ZERO;
      } while (++this.cursor < chunk.length);
    }
    parseBulkString(chunk) {
      if (this.bulkStringRemainingLength === undefined) {
        const length = this.parseInteger(chunk);
        if (length === undefined)
          return;
        if (length === -1)
          return null;
        this.bulkStringRemainingLength = length;
        if (this.cursor >= chunk.length)
          return;
      }
      const end = this.cursor + this.bulkStringRemainingLength;
      if (chunk.length >= end) {
        const reply = this.currentStringComposer.end(chunk.subarray(this.cursor, end));
        this.bulkStringRemainingLength = undefined;
        this.cursor = end + 2;
        return reply;
      }
      const toWrite = chunk.subarray(this.cursor);
      this.currentStringComposer.write(toWrite);
      this.bulkStringRemainingLength -= toWrite.length;
      this.cursor = chunk.length;
    }
    parseArray(chunk, arraysToKeep = 0) {
      if (this.initializeArray || this.arraysInProcess.length === arraysToKeep) {
        const length = this.parseInteger(chunk);
        if (length === undefined) {
          this.initializeArray = true;
          return;
        }
        this.initializeArray = false;
        this.arrayItemType = undefined;
        if (length === -1) {
          return this.returnArrayReply(null, arraysToKeep, chunk);
        } else if (length === 0) {
          return this.returnArrayReply([], arraysToKeep, chunk);
        }
        this.arraysInProcess.push({
          array: new Array(length),
          pushCounter: 0
        });
      }
      while (this.cursor < chunk.length) {
        if (!this.arrayItemType) {
          this.arrayItemType = chunk[this.cursor];
          if (++this.cursor >= chunk.length)
            break;
        }
        const item = this.parseType(chunk, this.arrayItemType, arraysToKeep + 1);
        if (item === undefined)
          break;
        this.arrayItemType = undefined;
        const reply = this.pushArrayItem(item, arraysToKeep);
        if (reply !== undefined)
          return reply;
      }
    }
    returnArrayReply(reply, arraysToKeep, chunk) {
      if (this.arraysInProcess.length <= arraysToKeep)
        return reply;
      return this.pushArrayItem(reply, arraysToKeep, chunk);
    }
    pushArrayItem(item, arraysToKeep, chunk) {
      const to = this.arraysInProcess[this.arraysInProcess.length - 1];
      to.array[to.pushCounter] = item;
      if (++to.pushCounter === to.array.length) {
        return this.returnArrayReply(this.arraysInProcess.pop().array, arraysToKeep, chunk);
      } else if (chunk && chunk.length > this.cursor) {
        return this.parseArray(chunk, arraysToKeep);
      }
    }
  }
  exports.default = RESP2Decoder;
});

// node_modules/@redis/client/dist/lib/client/RESP2/encoder.js
var require_encoder = __commonJS((exports) => {
  var encodeCommand = function(args) {
    const toWrite = [];
    let strings = "*" + args.length + CRLF;
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        strings += "$" + Buffer.byteLength(arg) + CRLF + arg + CRLF;
      } else if (arg instanceof Buffer) {
        toWrite.push(strings + "$" + arg.length.toString() + CRLF, arg);
        strings = CRLF;
      } else {
        throw new TypeError("Invalid argument type");
      }
    }
    toWrite.push(strings);
    return toWrite;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var CRLF = "\r\n";
  exports.default = encodeCommand;
});

// node_modules/@redis/client/dist/lib/client/pub-sub.js
var require_pub_sub = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var _PubSub_instances;
  var _a2;
  var _PubSub_channelsArray;
  var _PubSub_listenersSet;
  var _PubSub_subscribing;
  var _PubSub_isActive;
  var _PubSub_listeners;
  var _PubSub_extendChannelListeners;
  var _PubSub_unsubscribeCommand;
  var _PubSub_updateIsActive;
  var _PubSub_emitPubSubMessage;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSub = exports.PubSubType = undefined;
  var PubSubType;
  (function(PubSubType2) {
    PubSubType2["CHANNELS"] = "CHANNELS";
    PubSubType2["PATTERNS"] = "PATTERNS";
    PubSubType2["SHARDED"] = "SHARDED";
  })(PubSubType || (exports.PubSubType = PubSubType = {}));
  var COMMANDS = {
    [PubSubType.CHANNELS]: {
      subscribe: Buffer.from("subscribe"),
      unsubscribe: Buffer.from("unsubscribe"),
      message: Buffer.from("message")
    },
    [PubSubType.PATTERNS]: {
      subscribe: Buffer.from("psubscribe"),
      unsubscribe: Buffer.from("punsubscribe"),
      message: Buffer.from("pmessage")
    },
    [PubSubType.SHARDED]: {
      subscribe: Buffer.from("ssubscribe"),
      unsubscribe: Buffer.from("sunsubscribe"),
      message: Buffer.from("smessage")
    }
  };

  class PubSub {
    constructor() {
      _PubSub_instances.add(this);
      _PubSub_subscribing.set(this, 0);
      _PubSub_isActive.set(this, false);
      _PubSub_listeners.set(this, {
        [PubSubType.CHANNELS]: new Map,
        [PubSubType.PATTERNS]: new Map,
        [PubSubType.SHARDED]: new Map
      });
    }
    static isStatusReply(reply) {
      return COMMANDS[PubSubType.CHANNELS].subscribe.equals(reply[0]) || COMMANDS[PubSubType.CHANNELS].unsubscribe.equals(reply[0]) || COMMANDS[PubSubType.PATTERNS].subscribe.equals(reply[0]) || COMMANDS[PubSubType.PATTERNS].unsubscribe.equals(reply[0]) || COMMANDS[PubSubType.SHARDED].subscribe.equals(reply[0]);
    }
    static isShardedUnsubscribe(reply) {
      return COMMANDS[PubSubType.SHARDED].unsubscribe.equals(reply[0]);
    }
    get isActive() {
      return __classPrivateFieldGet2(this, _PubSub_isActive, "f");
    }
    subscribe(type54, channels, listener, returnBuffers) {
      var _b2;
      const args = [COMMANDS[type54].subscribe], channelsArray = __classPrivateFieldGet2(_a2, _a2, "m", _PubSub_channelsArray).call(_a2, channels);
      for (const channel of channelsArray) {
        let channelListeners = __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].get(channel);
        if (!channelListeners || channelListeners.unsubscribing) {
          args.push(channel);
        }
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          __classPrivateFieldGet2(_a2, _a2, "m", _PubSub_listenersSet).call(_a2, __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].get(channel), returnBuffers).add(listener);
        }
        return;
      }
      __classPrivateFieldSet2(this, _PubSub_isActive, true, "f");
      __classPrivateFieldSet2(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b2++, _b2), "f");
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          var _b3;
          __classPrivateFieldSet2(this, _PubSub_subscribing, (_b3 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3--, _b3), "f");
          for (const channel of channelsArray) {
            let listeners = __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].get(channel);
            if (!listeners) {
              listeners = {
                unsubscribing: false,
                buffers: new Set,
                strings: new Set
              };
              __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].set(channel, listeners);
            }
            __classPrivateFieldGet2(_a2, _a2, "m", _PubSub_listenersSet).call(_a2, listeners, returnBuffers).add(listener);
          }
        },
        reject: () => {
          var _b3;
          __classPrivateFieldSet2(this, _PubSub_subscribing, (_b3 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3--, _b3), "f");
          __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
        }
      };
    }
    extendChannelListeners(type54, channel, listeners) {
      var _b2;
      if (!__classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_extendChannelListeners).call(this, type54, channel, listeners))
        return;
      __classPrivateFieldSet2(this, _PubSub_isActive, true, "f");
      __classPrivateFieldSet2(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b2++, _b2), "f");
      return {
        args: [
          COMMANDS[type54].subscribe,
          channel
        ],
        channelsCounter: 1,
        resolve: () => {
          var _b3, _c;
          return __classPrivateFieldSet2(this, _PubSub_subscribing, (_c = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3 = _c--, _c), "f"), _b3;
        },
        reject: () => {
          var _b3;
          __classPrivateFieldSet2(this, _PubSub_subscribing, (_b3 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3--, _b3), "f");
          __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
        }
      };
    }
    extendTypeListeners(type54, listeners) {
      var _b2;
      const args = [COMMANDS[type54].subscribe];
      for (const [channel, channelListeners] of listeners) {
        if (__classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_extendChannelListeners).call(this, type54, channel, channelListeners)) {
          args.push(channel);
        }
      }
      if (args.length === 1)
        return;
      __classPrivateFieldSet2(this, _PubSub_isActive, true, "f");
      __classPrivateFieldSet2(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b2++, _b2), "f");
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          var _b3, _c;
          return __classPrivateFieldSet2(this, _PubSub_subscribing, (_c = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3 = _c--, _c), "f"), _b3;
        },
        reject: () => {
          var _b3;
          __classPrivateFieldSet2(this, _PubSub_subscribing, (_b3 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3--, _b3), "f");
          __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
        }
      };
    }
    unsubscribe(type54, channels, listener, returnBuffers) {
      const listeners = __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54];
      if (!channels) {
        return __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_unsubscribeCommand).call(this, [COMMANDS[type54].unsubscribe], NaN, () => listeners.clear());
      }
      const channelsArray = __classPrivateFieldGet2(_a2, _a2, "m", _PubSub_channelsArray).call(_a2, channels);
      if (!listener) {
        return __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_unsubscribeCommand).call(this, [COMMANDS[type54].unsubscribe, ...channelsArray], channelsArray.length, () => {
          for (const channel of channelsArray) {
            listeners.delete(channel);
          }
        });
      }
      const args = [COMMANDS[type54].unsubscribe];
      for (const channel of channelsArray) {
        const sets4 = listeners.get(channel);
        if (sets4) {
          let current, other;
          if (returnBuffers) {
            current = sets4.buffers;
            other = sets4.strings;
          } else {
            current = sets4.strings;
            other = sets4.buffers;
          }
          const currentSize = current.has(listener) ? current.size - 1 : current.size;
          if (currentSize !== 0 || other.size !== 0)
            continue;
          sets4.unsubscribing = true;
        }
        args.push(channel);
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          __classPrivateFieldGet2(_a2, _a2, "m", _PubSub_listenersSet).call(_a2, listeners.get(channel), returnBuffers).delete(listener);
        }
        return;
      }
      return __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_unsubscribeCommand).call(this, args, args.length - 1, () => {
        for (const channel of channelsArray) {
          const sets4 = listeners.get(channel);
          if (!sets4)
            continue;
          (returnBuffers ? sets4.buffers : sets4.strings).delete(listener);
          if (sets4.buffers.size === 0 && sets4.strings.size === 0) {
            listeners.delete(channel);
          }
        }
      });
    }
    reset() {
      __classPrivateFieldSet2(this, _PubSub_isActive, false, "f");
      __classPrivateFieldSet2(this, _PubSub_subscribing, 0, "f");
    }
    resubscribe() {
      var _b2;
      const commands = [];
      for (const [type54, listeners] of Object.entries(__classPrivateFieldGet2(this, _PubSub_listeners, "f"))) {
        if (!listeners.size)
          continue;
        __classPrivateFieldSet2(this, _PubSub_isActive, true, "f");
        __classPrivateFieldSet2(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b2++, _b2), "f");
        const callback = () => {
          var _b3, _c;
          return __classPrivateFieldSet2(this, _PubSub_subscribing, (_c = __classPrivateFieldGet2(this, _PubSub_subscribing, "f"), _b3 = _c--, _c), "f"), _b3;
        };
        commands.push({
          args: [
            COMMANDS[type54].subscribe,
            ...listeners.keys()
          ],
          channelsCounter: listeners.size,
          resolve: callback,
          reject: callback
        });
      }
      return commands;
    }
    handleMessageReply(reply) {
      if (COMMANDS[PubSubType.CHANNELS].message.equals(reply[0])) {
        __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_emitPubSubMessage).call(this, PubSubType.CHANNELS, reply[2], reply[1]);
        return true;
      } else if (COMMANDS[PubSubType.PATTERNS].message.equals(reply[0])) {
        __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_emitPubSubMessage).call(this, PubSubType.PATTERNS, reply[3], reply[2], reply[1]);
        return true;
      } else if (COMMANDS[PubSubType.SHARDED].message.equals(reply[0])) {
        __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_emitPubSubMessage).call(this, PubSubType.SHARDED, reply[2], reply[1]);
        return true;
      }
      return false;
    }
    removeShardedListeners(channel) {
      const listeners = __classPrivateFieldGet2(this, _PubSub_listeners, "f")[PubSubType.SHARDED].get(channel);
      __classPrivateFieldGet2(this, _PubSub_listeners, "f")[PubSubType.SHARDED].delete(channel);
      __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
      return listeners;
    }
    getTypeListeners(type54) {
      return __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54];
    }
  }
  exports.PubSub = PubSub;
  _a2 = PubSub, _PubSub_subscribing = new WeakMap, _PubSub_isActive = new WeakMap, _PubSub_listeners = new WeakMap, _PubSub_instances = new WeakSet, _PubSub_channelsArray = function _PubSub_channelsArray(channels) {
    return Array.isArray(channels) ? channels : [channels];
  }, _PubSub_listenersSet = function _PubSub_listenersSet(listeners, returnBuffers) {
    return returnBuffers ? listeners.buffers : listeners.strings;
  }, _PubSub_extendChannelListeners = function _PubSub_extendChannelListeners(type54, channel, listeners) {
    const existingListeners = __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].get(channel);
    if (!existingListeners) {
      __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].set(channel, listeners);
      return true;
    }
    for (const listener of listeners.buffers) {
      existingListeners.buffers.add(listener);
    }
    for (const listener of listeners.strings) {
      existingListeners.strings.add(listener);
    }
    return false;
  }, _PubSub_unsubscribeCommand = function _PubSub_unsubscribeCommand(args, channelsCounter, removeListeners) {
    return {
      args,
      channelsCounter,
      resolve: () => {
        removeListeners();
        __classPrivateFieldGet2(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
      },
      reject: undefined
    };
  }, _PubSub_updateIsActive = function _PubSub_updateIsActive() {
    __classPrivateFieldSet2(this, _PubSub_isActive, __classPrivateFieldGet2(this, _PubSub_listeners, "f")[PubSubType.CHANNELS].size !== 0 || __classPrivateFieldGet2(this, _PubSub_listeners, "f")[PubSubType.PATTERNS].size !== 0 || __classPrivateFieldGet2(this, _PubSub_listeners, "f")[PubSubType.SHARDED].size !== 0 || __classPrivateFieldGet2(this, _PubSub_subscribing, "f") !== 0, "f");
  }, _PubSub_emitPubSubMessage = function _PubSub_emitPubSubMessage(type54, message, channel, pattern2) {
    const keyString = (pattern2 ?? channel).toString(), listeners = __classPrivateFieldGet2(this, _PubSub_listeners, "f")[type54].get(keyString);
    if (!listeners)
      return;
    for (const listener of listeners.buffers) {
      listener(message, channel);
    }
    if (!listeners.strings.size)
      return;
    const channelString = pattern2 ? channel.toString() : keyString, messageString = channelString === "__redis__:invalidate" ? message === null ? null : message.map((x) => x.toString()) : message.toString();
    for (const listener of listeners.strings) {
      listener(messageString, channelString);
    }
  };
});

// node_modules/@redis/client/dist/lib/client/commands-queue.js
var require_commands_queue = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var _RedisCommandsQueue_instances;
  var _a2;
  var _RedisCommandsQueue_flushQueue;
  var _RedisCommandsQueue_maxLength;
  var _RedisCommandsQueue_waitingToBeSent;
  var _RedisCommandsQueue_waitingForReply;
  var _RedisCommandsQueue_onShardedChannelMoved;
  var _RedisCommandsQueue_pubSub;
  var _RedisCommandsQueue_chainInExecution;
  var _RedisCommandsQueue_decoder;
  var _RedisCommandsQueue_pushPubSubCommand;
  Object.defineProperty(exports, "__esModule", { value: true });
  var LinkedList = require_yallist();
  var errors_1 = require_errors3();
  var decoder_1 = require_decoder();
  var encoder_1 = require_encoder();
  var pub_sub_1 = require_pub_sub();
  var PONG = Buffer.from("pong");

  class RedisCommandsQueue {
    get isPubSubActive() {
      return __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").isActive;
    }
    constructor(maxLength, onShardedChannelMoved) {
      _RedisCommandsQueue_instances.add(this);
      _RedisCommandsQueue_maxLength.set(this, undefined);
      _RedisCommandsQueue_waitingToBeSent.set(this, new LinkedList);
      _RedisCommandsQueue_waitingForReply.set(this, new LinkedList);
      _RedisCommandsQueue_onShardedChannelMoved.set(this, undefined);
      _RedisCommandsQueue_pubSub.set(this, new pub_sub_1.PubSub);
      _RedisCommandsQueue_chainInExecution.set(this, undefined);
      _RedisCommandsQueue_decoder.set(this, new decoder_1.default({
        returnStringsAsBuffers: () => {
          return !!__classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").head?.value.returnBuffers || __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").isActive;
        },
        onReply: (reply) => {
          if (__classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").isActive && Array.isArray(reply)) {
            if (__classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").handleMessageReply(reply))
              return;
            const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(reply);
            if (isShardedUnsubscribe && !__classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").length) {
              const channel = reply[1].toString();
              __classPrivateFieldGet2(this, _RedisCommandsQueue_onShardedChannelMoved, "f").call(this, channel, __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").removeShardedListeners(channel));
              return;
            } else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(reply)) {
              const head = __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").head.value;
              if (Number.isNaN(head.channelsCounter) && reply[2] === 0 || --head.channelsCounter === 0) {
                __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").shift().resolve();
              }
              return;
            }
            if (PONG.equals(reply[0])) {
              const { resolve: resolve3, returnBuffers } = __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").shift(), buffer = reply[1].length === 0 ? reply[0] : reply[1];
              resolve3(returnBuffers ? buffer : buffer.toString());
              return;
            }
          }
          const { resolve: resolve2, reject } = __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").shift();
          if (reply instanceof errors_1.ErrorReply) {
            reject(reply);
          } else {
            resolve2(reply);
          }
        }
      }));
      __classPrivateFieldSet2(this, _RedisCommandsQueue_maxLength, maxLength, "f");
      __classPrivateFieldSet2(this, _RedisCommandsQueue_onShardedChannelMoved, onShardedChannelMoved, "f");
    }
    addCommand(args, options) {
      if (__classPrivateFieldGet2(this, _RedisCommandsQueue_maxLength, "f") && __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").length + __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").length >= __classPrivateFieldGet2(this, _RedisCommandsQueue_maxLength, "f")) {
        return Promise.reject(new Error("The queue is full"));
      } else if (options?.signal?.aborted) {
        return Promise.reject(new errors_1.AbortError);
      }
      return new Promise((resolve2, reject) => {
        const node = new LinkedList.Node({
          args,
          chainId: options?.chainId,
          returnBuffers: options?.returnBuffers,
          resolve: resolve2,
          reject
        });
        if (options?.signal) {
          const listener = () => {
            __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").removeNode(node);
            node.value.reject(new errors_1.AbortError);
          };
          node.value.abort = {
            signal: options.signal,
            listener
          };
          options.signal.addEventListener("abort", listener, {
            once: true
          });
        }
        if (options?.asap) {
          __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").unshiftNode(node);
        } else {
          __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").pushNode(node);
        }
      });
    }
    subscribe(type54, channels, listener, returnBuffers) {
      return __classPrivateFieldGet2(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").subscribe(type54, channels, listener, returnBuffers));
    }
    unsubscribe(type54, channels, listener, returnBuffers) {
      return __classPrivateFieldGet2(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").unsubscribe(type54, channels, listener, returnBuffers));
    }
    resubscribe() {
      const commands = __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").resubscribe();
      if (!commands.length)
        return;
      return Promise.all(commands.map((command) => __classPrivateFieldGet2(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, command)));
    }
    extendPubSubChannelListeners(type54, channel, listeners) {
      return __classPrivateFieldGet2(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").extendChannelListeners(type54, channel, listeners));
    }
    extendPubSubListeners(type54, listeners) {
      return __classPrivateFieldGet2(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").extendTypeListeners(type54, listeners));
    }
    getPubSubListeners(type54) {
      return __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").getTypeListeners(type54);
    }
    getCommandToSend() {
      const toSend = __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").shift();
      if (!toSend)
        return;
      let encoded;
      try {
        encoded = (0, encoder_1.default)(toSend.args);
      } catch (err2) {
        toSend.reject(err2);
        return;
      }
      __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f").push({
        resolve: toSend.resolve,
        reject: toSend.reject,
        channelsCounter: toSend.channelsCounter,
        returnBuffers: toSend.returnBuffers
      });
      __classPrivateFieldSet2(this, _RedisCommandsQueue_chainInExecution, toSend.chainId, "f");
      return encoded;
    }
    onReplyChunk(chunk) {
      __classPrivateFieldGet2(this, _RedisCommandsQueue_decoder, "f").write(chunk);
    }
    flushWaitingForReply(err2) {
      __classPrivateFieldGet2(this, _RedisCommandsQueue_decoder, "f").reset();
      __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").reset();
      __classPrivateFieldGet2(_a2, _a2, "m", _RedisCommandsQueue_flushQueue).call(_a2, __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f"), err2);
      if (!__classPrivateFieldGet2(this, _RedisCommandsQueue_chainInExecution, "f"))
        return;
      while (__classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").head?.value.chainId === __classPrivateFieldGet2(this, _RedisCommandsQueue_chainInExecution, "f")) {
        __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").shift();
      }
      __classPrivateFieldSet2(this, _RedisCommandsQueue_chainInExecution, undefined, "f");
    }
    flushAll(err2) {
      __classPrivateFieldGet2(this, _RedisCommandsQueue_decoder, "f").reset();
      __classPrivateFieldGet2(this, _RedisCommandsQueue_pubSub, "f").reset();
      __classPrivateFieldGet2(_a2, _a2, "m", _RedisCommandsQueue_flushQueue).call(_a2, __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingForReply, "f"), err2);
      __classPrivateFieldGet2(_a2, _a2, "m", _RedisCommandsQueue_flushQueue).call(_a2, __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f"), err2);
    }
  }
  _a2 = RedisCommandsQueue, _RedisCommandsQueue_maxLength = new WeakMap, _RedisCommandsQueue_waitingToBeSent = new WeakMap, _RedisCommandsQueue_waitingForReply = new WeakMap, _RedisCommandsQueue_onShardedChannelMoved = new WeakMap, _RedisCommandsQueue_pubSub = new WeakMap, _RedisCommandsQueue_chainInExecution = new WeakMap, _RedisCommandsQueue_decoder = new WeakMap, _RedisCommandsQueue_instances = new WeakSet, _RedisCommandsQueue_flushQueue = function _RedisCommandsQueue_flushQueue(queue, err2) {
    while (queue.length) {
      queue.shift().reject(err2);
    }
  }, _RedisCommandsQueue_pushPubSubCommand = function _RedisCommandsQueue_pushPubSubCommand(command) {
    if (command === undefined)
      return;
    return new Promise((resolve2, reject) => {
      __classPrivateFieldGet2(this, _RedisCommandsQueue_waitingToBeSent, "f").push({
        args: command.args,
        channelsCounter: command.channelsCounter,
        returnBuffers: true,
        resolve: () => {
          command.resolve();
          resolve2();
        },
        reject: (err2) => {
          command.reject?.();
          reject(err2);
        }
      });
    });
  };
  exports.default = RedisCommandsQueue;
});

// node_modules/@redis/client/dist/lib/command-options.js
var require_command_options = __commonJS((exports) => {
  var commandOptions = function(options) {
    options[symbol2] = true;
    return options;
  };
  var isCommandOptions = function(options) {
    return options?.[symbol2] === true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCommandOptions = exports.commandOptions = undefined;
  var symbol2 = Symbol("Command Options");
  exports.commandOptions = commandOptions;
  exports.isCommandOptions = isCommandOptions;
});

// node_modules/@redis/client/dist/lib/commander.js
var require_commander = __commonJS((exports) => {
  var attachCommands = function({ BaseClass, commands, executor }) {
    for (const [name, command] of Object.entries(commands)) {
      BaseClass.prototype[name] = function(...args) {
        return executor.call(this, command, args, name);
      };
    }
  };
  var attachExtensions = function(config) {
    let Commander;
    if (config.modules) {
      Commander = attachWithNamespaces({
        BaseClass: config.BaseClass,
        namespaces: config.modules,
        executor: config.modulesExecutor
      });
    }
    if (config.functions) {
      Commander = attachWithNamespaces({
        BaseClass: Commander ?? config.BaseClass,
        namespaces: config.functions,
        executor: config.functionsExecutor
      });
    }
    if (config.scripts) {
      Commander ?? (Commander = class extends config.BaseClass {
      });
      attachCommands({
        BaseClass: Commander,
        commands: config.scripts,
        executor: config.scriptsExecutor
      });
    }
    return Commander ?? config.BaseClass;
  };
  var attachWithNamespaces = function({ BaseClass, namespaces, executor }) {
    const Commander = class extends BaseClass {
      constructor(...args) {
        super(...args);
        for (const namespace of Object.keys(namespaces)) {
          this[namespace] = Object.create(this[namespace], {
            self: {
              value: this
            }
          });
        }
      }
    };
    for (const [namespace, commands] of Object.entries(namespaces)) {
      Commander.prototype[namespace] = {};
      for (const [name, command] of Object.entries(commands)) {
        Commander.prototype[namespace][name] = function(...args) {
          return executor.call(this.self, command, args, name);
        };
      }
    }
    return Commander;
  };
  var transformCommandArguments = function(command, args) {
    let options;
    if ((0, command_options_1.isCommandOptions)(args[0])) {
      options = args[0];
      args = args.slice(1);
    }
    return {
      jsArgs: args,
      args: command.transformArguments(...args),
      options
    };
  };
  var transformLegacyCommandArguments = function(args) {
    return args.flat().map((arg) => {
      return typeof arg === "number" || arg instanceof Date ? arg.toString() : arg;
    });
  };
  var transformCommandReply = function(command, rawReply, preserved) {
    if (!command.transformReply) {
      return rawReply;
    }
    return command.transformReply(rawReply, preserved);
  };
  var fCallArguments = function(name, fn, args) {
    const actualArgs = [
      fn.IS_READ_ONLY ? "FCALL_RO" : "FCALL",
      name
    ];
    if (fn.NUMBER_OF_KEYS !== undefined) {
      actualArgs.push(fn.NUMBER_OF_KEYS.toString());
    }
    actualArgs.push(...args);
    return actualArgs;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fCallArguments = exports.transformCommandReply = exports.transformLegacyCommandArguments = exports.transformCommandArguments = exports.attachExtensions = exports.attachCommands = undefined;
  var command_options_1 = require_command_options();
  exports.attachCommands = attachCommands;
  exports.attachExtensions = attachExtensions;
  exports.transformCommandArguments = transformCommandArguments;
  exports.transformLegacyCommandArguments = transformLegacyCommandArguments;
  exports.transformCommandReply = transformCommandReply;
  exports.fCallArguments = fCallArguments;
});

// node_modules/@redis/client/dist/lib/multi-command.js
var require_multi_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commander_1 = require_commander();
  var errors_1 = require_errors3();

  class RedisMultiCommand {
    constructor() {
      Object.defineProperty(this, "queue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "scriptsInUse", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Set
      });
    }
    static generateChainId() {
      return Symbol("RedisMultiCommand Chain Id");
    }
    addCommand(args, transformReply) {
      this.queue.push({
        args,
        transformReply
      });
    }
    addFunction(name, fn, args) {
      const transformedArguments = (0, commander_1.fCallArguments)(name, fn, fn.transformArguments(...args));
      this.queue.push({
        args: transformedArguments,
        transformReply: fn.transformReply
      });
      return transformedArguments;
    }
    addScript(script, args) {
      const transformedArguments = [];
      if (this.scriptsInUse.has(script.SHA1)) {
        transformedArguments.push("EVALSHA", script.SHA1);
      } else {
        this.scriptsInUse.add(script.SHA1);
        transformedArguments.push("EVAL", script.SCRIPT);
      }
      if (script.NUMBER_OF_KEYS !== undefined) {
        transformedArguments.push(script.NUMBER_OF_KEYS.toString());
      }
      const scriptArguments = script.transformArguments(...args);
      transformedArguments.push(...scriptArguments);
      if (scriptArguments.preserve) {
        transformedArguments.preserve = scriptArguments.preserve;
      }
      this.addCommand(transformedArguments, script.transformReply);
      return transformedArguments;
    }
    handleExecReplies(rawReplies) {
      const execReply = rawReplies[rawReplies.length - 1];
      if (execReply === null) {
        throw new errors_1.WatchError;
      }
      return this.transformReplies(execReply);
    }
    transformReplies(rawReplies) {
      const errorIndexes = [], replies = rawReplies.map((reply, i) => {
        if (reply instanceof errors_1.ErrorReply) {
          errorIndexes.push(i);
          return reply;
        }
        const { transformReply, args } = this.queue[i];
        return transformReply ? transformReply(reply, args.preserve) : reply;
      });
      if (errorIndexes.length)
        throw new errors_1.MultiErrorReply(replies, errorIndexes);
      return replies;
    }
  }
  exports.default = RedisMultiCommand;
});

// node_modules/@redis/client/dist/lib/client/multi-command.js
var require_multi_command2 = __commonJS((exports) => {
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _RedisClientMultiCommand_instances;
  var _RedisClientMultiCommand_multi;
  var _RedisClientMultiCommand_executor;
  var _RedisClientMultiCommand_selectedDB;
  var _RedisClientMultiCommand_legacyMode;
  var _RedisClientMultiCommand_defineLegacyCommand;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands2();
  var multi_command_1 = require_multi_command();
  var commander_1 = require_commander();

  class RedisClientMultiCommand {
    static extend(extensions2) {
      return (0, commander_1.attachExtensions)({
        BaseClass: RedisClientMultiCommand,
        modulesExecutor: RedisClientMultiCommand.prototype.commandsExecutor,
        modules: extensions2?.modules,
        functionsExecutor: RedisClientMultiCommand.prototype.functionsExecutor,
        functions: extensions2?.functions,
        scriptsExecutor: RedisClientMultiCommand.prototype.scriptsExecutor,
        scripts: extensions2?.scripts
      });
    }
    constructor(executor, legacyMode = false) {
      _RedisClientMultiCommand_instances.add(this);
      _RedisClientMultiCommand_multi.set(this, new multi_command_1.default);
      _RedisClientMultiCommand_executor.set(this, undefined);
      Object.defineProperty(this, "v4", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      _RedisClientMultiCommand_selectedDB.set(this, undefined);
      Object.defineProperty(this, "select", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SELECT
      });
      Object.defineProperty(this, "EXEC", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.exec
      });
      __classPrivateFieldSet2(this, _RedisClientMultiCommand_executor, executor, "f");
      if (legacyMode) {
        __classPrivateFieldGet2(this, _RedisClientMultiCommand_instances, "m", _RedisClientMultiCommand_legacyMode).call(this);
      }
    }
    commandsExecutor(command, args) {
      return this.addCommand(command.transformArguments(...args), command.transformReply);
    }
    SELECT(db, transformReply) {
      __classPrivateFieldSet2(this, _RedisClientMultiCommand_selectedDB, db, "f");
      return this.addCommand(["SELECT", db.toString()], transformReply);
    }
    addCommand(args, transformReply) {
      __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").addCommand(args, transformReply);
      return this;
    }
    functionsExecutor(fn, args, name) {
      __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").addFunction(name, fn, args);
      return this;
    }
    scriptsExecutor(script, args) {
      __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").addScript(script, args);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline) {
        return this.execAsPipeline();
      }
      return __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").handleExecReplies(await __classPrivateFieldGet2(this, _RedisClientMultiCommand_executor, "f").call(this, __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").queue, __classPrivateFieldGet2(this, _RedisClientMultiCommand_selectedDB, "f"), multi_command_1.default.generateChainId()));
    }
    async execAsPipeline() {
      if (__classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").queue.length === 0)
        return [];
      return __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").transformReplies(await __classPrivateFieldGet2(this, _RedisClientMultiCommand_executor, "f").call(this, __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").queue, __classPrivateFieldGet2(this, _RedisClientMultiCommand_selectedDB, "f")));
    }
  }
  _RedisClientMultiCommand_multi = new WeakMap, _RedisClientMultiCommand_executor = new WeakMap, _RedisClientMultiCommand_selectedDB = new WeakMap, _RedisClientMultiCommand_instances = new WeakSet, _RedisClientMultiCommand_legacyMode = function _RedisClientMultiCommand_legacyMode() {
    var _a2, _b2;
    this.v4.addCommand = this.addCommand.bind(this);
    this.addCommand = (...args) => {
      __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").addCommand((0, commander_1.transformLegacyCommandArguments)(args));
      return this;
    };
    this.v4.exec = this.exec.bind(this);
    this.exec = (callback) => {
      this.v4.exec().then((reply) => {
        if (!callback)
          return;
        callback(null, reply);
      }).catch((err2) => {
        if (!callback) {
          return;
        }
        callback(err2);
      });
    };
    for (const [name, command] of Object.entries(commands_1.default)) {
      __classPrivateFieldGet2(this, _RedisClientMultiCommand_instances, "m", _RedisClientMultiCommand_defineLegacyCommand).call(this, name, command);
      (_a2 = this)[_b2 = name.toLowerCase()] ?? (_a2[_b2] = this[name]);
    }
  }, _RedisClientMultiCommand_defineLegacyCommand = function _RedisClientMultiCommand_defineLegacyCommand(name, command) {
    this.v4[name] = this[name].bind(this.v4);
    this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ? (...args) => {
      __classPrivateFieldGet2(this, _RedisClientMultiCommand_multi, "f").addCommand([name, ...(0, commander_1.transformLegacyCommandArguments)(args)], command.transformReply);
      return this;
    } : (...args) => this.addCommand(name, ...args);
  };
  exports.default = RedisClientMultiCommand;
  (0, commander_1.attachCommands)({
    BaseClass: RedisClientMultiCommand,
    commands: commands_1.default,
    executor: RedisClientMultiCommand.prototype.commandsExecutor
  });
});

// node_modules/generic-pool/lib/factoryValidator.js
var require_factoryValidator = __commonJS((exports, module) => {
  module.exports = function(factory) {
    if (typeof factory.create !== "function") {
      throw new TypeError("factory.create must be a function");
    }
    if (typeof factory.destroy !== "function") {
      throw new TypeError("factory.destroy must be a function");
    }
    if (typeof factory.validate !== "undefined" && typeof factory.validate !== "function") {
      throw new TypeError("factory.validate must be a function");
    }
  };
});

// node_modules/generic-pool/lib/PoolDefaults.js
var require_PoolDefaults = __commonJS((exports, module) => {
  class PoolDefaults {
    constructor() {
      this.fifo = true;
      this.priorityRange = 1;
      this.testOnBorrow = false;
      this.testOnReturn = false;
      this.autostart = true;
      this.evictionRunIntervalMillis = 0;
      this.numTestsPerEvictionRun = 3;
      this.softIdleTimeoutMillis = -1;
      this.idleTimeoutMillis = 30000;
      this.acquireTimeoutMillis = null;
      this.destroyTimeoutMillis = null;
      this.maxWaitingClients = null;
      this.min = null;
      this.max = null;
      this.Promise = Promise;
    }
  }
  module.exports = PoolDefaults;
});

// node_modules/generic-pool/lib/PoolOptions.js
var require_PoolOptions = __commonJS((exports, module) => {
  var PoolDefaults = require_PoolDefaults();

  class PoolOptions {
    constructor(opts) {
      const poolDefaults = new PoolDefaults;
      opts = opts || {};
      this.fifo = typeof opts.fifo === "boolean" ? opts.fifo : poolDefaults.fifo;
      this.priorityRange = opts.priorityRange || poolDefaults.priorityRange;
      this.testOnBorrow = typeof opts.testOnBorrow === "boolean" ? opts.testOnBorrow : poolDefaults.testOnBorrow;
      this.testOnReturn = typeof opts.testOnReturn === "boolean" ? opts.testOnReturn : poolDefaults.testOnReturn;
      this.autostart = typeof opts.autostart === "boolean" ? opts.autostart : poolDefaults.autostart;
      if (opts.acquireTimeoutMillis) {
        this.acquireTimeoutMillis = parseInt(opts.acquireTimeoutMillis, 10);
      }
      if (opts.destroyTimeoutMillis) {
        this.destroyTimeoutMillis = parseInt(opts.destroyTimeoutMillis, 10);
      }
      if (opts.maxWaitingClients !== undefined) {
        this.maxWaitingClients = parseInt(opts.maxWaitingClients, 10);
      }
      this.max = parseInt(opts.max, 10);
      this.min = parseInt(opts.min, 10);
      this.max = Math.max(isNaN(this.max) ? 1 : this.max, 1);
      this.min = Math.min(isNaN(this.min) ? 0 : this.min, this.max);
      this.evictionRunIntervalMillis = opts.evictionRunIntervalMillis || poolDefaults.evictionRunIntervalMillis;
      this.numTestsPerEvictionRun = opts.numTestsPerEvictionRun || poolDefaults.numTestsPerEvictionRun;
      this.softIdleTimeoutMillis = opts.softIdleTimeoutMillis || poolDefaults.softIdleTimeoutMillis;
      this.idleTimeoutMillis = opts.idleTimeoutMillis || poolDefaults.idleTimeoutMillis;
      this.Promise = opts.Promise != null ? opts.Promise : poolDefaults.Promise;
    }
  }
  module.exports = PoolOptions;
});

// node_modules/generic-pool/lib/Deferred.js
var require_Deferred = __commonJS((exports, module) => {
  class Deferred3 {
    constructor(Promise3) {
      this._state = Deferred3.PENDING;
      this._resolve = undefined;
      this._reject = undefined;
      this._promise = new Promise3((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    reject(reason) {
      if (this._state !== Deferred3.PENDING) {
        return;
      }
      this._state = Deferred3.REJECTED;
      this._reject(reason);
    }
    resolve(value26) {
      if (this._state !== Deferred3.PENDING) {
        return;
      }
      this._state = Deferred3.FULFILLED;
      this._resolve(value26);
    }
  }
  Deferred3.PENDING = "PENDING";
  Deferred3.FULFILLED = "FULFILLED";
  Deferred3.REJECTED = "REJECTED";
  module.exports = Deferred3;
});

// node_modules/generic-pool/lib/errors.js
var require_errors4 = __commonJS((exports, module) => {
  class ExtendableError extends Error {
    constructor(message) {
      super(message);
      this.name = this.constructor.name;
      this.message = message;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }

  class TimeoutError extends ExtendableError {
    constructor(m) {
      super(m);
    }
  }
  module.exports = {
    TimeoutError
  };
});

// node_modules/generic-pool/lib/ResourceRequest.js
var require_ResourceRequest = __commonJS((exports, module) => {
  var fbind = function(fn, ctx) {
    return function bound() {
      return fn.apply(ctx, arguments);
    };
  };
  var Deferred3 = require_Deferred();
  var errors6 = require_errors4();

  class ResourceRequest extends Deferred3 {
    constructor(ttl, Promise3) {
      super(Promise3);
      this._creationTimestamp = Date.now();
      this._timeout = null;
      if (ttl !== undefined) {
        this.setTimeout(ttl);
      }
    }
    setTimeout(delay) {
      if (this._state !== ResourceRequest.PENDING) {
        return;
      }
      const ttl = parseInt(delay, 10);
      if (isNaN(ttl) || ttl <= 0) {
        throw new Error("delay must be a positive int");
      }
      const age = Date.now() - this._creationTimestamp;
      if (this._timeout) {
        this.removeTimeout();
      }
      this._timeout = setTimeout(fbind(this._fireTimeout, this), Math.max(ttl - age, 0));
    }
    removeTimeout() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeout = null;
    }
    _fireTimeout() {
      this.reject(new errors6.TimeoutError("ResourceRequest timed out"));
    }
    reject(reason) {
      this.removeTimeout();
      super.reject(reason);
    }
    resolve(value26) {
      this.removeTimeout();
      super.resolve(value26);
    }
  }
  module.exports = ResourceRequest;
});

// node_modules/generic-pool/lib/ResourceLoan.js
var require_ResourceLoan = __commonJS((exports, module) => {
  var Deferred3 = require_Deferred();

  class ResourceLoan extends Deferred3 {
    constructor(pooledResource, Promise3) {
      super(Promise3);
      this._creationTimestamp = Date.now();
      this.pooledResource = pooledResource;
    }
    reject() {
    }
  }
  module.exports = ResourceLoan;
});

// node_modules/generic-pool/lib/PooledResourceStateEnum.js
var require_PooledResourceStateEnum = __commonJS((exports, module) => {
  var PooledResourceStateEnum = {
    ALLOCATED: "ALLOCATED",
    IDLE: "IDLE",
    INVALID: "INVALID",
    RETURNING: "RETURNING",
    VALIDATION: "VALIDATION"
  };
  module.exports = PooledResourceStateEnum;
});

// node_modules/generic-pool/lib/PooledResource.js
var require_PooledResource = __commonJS((exports, module) => {
  var PooledResourceStateEnum = require_PooledResourceStateEnum();

  class PooledResource {
    constructor(resource) {
      this.creationTime = Date.now();
      this.lastReturnTime = null;
      this.lastBorrowTime = null;
      this.lastIdleTime = null;
      this.obj = resource;
      this.state = PooledResourceStateEnum.IDLE;
    }
    allocate() {
      this.lastBorrowTime = Date.now();
      this.state = PooledResourceStateEnum.ALLOCATED;
    }
    deallocate() {
      this.lastReturnTime = Date.now();
      this.state = PooledResourceStateEnum.IDLE;
    }
    invalidate() {
      this.state = PooledResourceStateEnum.INVALID;
    }
    test() {
      this.state = PooledResourceStateEnum.VALIDATION;
    }
    idle() {
      this.lastIdleTime = Date.now();
      this.state = PooledResourceStateEnum.IDLE;
    }
    returning() {
      this.state = PooledResourceStateEnum.RETURNING;
    }
  }
  module.exports = PooledResource;
});

// node_modules/generic-pool/lib/DefaultEvictor.js
var require_DefaultEvictor = __commonJS((exports, module) => {
  class DefaultEvictor {
    evict(config, pooledResource, availableObjectsCount) {
      const idleTime = Date.now() - pooledResource.lastIdleTime;
      if (config.softIdleTimeoutMillis > 0 && config.softIdleTimeoutMillis < idleTime && config.min < availableObjectsCount) {
        return true;
      }
      if (config.idleTimeoutMillis < idleTime) {
        return true;
      }
      return false;
    }
  }
  module.exports = DefaultEvictor;
});

// node_modules/generic-pool/lib/DoublyLinkedList.js
var require_DoublyLinkedList = __commonJS((exports, module) => {
  class DoublyLinkedList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    insertBeginning(node) {
      if (this.head === null) {
        this.head = node;
        this.tail = node;
        node.prev = null;
        node.next = null;
        this.length++;
      } else {
        this.insertBefore(this.head, node);
      }
    }
    insertEnd(node) {
      if (this.tail === null) {
        this.insertBeginning(node);
      } else {
        this.insertAfter(this.tail, node);
      }
    }
    insertAfter(node, newNode) {
      newNode.prev = node;
      newNode.next = node.next;
      if (node.next === null) {
        this.tail = newNode;
      } else {
        node.next.prev = newNode;
      }
      node.next = newNode;
      this.length++;
    }
    insertBefore(node, newNode) {
      newNode.prev = node.prev;
      newNode.next = node;
      if (node.prev === null) {
        this.head = newNode;
      } else {
        node.prev.next = newNode;
      }
      node.prev = newNode;
      this.length++;
    }
    remove(node) {
      if (node.prev === null) {
        this.head = node.next;
      } else {
        node.prev.next = node.next;
      }
      if (node.next === null) {
        this.tail = node.prev;
      } else {
        node.next.prev = node.prev;
      }
      node.prev = null;
      node.next = null;
      this.length--;
    }
    static createNode(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
  }
  module.exports = DoublyLinkedList;
});

// node_modules/generic-pool/lib/DoublyLinkedListIterator.js
var require_DoublyLinkedListIterator = __commonJS((exports, module) => {
  class DoublyLinkedListIterator {
    constructor(doublyLinkedList, reverse) {
      this._list = doublyLinkedList;
      this._direction = reverse === true ? "prev" : "next";
      this._startPosition = reverse === true ? "tail" : "head";
      this._started = false;
      this._cursor = null;
      this._done = false;
    }
    _start() {
      this._cursor = this._list[this._startPosition];
      this._started = true;
    }
    _advanceCursor() {
      if (this._started === false) {
        this._started = true;
        this._cursor = this._list[this._startPosition];
        return;
      }
      this._cursor = this._cursor[this._direction];
    }
    reset() {
      this._done = false;
      this._started = false;
      this._cursor = null;
    }
    remove() {
      if (this._started === false || this._done === true || this._isCursorDetached()) {
        return false;
      }
      this._list.remove(this._cursor);
    }
    next() {
      if (this._done === true) {
        return { done: true };
      }
      this._advanceCursor();
      if (this._cursor === null || this._isCursorDetached()) {
        this._done = true;
        return { done: true };
      }
      return {
        value: this._cursor,
        done: false
      };
    }
    _isCursorDetached() {
      return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;
    }
  }
  module.exports = DoublyLinkedListIterator;
});

// node_modules/generic-pool/lib/DequeIterator.js
var require_DequeIterator = __commonJS((exports, module) => {
  var DoublyLinkedListIterator = require_DoublyLinkedListIterator();

  class DequeIterator extends DoublyLinkedListIterator {
    next() {
      const result = super.next();
      if (result.value) {
        result.value = result.value.data;
      }
      return result;
    }
  }
  module.exports = DequeIterator;
});

// node_modules/generic-pool/lib/Deque.js
var require_Deque = __commonJS((exports, module) => {
  var DoublyLinkedList = require_DoublyLinkedList();
  var DequeIterator = require_DequeIterator();

  class Deque {
    constructor() {
      this._list = new DoublyLinkedList;
    }
    shift() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.head;
      this._list.remove(node);
      return node.data;
    }
    unshift(element) {
      const node = DoublyLinkedList.createNode(element);
      this._list.insertBeginning(node);
    }
    push(element) {
      const node = DoublyLinkedList.createNode(element);
      this._list.insertEnd(node);
    }
    pop() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.tail;
      this._list.remove(node);
      return node.data;
    }
    [Symbol.iterator]() {
      return new DequeIterator(this._list);
    }
    iterator() {
      return new DequeIterator(this._list);
    }
    reverseIterator() {
      return new DequeIterator(this._list, true);
    }
    get head() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.head;
      return node.data;
    }
    get tail() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.tail;
      return node.data;
    }
    get length() {
      return this._list.length;
    }
  }
  module.exports = Deque;
});

// node_modules/generic-pool/lib/Queue.js
var require_Queue = __commonJS((exports, module) => {
  var DoublyLinkedList = require_DoublyLinkedList();
  var Deque = require_Deque();

  class Queue extends Deque {
    push(resourceRequest) {
      const node = DoublyLinkedList.createNode(resourceRequest);
      resourceRequest.promise.catch(this._createTimeoutRejectionHandler(node));
      this._list.insertEnd(node);
    }
    _createTimeoutRejectionHandler(node) {
      return (reason) => {
        if (reason.name === "TimeoutError") {
          this._list.remove(node);
        }
      };
    }
  }
  module.exports = Queue;
});

// node_modules/generic-pool/lib/PriorityQueue.js
var require_PriorityQueue = __commonJS((exports, module) => {
  var Queue = require_Queue();

  class PriorityQueue {
    constructor(size) {
      this._size = Math.max(+size | 0, 1);
      this._slots = [];
      for (let i = 0;i < this._size; i++) {
        this._slots.push(new Queue);
      }
    }
    get length() {
      let _length = 0;
      for (let i = 0, slots = this._slots.length;i < slots; i++) {
        _length += this._slots[i].length;
      }
      return _length;
    }
    enqueue(obj, priority) {
      priority = priority && +priority | 0 || 0;
      if (priority) {
        if (priority < 0 || priority >= this._size) {
          priority = this._size - 1;
        }
      }
      this._slots[priority].push(obj);
    }
    dequeue() {
      for (let i = 0, sl = this._slots.length;i < sl; i += 1) {
        if (this._slots[i].length) {
          return this._slots[i].shift();
        }
      }
      return;
    }
    get head() {
      for (let i = 0, sl = this._slots.length;i < sl; i += 1) {
        if (this._slots[i].length > 0) {
          return this._slots[i].head;
        }
      }
      return;
    }
    get tail() {
      for (let i = this._slots.length - 1;i >= 0; i--) {
        if (this._slots[i].length > 0) {
          return this._slots[i].tail;
        }
      }
      return;
    }
  }
  module.exports = PriorityQueue;
});

// node_modules/generic-pool/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  var noop = function() {
  };
  exports.reflector = function(promise2) {
    return promise2.then(noop, noop);
  };
});

// node_modules/generic-pool/lib/Pool.js
var require_Pool = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var factoryValidator = require_factoryValidator();
  var PoolOptions = require_PoolOptions();
  var ResourceRequest = require_ResourceRequest();
  var ResourceLoan = require_ResourceLoan();
  var PooledResource = require_PooledResource();
  var DefaultEvictor = require_DefaultEvictor();
  var Deque = require_Deque();
  var Deferred3 = require_Deferred();
  var PriorityQueue = require_PriorityQueue();
  var DequeIterator = require_DequeIterator();
  var reflector = require_utils4().reflector;
  var FACTORY_CREATE_ERROR = "factoryCreateError";
  var FACTORY_DESTROY_ERROR = "factoryDestroyError";

  class Pool extends EventEmitter {
    constructor(Evictor, Deque2, PriorityQueue2, factory, options) {
      super();
      factoryValidator(factory);
      this._config = new PoolOptions(options);
      this._Promise = this._config.Promise;
      this._factory = factory;
      this._draining = false;
      this._started = false;
      this._waitingClientsQueue = new PriorityQueue2(this._config.priorityRange);
      this._factoryCreateOperations = new Set;
      this._factoryDestroyOperations = new Set;
      this._availableObjects = new Deque2;
      this._testOnBorrowResources = new Set;
      this._testOnReturnResources = new Set;
      this._validationOperations = new Set;
      this._allObjects = new Set;
      this._resourceLoans = new Map;
      this._evictionIterator = this._availableObjects.iterator();
      this._evictor = new Evictor;
      this._scheduledEviction = null;
      if (this._config.autostart === true) {
        this.start();
      }
    }
    _destroy(pooledResource) {
      pooledResource.invalidate();
      this._allObjects.delete(pooledResource);
      const destroyPromise = this._factory.destroy(pooledResource.obj);
      const wrappedDestroyPromise = this._config.destroyTimeoutMillis ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise)) : this._Promise.resolve(destroyPromise);
      this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch((reason) => {
        this.emit(FACTORY_DESTROY_ERROR, reason);
      });
      this._ensureMinimum();
    }
    _applyDestroyTimeout(promise2) {
      const timeoutPromise = new this._Promise((resolve2, reject) => {
        setTimeout(() => {
          reject(new Error("destroy timed out"));
        }, this._config.destroyTimeoutMillis).unref();
      });
      return this._Promise.race([timeoutPromise, promise2]);
    }
    _testOnBorrow() {
      if (this._availableObjects.length < 1) {
        return false;
      }
      const pooledResource = this._availableObjects.shift();
      pooledResource.test();
      this._testOnBorrowResources.add(pooledResource);
      const validationPromise = this._factory.validate(pooledResource.obj);
      const wrappedValidationPromise = this._Promise.resolve(validationPromise);
      this._trackOperation(wrappedValidationPromise, this._validationOperations).then((isValid) => {
        this._testOnBorrowResources.delete(pooledResource);
        if (isValid === false) {
          pooledResource.invalidate();
          this._destroy(pooledResource);
          this._dispense();
          return;
        }
        this._dispatchPooledResourceToNextWaitingClient(pooledResource);
      });
      return true;
    }
    _dispatchResource() {
      if (this._availableObjects.length < 1) {
        return false;
      }
      const pooledResource = this._availableObjects.shift();
      this._dispatchPooledResourceToNextWaitingClient(pooledResource);
      return false;
    }
    _dispense() {
      const numWaitingClients = this._waitingClientsQueue.length;
      if (numWaitingClients < 1) {
        return;
      }
      const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;
      const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);
      for (let i = 0;actualNumberOfResourcesToCreate > i; i++) {
        this._createResource();
      }
      if (this._config.testOnBorrow === true) {
        const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;
        const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);
        for (let i = 0;actualNumberOfResourcesToMoveIntoTest > i; i++) {
          this._testOnBorrow();
        }
      }
      if (this._config.testOnBorrow === false) {
        const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);
        for (let i = 0;actualNumberOfResourcesToDispatch > i; i++) {
          this._dispatchResource();
        }
      }
    }
    _dispatchPooledResourceToNextWaitingClient(pooledResource) {
      const clientResourceRequest = this._waitingClientsQueue.dequeue();
      if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred3.PENDING) {
        this._addPooledResourceToAvailableObjects(pooledResource);
        return false;
      }
      const loan = new ResourceLoan(pooledResource, this._Promise);
      this._resourceLoans.set(pooledResource.obj, loan);
      pooledResource.allocate();
      clientResourceRequest.resolve(pooledResource.obj);
      return true;
    }
    _trackOperation(operation, set2) {
      set2.add(operation);
      return operation.then((v) => {
        set2.delete(operation);
        return this._Promise.resolve(v);
      }, (e) => {
        set2.delete(operation);
        return this._Promise.reject(e);
      });
    }
    _createResource() {
      const factoryPromise = this._factory.create();
      const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then((resource) => {
        const pooledResource = new PooledResource(resource);
        this._allObjects.add(pooledResource);
        this._addPooledResourceToAvailableObjects(pooledResource);
      });
      this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {
        this._dispense();
        return null;
      }).catch((reason) => {
        this.emit(FACTORY_CREATE_ERROR, reason);
        this._dispense();
      });
    }
    _ensureMinimum() {
      if (this._draining === true) {
        return;
      }
      const minShortfall = this._config.min - this._count;
      for (let i = 0;i < minShortfall; i++) {
        this._createResource();
      }
    }
    _evict() {
      const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);
      const evictionConfig = {
        softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,
        idleTimeoutMillis: this._config.idleTimeoutMillis,
        min: this._config.min
      };
      for (let testsHaveRun = 0;testsHaveRun < testsToRun; ) {
        const iterationResult = this._evictionIterator.next();
        if (iterationResult.done === true && this._availableObjects.length < 1) {
          this._evictionIterator.reset();
          return;
        }
        if (iterationResult.done === true && this._availableObjects.length > 0) {
          this._evictionIterator.reset();
          continue;
        }
        const resource = iterationResult.value;
        const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);
        testsHaveRun++;
        if (shouldEvict === true) {
          this._evictionIterator.remove();
          this._destroy(resource);
        }
      }
    }
    _scheduleEvictorRun() {
      if (this._config.evictionRunIntervalMillis > 0) {
        this._scheduledEviction = setTimeout(() => {
          this._evict();
          this._scheduleEvictorRun();
        }, this._config.evictionRunIntervalMillis).unref();
      }
    }
    _descheduleEvictorRun() {
      if (this._scheduledEviction) {
        clearTimeout(this._scheduledEviction);
      }
      this._scheduledEviction = null;
    }
    start() {
      if (this._draining === true) {
        return;
      }
      if (this._started === true) {
        return;
      }
      this._started = true;
      this._scheduleEvictorRun();
      this._ensureMinimum();
    }
    acquire(priority) {
      if (this._started === false && this._config.autostart === false) {
        this.start();
      }
      if (this._draining) {
        return this._Promise.reject(new Error("pool is draining and cannot accept work"));
      }
      if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {
        return this._Promise.reject(new Error("max waitingClients count exceeded"));
      }
      const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);
      this._waitingClientsQueue.enqueue(resourceRequest, priority);
      this._dispense();
      return resourceRequest.promise;
    }
    use(fn, priority) {
      return this.acquire(priority).then((resource) => {
        return fn(resource).then((result) => {
          this.release(resource);
          return result;
        }, (err2) => {
          this.destroy(resource);
          throw err2;
        });
      });
    }
    isBorrowedResource(resource) {
      return this._resourceLoans.has(resource);
    }
    release(resource) {
      const loan = this._resourceLoans.get(resource);
      if (loan === undefined) {
        return this._Promise.reject(new Error("Resource not currently part of this pool"));
      }
      this._resourceLoans.delete(resource);
      loan.resolve();
      const pooledResource = loan.pooledResource;
      pooledResource.deallocate();
      this._addPooledResourceToAvailableObjects(pooledResource);
      this._dispense();
      return this._Promise.resolve();
    }
    destroy(resource) {
      const loan = this._resourceLoans.get(resource);
      if (loan === undefined) {
        return this._Promise.reject(new Error("Resource not currently part of this pool"));
      }
      this._resourceLoans.delete(resource);
      loan.resolve();
      const pooledResource = loan.pooledResource;
      pooledResource.deallocate();
      this._destroy(pooledResource);
      this._dispense();
      return this._Promise.resolve();
    }
    _addPooledResourceToAvailableObjects(pooledResource) {
      pooledResource.idle();
      if (this._config.fifo === true) {
        this._availableObjects.push(pooledResource);
      } else {
        this._availableObjects.unshift(pooledResource);
      }
    }
    drain() {
      this._draining = true;
      return this.__allResourceRequestsSettled().then(() => {
        return this.__allResourcesReturned();
      }).then(() => {
        this._descheduleEvictorRun();
      });
    }
    __allResourceRequestsSettled() {
      if (this._waitingClientsQueue.length > 0) {
        return reflector(this._waitingClientsQueue.tail.promise);
      }
      return this._Promise.resolve();
    }
    __allResourcesReturned() {
      const ps = Array.from(this._resourceLoans.values()).map((loan) => loan.promise).map(reflector);
      return this._Promise.all(ps);
    }
    clear() {
      const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector);
      return this._Promise.all(reflectedCreatePromises).then(() => {
        for (const resource of this._availableObjects) {
          this._destroy(resource);
        }
        const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);
        return reflector(this._Promise.all(reflectedDestroyPromises));
      });
    }
    ready() {
      return new this._Promise((resolve2) => {
        const isReady = () => {
          if (this.available >= this.min) {
            resolve2();
          } else {
            setTimeout(isReady, 100);
          }
        };
        isReady();
      });
    }
    get _potentiallyAllocableResourceCount() {
      return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;
    }
    get _count() {
      return this._allObjects.size + this._factoryCreateOperations.size;
    }
    get spareResourceCapacity() {
      return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);
    }
    get size() {
      return this._count;
    }
    get available() {
      return this._availableObjects.length;
    }
    get borrowed() {
      return this._resourceLoans.size;
    }
    get pending() {
      return this._waitingClientsQueue.length;
    }
    get max() {
      return this._config.max;
    }
    get min() {
      return this._config.min;
    }
  }
  module.exports = Pool;
});

// node_modules/generic-pool/index.js
var require_generic_pool = __commonJS((exports, module) => {
  var Pool = require_Pool();
  var Deque = require_Deque();
  var PriorityQueue = require_PriorityQueue();
  var DefaultEvictor = require_DefaultEvictor();
  module.exports = {
    Pool,
    Deque,
    PriorityQueue,
    DefaultEvictor,
    createPool: function(factory, config) {
      return new Pool(DefaultEvictor, Deque, PriorityQueue, factory, config);
    }
  };
});

// node_modules/@redis/client/dist/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@redis/client",
    version: "1.6.0",
    license: "MIT",
    main: "./dist/index.js",
    types: "./dist/index.d.ts",
    files: [
      "dist/"
    ],
    scripts: {
      test: "nyc -r text-summary -r lcov mocha -r source-map-support/register -r ts-node/register './lib/**/*.spec.ts'",
      build: "tsc",
      lint: "eslint ./*.ts ./lib/**/*.ts",
      documentation: "typedoc"
    },
    dependencies: {
      "cluster-key-slot": "1.1.2",
      "generic-pool": "3.9.0",
      yallist: "4.0.0"
    },
    devDependencies: {
      "@istanbuljs/nyc-config-typescript": "^1.0.2",
      "@redis/test-utils": "*",
      "@types/node": "^20.6.2",
      "@types/sinon": "^10.0.16",
      "@types/yallist": "^4.0.1",
      "@typescript-eslint/eslint-plugin": "^6.7.2",
      "@typescript-eslint/parser": "^6.7.2",
      eslint: "^8.49.0",
      nyc: "^15.1.0",
      "release-it": "^16.1.5",
      sinon: "^16.0.0",
      "source-map-support": "^0.5.21",
      "ts-node": "^10.9.1",
      typedoc: "^0.25.1",
      typescript: "^5.2.2"
    },
    engines: {
      node: ">=14"
    },
    repository: {
      type: "git",
      url: "git://github.com/redis/node-redis.git"
    },
    bugs: {
      url: "https://github.com/redis/node-redis/issues"
    },
    homepage: "https://github.com/redis/node-redis/tree/master/packages/client",
    keywords: [
      "redis"
    ]
  };
});

// node_modules/@redis/client/dist/lib/client/index.js
var require_client = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var _RedisClient_instances;
  var _a2;
  var _RedisClient_options;
  var _RedisClient_socket;
  var _RedisClient_queue;
  var _RedisClient_isolationPool;
  var _RedisClient_v4;
  var _RedisClient_selectedDB;
  var _RedisClient_initiateOptions;
  var _RedisClient_initiateQueue;
  var _RedisClient_initiateSocket;
  var _RedisClient_initiateIsolationPool;
  var _RedisClient_legacyMode;
  var _RedisClient_legacySendCommand;
  var _RedisClient_defineLegacyCommand;
  var _RedisClient_pingTimer;
  var _RedisClient_setPingTimer;
  var _RedisClient_sendCommand;
  var _RedisClient_pubSubCommand;
  var _RedisClient_tick;
  var _RedisClient_addMultiCommands;
  var _RedisClient_destroyIsolationPool;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands2();
  var socket_1 = require_socket();
  var commands_queue_1 = require_commands_queue();
  var multi_command_1 = require_multi_command2();
  var events_1 = import.meta.require("events");
  var command_options_1 = require_command_options();
  var commander_1 = require_commander();
  var generic_pool_1 = require_generic_pool();
  var errors_1 = require_errors3();
  var url_1 = import.meta.require("url");
  var pub_sub_1 = require_pub_sub();
  var package_json_1 = require_package2();

  class RedisClient extends events_1.EventEmitter {
    static commandOptions(options) {
      return (0, command_options_1.commandOptions)(options);
    }
    static extend(extensions2) {
      const Client = (0, commander_1.attachExtensions)({
        BaseClass: _a2,
        modulesExecutor: _a2.prototype.commandsExecutor,
        modules: extensions2?.modules,
        functionsExecutor: _a2.prototype.functionsExecuter,
        functions: extensions2?.functions,
        scriptsExecutor: _a2.prototype.scriptsExecuter,
        scripts: extensions2?.scripts
      });
      if (Client !== _a2) {
        Client.prototype.Multi = multi_command_1.default.extend(extensions2);
      }
      return Client;
    }
    static create(options) {
      return new (_a2.extend(options))(options);
    }
    static parseURL(url) {
      const { hostname, port, protocol, username, password, pathname } = new url_1.URL(url), parsed = {
        socket: {
          host: hostname
        }
      };
      if (protocol === "rediss:") {
        parsed.socket.tls = true;
      } else if (protocol !== "redis:") {
        throw new TypeError("Invalid protocol");
      }
      if (port) {
        parsed.socket.port = Number(port);
      }
      if (username) {
        parsed.username = decodeURIComponent(username);
      }
      if (password) {
        parsed.password = decodeURIComponent(password);
      }
      if (pathname.length > 1) {
        const database = Number(pathname.substring(1));
        if (isNaN(database)) {
          throw new TypeError("Invalid pathname");
        }
        parsed.database = database;
      }
      return parsed;
    }
    get options() {
      return __classPrivateFieldGet2(this, _RedisClient_options, "f");
    }
    get isOpen() {
      return __classPrivateFieldGet2(this, _RedisClient_socket, "f").isOpen;
    }
    get isReady() {
      return __classPrivateFieldGet2(this, _RedisClient_socket, "f").isReady;
    }
    get isPubSubActive() {
      return __classPrivateFieldGet2(this, _RedisClient_queue, "f").isPubSubActive;
    }
    get v4() {
      if (!__classPrivateFieldGet2(this, _RedisClient_options, "f")?.legacyMode) {
        throw new Error('the client is not in "legacy mode"');
      }
      return __classPrivateFieldGet2(this, _RedisClient_v4, "f");
    }
    constructor(options) {
      super();
      _RedisClient_instances.add(this);
      Object.defineProperty(this, "commandOptions", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _a2.commandOptions
      });
      _RedisClient_options.set(this, undefined);
      _RedisClient_socket.set(this, undefined);
      _RedisClient_queue.set(this, undefined);
      _RedisClient_isolationPool.set(this, undefined);
      _RedisClient_v4.set(this, {});
      _RedisClient_selectedDB.set(this, 0);
      _RedisClient_pingTimer.set(this, undefined);
      Object.defineProperty(this, "select", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SELECT
      });
      Object.defineProperty(this, "subscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUBSCRIBE
      });
      Object.defineProperty(this, "unsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.UNSUBSCRIBE
      });
      Object.defineProperty(this, "pSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PSUBSCRIBE
      });
      Object.defineProperty(this, "pUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PUNSUBSCRIBE
      });
      Object.defineProperty(this, "sSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SSUBSCRIBE
      });
      Object.defineProperty(this, "sUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUNSUBSCRIBE
      });
      Object.defineProperty(this, "quit", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.QUIT
      });
      Object.defineProperty(this, "multi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.MULTI
      });
      __classPrivateFieldSet2(this, _RedisClient_options, __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_initiateOptions).call(this, options), "f");
      __classPrivateFieldSet2(this, _RedisClient_queue, __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_initiateQueue).call(this), "f");
      __classPrivateFieldSet2(this, _RedisClient_socket, __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_initiateSocket).call(this), "f");
      __classPrivateFieldSet2(this, _RedisClient_isolationPool, __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_initiateIsolationPool).call(this), "f");
      __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_legacyMode).call(this);
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...__classPrivateFieldGet2(this, _RedisClient_options, "f"),
        ...overrides
      });
    }
    async connect() {
      __classPrivateFieldSet2(this, _RedisClient_isolationPool, __classPrivateFieldGet2(this, _RedisClient_isolationPool, "f") ?? __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_initiateIsolationPool).call(this), "f");
      await __classPrivateFieldGet2(this, _RedisClient_socket, "f").connect();
      return this;
    }
    async commandsExecutor(command, args) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(command, args);
      return (0, commander_1.transformCommandReply)(command, await __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options), redisArgs.preserve);
    }
    sendCommand(args, options) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, args, options);
    }
    async functionsExecuter(fn, args, name) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(fn, args);
      return (0, commander_1.transformCommandReply)(fn, await this.executeFunction(name, fn, redisArgs, options), redisArgs.preserve);
    }
    executeFunction(name, fn, args, options) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, (0, commander_1.fCallArguments)(name, fn, args), options);
    }
    async scriptsExecuter(script, args) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(script, args);
      return (0, commander_1.transformCommandReply)(script, await this.executeScript(script, redisArgs, options), redisArgs.preserve);
    }
    async executeScript(script, args, options) {
      const redisArgs = ["EVALSHA", script.SHA1];
      if (script.NUMBER_OF_KEYS !== undefined) {
        redisArgs.push(script.NUMBER_OF_KEYS.toString());
      }
      redisArgs.push(...args);
      try {
        return await __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options);
      } catch (err2) {
        if (!err2?.message?.startsWith?.("NOSCRIPT")) {
          throw err2;
        }
        redisArgs[0] = "EVAL";
        redisArgs[1] = script.SCRIPT;
        return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options);
      }
    }
    async SELECT(options, db) {
      if (!(0, command_options_1.isCommandOptions)(options)) {
        db = options;
        options = null;
      }
      await __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, ["SELECT", db.toString()], options);
      __classPrivateFieldSet2(this, _RedisClient_selectedDB, db, "f");
    }
    SUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    UNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    PSUBSCRIBE(patterns4, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.PATTERNS, patterns4, listener, bufferMode));
    }
    PUNSUBSCRIBE(patterns4, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.PATTERNS, patterns4, listener, bufferMode));
    }
    SSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    getPubSubListeners(type54) {
      return __classPrivateFieldGet2(this, _RedisClient_queue, "f").getPubSubListeners(type54);
    }
    extendPubSubChannelListeners(type54, channel, listeners) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").extendPubSubChannelListeners(type54, channel, listeners));
    }
    extendPubSubListeners(type54, listeners) {
      return __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet2(this, _RedisClient_queue, "f").extendPubSubListeners(type54, listeners));
    }
    QUIT() {
      return __classPrivateFieldGet2(this, _RedisClient_socket, "f").quit(async () => {
        if (__classPrivateFieldGet2(this, _RedisClient_pingTimer, "f"))
          clearTimeout(__classPrivateFieldGet2(this, _RedisClient_pingTimer, "f"));
        const quitPromise = __classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(["QUIT"]);
        __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
        const [reply] = await Promise.all([
          quitPromise,
          __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_destroyIsolationPool).call(this)
        ]);
        return reply;
      });
    }
    executeIsolated(fn) {
      if (!__classPrivateFieldGet2(this, _RedisClient_isolationPool, "f"))
        return Promise.reject(new errors_1.ClientClosedError);
      return __classPrivateFieldGet2(this, _RedisClient_isolationPool, "f").use(fn);
    }
    MULTI() {
      return new this.Multi(this.multiExecutor.bind(this), __classPrivateFieldGet2(this, _RedisClient_options, "f")?.legacyMode);
    }
    async multiExecutor(commands, selectedDB, chainId) {
      if (!__classPrivateFieldGet2(this, _RedisClient_socket, "f").isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      }
      const promise2 = chainId ? Promise.all([
        __classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(["MULTI"], { chainId }),
        __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_addMultiCommands).call(this, commands, chainId),
        __classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(["EXEC"], { chainId })
      ]) : __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_addMultiCommands).call(this, commands);
      __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
      const results = await promise2;
      if (selectedDB !== undefined) {
        __classPrivateFieldSet2(this, _RedisClient_selectedDB, selectedDB, "f");
      }
      return results;
    }
    async* scanIterator(options) {
      let cursor = 0;
      do {
        const reply = await this.scan(cursor, options);
        cursor = reply.cursor;
        for (const key of reply.keys) {
          yield key;
        }
      } while (cursor !== 0);
    }
    async* hScanIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.hScan(key, cursor, options);
        cursor = reply.cursor;
        for (const tuple6 of reply.tuples) {
          yield tuple6;
        }
      } while (cursor !== 0);
    }
    async* hScanNoValuesIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        for (const k2 of reply.keys) {
          yield k2;
        }
      } while (cursor !== 0);
    }
    async* sScanIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.sScan(key, cursor, options);
        cursor = reply.cursor;
        for (const member of reply.members) {
          yield member;
        }
      } while (cursor !== 0);
    }
    async* zScanIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.zScan(key, cursor, options);
        cursor = reply.cursor;
        for (const member of reply.members) {
          yield member;
        }
      } while (cursor !== 0);
    }
    async disconnect() {
      if (__classPrivateFieldGet2(this, _RedisClient_pingTimer, "f"))
        clearTimeout(__classPrivateFieldGet2(this, _RedisClient_pingTimer, "f"));
      __classPrivateFieldGet2(this, _RedisClient_queue, "f").flushAll(new errors_1.DisconnectsClientError);
      __classPrivateFieldGet2(this, _RedisClient_socket, "f").disconnect();
      await __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_destroyIsolationPool).call(this);
    }
    ref() {
      __classPrivateFieldGet2(this, _RedisClient_socket, "f").ref();
    }
    unref() {
      __classPrivateFieldGet2(this, _RedisClient_socket, "f").unref();
    }
  }
  _a2 = RedisClient, _RedisClient_options = new WeakMap, _RedisClient_socket = new WeakMap, _RedisClient_queue = new WeakMap, _RedisClient_isolationPool = new WeakMap, _RedisClient_v4 = new WeakMap, _RedisClient_selectedDB = new WeakMap, _RedisClient_pingTimer = new WeakMap, _RedisClient_instances = new WeakSet, _RedisClient_initiateOptions = function _RedisClient_initiateOptions(options) {
    if (options?.url) {
      const parsed = _a2.parseURL(options.url);
      if (options.socket) {
        parsed.socket = Object.assign(options.socket, parsed.socket);
      }
      Object.assign(options, parsed);
    }
    if (options?.database) {
      __classPrivateFieldSet2(this, _RedisClient_selectedDB, options.database, "f");
    }
    return options;
  }, _RedisClient_initiateQueue = function _RedisClient_initiateQueue() {
    return new commands_queue_1.default(__classPrivateFieldGet2(this, _RedisClient_options, "f")?.commandsQueueMaxLength, (channel, listeners) => this.emit("sharded-channel-moved", channel, listeners));
  }, _RedisClient_initiateSocket = function _RedisClient_initiateSocket() {
    const socketInitiator = async () => {
      const promises5 = [];
      if (__classPrivateFieldGet2(this, _RedisClient_selectedDB, "f") !== 0) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(["SELECT", __classPrivateFieldGet2(this, _RedisClient_selectedDB, "f").toString()], { asap: true }));
      }
      if (__classPrivateFieldGet2(this, _RedisClient_options, "f")?.readonly) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(commands_1.default.READONLY.transformArguments(), { asap: true }));
      }
      if (!__classPrivateFieldGet2(this, _RedisClient_options, "f")?.disableClientInfo) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(["CLIENT", "SETINFO", "LIB-VER", package_json_1.version], { asap: true }).catch((err2) => {
          if (!(err2 instanceof errors_1.ErrorReply)) {
            throw err2;
          }
        }));
        promises5.push(__classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand([
          "CLIENT",
          "SETINFO",
          "LIB-NAME",
          __classPrivateFieldGet2(this, _RedisClient_options, "f")?.clientInfoTag ? `node-redis(${__classPrivateFieldGet2(this, _RedisClient_options, "f").clientInfoTag})` : "node-redis"
        ], { asap: true }).catch((err2) => {
          if (!(err2 instanceof errors_1.ErrorReply)) {
            throw err2;
          }
        }));
      }
      if (__classPrivateFieldGet2(this, _RedisClient_options, "f")?.name) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(commands_1.default.CLIENT_SETNAME.transformArguments(__classPrivateFieldGet2(this, _RedisClient_options, "f").name), { asap: true }));
      }
      if (__classPrivateFieldGet2(this, _RedisClient_options, "f")?.username || __classPrivateFieldGet2(this, _RedisClient_options, "f")?.password) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(commands_1.default.AUTH.transformArguments({
          username: __classPrivateFieldGet2(this, _RedisClient_options, "f").username,
          password: __classPrivateFieldGet2(this, _RedisClient_options, "f").password ?? ""
        }), { asap: true }));
      }
      const resubscribePromise = __classPrivateFieldGet2(this, _RedisClient_queue, "f").resubscribe();
      if (resubscribePromise) {
        promises5.push(resubscribePromise);
      }
      if (promises5.length) {
        __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this, true);
        await Promise.all(promises5);
      }
    };
    return new socket_1.default(socketInitiator, __classPrivateFieldGet2(this, _RedisClient_options, "f")?.socket).on("data", (chunk) => __classPrivateFieldGet2(this, _RedisClient_queue, "f").onReplyChunk(chunk)).on("error", (err2) => {
      this.emit("error", err2);
      if (__classPrivateFieldGet2(this, _RedisClient_socket, "f").isOpen && !__classPrivateFieldGet2(this, _RedisClient_options, "f")?.disableOfflineQueue) {
        __classPrivateFieldGet2(this, _RedisClient_queue, "f").flushWaitingForReply(err2);
      } else {
        __classPrivateFieldGet2(this, _RedisClient_queue, "f").flushAll(err2);
      }
    }).on("connect", () => {
      this.emit("connect");
    }).on("ready", () => {
      this.emit("ready");
      __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_setPingTimer).call(this);
      __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    }).on("reconnecting", () => this.emit("reconnecting")).on("drain", () => __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this)).on("end", () => this.emit("end"));
  }, _RedisClient_initiateIsolationPool = function _RedisClient_initiateIsolationPool() {
    return (0, generic_pool_1.createPool)({
      create: async () => {
        const duplicate = this.duplicate({
          isolationPoolOptions: undefined
        }).on("error", (err2) => this.emit("error", err2));
        await duplicate.connect();
        return duplicate;
      },
      destroy: (client) => client.disconnect()
    }, __classPrivateFieldGet2(this, _RedisClient_options, "f")?.isolationPoolOptions);
  }, _RedisClient_legacyMode = function _RedisClient_legacyMode() {
    var _b2, _c;
    if (!__classPrivateFieldGet2(this, _RedisClient_options, "f")?.legacyMode)
      return;
    __classPrivateFieldGet2(this, _RedisClient_v4, "f").sendCommand = __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).bind(this);
    this.sendCommand = (...args) => {
      const result = __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_legacySendCommand).call(this, ...args);
      if (result) {
        result.promise.then((reply) => result.callback(null, reply)).catch((err2) => result.callback(err2));
      }
    };
    for (const [name, command] of Object.entries(commands_1.default)) {
      __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, name, command);
      (_b2 = this)[_c = name.toLowerCase()] ?? (_b2[_c] = this[name]);
    }
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "SELECT");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "select");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "SUBSCRIBE");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "subscribe");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "PSUBSCRIBE");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "pSubscribe");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "UNSUBSCRIBE");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "unsubscribe");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "PUNSUBSCRIBE");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "pUnsubscribe");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "QUIT");
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "quit");
  }, _RedisClient_legacySendCommand = function _RedisClient_legacySendCommand(...args) {
    const callback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
    const promise2 = __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, (0, commander_1.transformLegacyCommandArguments)(args));
    if (callback)
      return {
        promise: promise2,
        callback
      };
    promise2.catch((err2) => this.emit("error", err2));
  }, _RedisClient_defineLegacyCommand = function _RedisClient_defineLegacyCommand(name, command) {
    __classPrivateFieldGet2(this, _RedisClient_v4, "f")[name] = this[name].bind(this);
    this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ? (...args) => {
      const result = __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_legacySendCommand).call(this, name, ...args);
      if (result) {
        result.promise.then((reply) => result.callback(null, command.transformReply(reply))).catch((err2) => result.callback(err2));
      }
    } : (...args) => this.sendCommand(name, ...args);
  }, _RedisClient_setPingTimer = function _RedisClient_setPingTimer() {
    if (!__classPrivateFieldGet2(this, _RedisClient_options, "f")?.pingInterval || !__classPrivateFieldGet2(this, _RedisClient_socket, "f").isReady)
      return;
    clearTimeout(__classPrivateFieldGet2(this, _RedisClient_pingTimer, "f"));
    __classPrivateFieldSet2(this, _RedisClient_pingTimer, setTimeout(() => {
      if (!__classPrivateFieldGet2(this, _RedisClient_socket, "f").isReady)
        return;
      __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, ["PING"]).then((reply) => this.emit("ping-interval", reply)).catch((err2) => this.emit("error", err2)).finally(() => __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_setPingTimer).call(this));
    }, __classPrivateFieldGet2(this, _RedisClient_options, "f").pingInterval), "f");
  }, _RedisClient_sendCommand = function _RedisClient_sendCommand(args, options) {
    if (!__classPrivateFieldGet2(this, _RedisClient_socket, "f").isOpen) {
      return Promise.reject(new errors_1.ClientClosedError);
    } else if (options?.isolated) {
      return this.executeIsolated((isolatedClient) => isolatedClient.sendCommand(args, {
        ...options,
        isolated: false
      }));
    } else if (!__classPrivateFieldGet2(this, _RedisClient_socket, "f").isReady && __classPrivateFieldGet2(this, _RedisClient_options, "f")?.disableOfflineQueue) {
      return Promise.reject(new errors_1.ClientOfflineError);
    }
    const promise2 = __classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(args, options);
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    return promise2;
  }, _RedisClient_pubSubCommand = function _RedisClient_pubSubCommand(promise2) {
    if (promise2 === undefined)
      return Promise.resolve();
    __classPrivateFieldGet2(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    return promise2;
  }, _RedisClient_tick = function _RedisClient_tick(force = false) {
    if (__classPrivateFieldGet2(this, _RedisClient_socket, "f").writableNeedDrain || !force && !__classPrivateFieldGet2(this, _RedisClient_socket, "f").isReady) {
      return;
    }
    __classPrivateFieldGet2(this, _RedisClient_socket, "f").cork();
    while (!__classPrivateFieldGet2(this, _RedisClient_socket, "f").writableNeedDrain) {
      const args = __classPrivateFieldGet2(this, _RedisClient_queue, "f").getCommandToSend();
      if (args === undefined)
        break;
      __classPrivateFieldGet2(this, _RedisClient_socket, "f").writeCommand(args);
    }
  }, _RedisClient_addMultiCommands = function _RedisClient_addMultiCommands(commands, chainId) {
    return Promise.all(commands.map(({ args }) => __classPrivateFieldGet2(this, _RedisClient_queue, "f").addCommand(args, { chainId })));
  }, _RedisClient_destroyIsolationPool = async function _RedisClient_destroyIsolationPool() {
    await __classPrivateFieldGet2(this, _RedisClient_isolationPool, "f").drain();
    await __classPrivateFieldGet2(this, _RedisClient_isolationPool, "f").clear();
    __classPrivateFieldSet2(this, _RedisClient_isolationPool, undefined, "f");
  };
  exports.default = RedisClient;
  (0, commander_1.attachCommands)({
    BaseClass: RedisClient,
    commands: commands_1.default,
    executor: RedisClient.prototype.commandsExecutor
  });
  RedisClient.prototype.Multi = multi_command_1.default;
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p++] = char;
      } else if (char < 2048) {
        utf8[p++] = char >> 6 | 192;
        utf8[p++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p++] = char >> 18 | 240;
        utf8[p++] = char >> 12 & 63 | 128;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      } else {
        utf8[p++] = char >> 12 | 224;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate2 = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
    }
    return result & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate2(keys[0]);
    while (i < len) {
      if (generate2(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// node_modules/@redis/client/dist/lib/cluster/cluster-slots.js
var require_cluster_slots = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var _RedisClusterSlots_instances;
  var _a2;
  var _RedisClusterSlots_SLOTS;
  var _RedisClusterSlots_options;
  var _RedisClusterSlots_Client;
  var _RedisClusterSlots_emit;
  var _RedisClusterSlots_isOpen;
  var _RedisClusterSlots_discoverWithRootNodes;
  var _RedisClusterSlots_resetSlots;
  var _RedisClusterSlots_discover;
  var _RedisClusterSlots_getShards;
  var _RedisClusterSlots_getNodeAddress;
  var _RedisClusterSlots_clientOptionsDefaults;
  var _RedisClusterSlots_initiateSlotNode;
  var _RedisClusterSlots_createClient;
  var _RedisClusterSlots_createNodeClient;
  var _RedisClusterSlots_runningRediscoverPromise;
  var _RedisClusterSlots_rediscover;
  var _RedisClusterSlots_destroy;
  var _RedisClusterSlots_execOnNodeClient;
  var _RedisClusterSlots_iterateAllNodes;
  var _RedisClusterSlots_randomNodeIterator;
  var _RedisClusterSlots_slotNodesIterator;
  var _RedisClusterSlots_initiatePubSubClient;
  var _RedisClusterSlots_initiateShardedPubSubClient;
  Object.defineProperty(exports, "__esModule", { value: true });
  var client_1 = require_client();
  var errors_1 = require_errors3();
  var util_1 = import.meta.require("util");
  var pub_sub_1 = require_pub_sub();
  var calculateSlot = require_lib();

  class RedisClusterSlots {
    get isOpen() {
      return __classPrivateFieldGet2(this, _RedisClusterSlots_isOpen, "f");
    }
    constructor(options, emit) {
      _RedisClusterSlots_instances.add(this);
      _RedisClusterSlots_options.set(this, undefined);
      _RedisClusterSlots_Client.set(this, undefined);
      _RedisClusterSlots_emit.set(this, undefined);
      Object.defineProperty(this, "slots", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array(__classPrivateFieldGet2(_a2, _a2, "f", _RedisClusterSlots_SLOTS))
      });
      Object.defineProperty(this, "shards", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array
      });
      Object.defineProperty(this, "masters", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array
      });
      Object.defineProperty(this, "replicas", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array
      });
      Object.defineProperty(this, "nodeByAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Map
      });
      Object.defineProperty(this, "pubSubNode", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      _RedisClusterSlots_isOpen.set(this, false);
      _RedisClusterSlots_runningRediscoverPromise.set(this, undefined);
      _RedisClusterSlots_randomNodeIterator.set(this, undefined);
      __classPrivateFieldSet2(this, _RedisClusterSlots_options, options, "f");
      __classPrivateFieldSet2(this, _RedisClusterSlots_Client, client_1.default.extend(options), "f");
      __classPrivateFieldSet2(this, _RedisClusterSlots_emit, emit, "f");
    }
    async connect() {
      if (__classPrivateFieldGet2(this, _RedisClusterSlots_isOpen, "f")) {
        throw new Error("Cluster already open");
      }
      __classPrivateFieldSet2(this, _RedisClusterSlots_isOpen, true, "f");
      try {
        await __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discoverWithRootNodes).call(this);
      } catch (err2) {
        __classPrivateFieldSet2(this, _RedisClusterSlots_isOpen, false, "f");
        throw err2;
      }
    }
    nodeClient(node) {
      return node.client ?? __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createNodeClient).call(this, node);
    }
    async rediscover(startWith) {
      __classPrivateFieldSet2(this, _RedisClusterSlots_runningRediscoverPromise, __classPrivateFieldGet2(this, _RedisClusterSlots_runningRediscoverPromise, "f") ?? __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_rediscover).call(this, startWith).finally(() => __classPrivateFieldSet2(this, _RedisClusterSlots_runningRediscoverPromise, undefined, "f")), "f");
      return __classPrivateFieldGet2(this, _RedisClusterSlots_runningRediscoverPromise, "f");
    }
    quit() {
      return __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_destroy).call(this, (client) => client.quit());
    }
    disconnect() {
      return __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_destroy).call(this, (client) => client.disconnect());
    }
    getClient(firstKey, isReadonly) {
      if (!firstKey) {
        return this.nodeClient(this.getRandomNode());
      }
      const slotNumber = calculateSlot(firstKey);
      if (!isReadonly) {
        return this.nodeClient(this.slots[slotNumber].master);
      }
      return this.nodeClient(this.getSlotRandomNode(slotNumber));
    }
    getRandomNode() {
      __classPrivateFieldSet2(this, _RedisClusterSlots_randomNodeIterator, __classPrivateFieldGet2(this, _RedisClusterSlots_randomNodeIterator, "f") ?? __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_iterateAllNodes).call(this), "f");
      return __classPrivateFieldGet2(this, _RedisClusterSlots_randomNodeIterator, "f").next().value;
    }
    getSlotRandomNode(slotNumber) {
      const slot = this.slots[slotNumber];
      if (!slot.replicas?.length) {
        return slot.master;
      }
      slot.nodesIterator ?? (slot.nodesIterator = __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_slotNodesIterator).call(this, slot));
      return slot.nodesIterator.next().value;
    }
    getMasterByAddress(address) {
      const master = this.nodeByAddress.get(address);
      if (!master)
        return;
      return this.nodeClient(master);
    }
    getPubSubClient() {
      return this.pubSubNode ? this.pubSubNode.client : __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiatePubSubClient).call(this);
    }
    async executeUnsubscribeCommand(unsubscribe) {
      const client = await this.getPubSubClient();
      await unsubscribe(client);
      if (!client.isPubSubActive && client.isOpen) {
        await client.disconnect();
        this.pubSubNode = undefined;
      }
    }
    getShardedPubSubClient(channel) {
      const { master } = this.slots[calculateSlot(channel)];
      return master.pubSubClient ?? __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiateShardedPubSubClient).call(this, master);
    }
    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
      const { master } = this.slots[calculateSlot(channel)];
      if (!master.pubSubClient)
        return Promise.resolve();
      const client = await master.pubSubClient;
      await unsubscribe(client);
      if (!client.isPubSubActive && client.isOpen) {
        await client.disconnect();
        master.pubSubClient = undefined;
      }
    }
  }
  _a2 = RedisClusterSlots, _RedisClusterSlots_options = new WeakMap, _RedisClusterSlots_Client = new WeakMap, _RedisClusterSlots_emit = new WeakMap, _RedisClusterSlots_isOpen = new WeakMap, _RedisClusterSlots_runningRediscoverPromise = new WeakMap, _RedisClusterSlots_randomNodeIterator = new WeakMap, _RedisClusterSlots_instances = new WeakSet, _RedisClusterSlots_discoverWithRootNodes = async function _RedisClusterSlots_discoverWithRootNodes() {
    let start = Math.floor(Math.random() * __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").rootNodes.length);
    for (let i = start;i < __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").rootNodes.length; i++) {
      if (await __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discover).call(this, __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").rootNodes[i]))
        return;
    }
    for (let i = 0;i < start; i++) {
      if (await __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discover).call(this, __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").rootNodes[i]))
        return;
    }
    throw new errors_1.RootNodesUnavailableError;
  }, _RedisClusterSlots_resetSlots = function _RedisClusterSlots_resetSlots() {
    this.slots = new Array(__classPrivateFieldGet2(_a2, _a2, "f", _RedisClusterSlots_SLOTS));
    this.shards = [];
    this.masters = [];
    this.replicas = [];
    __classPrivateFieldSet2(this, _RedisClusterSlots_randomNodeIterator, undefined, "f");
  }, _RedisClusterSlots_discover = async function _RedisClusterSlots_discover(rootNode) {
    const addressesInUse = new Set;
    try {
      const shards = await __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_getShards).call(this, rootNode), promises5 = [], eagerConnect = __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").minimizeConnections !== true;
      __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_resetSlots).call(this);
      for (const { from, to, master, replicas } of shards) {
        const shard = {
          master: __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiateSlotNode).call(this, master, false, eagerConnect, addressesInUse, promises5)
        };
        if (__classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").useReplicas) {
          shard.replicas = replicas.map((replica) => __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiateSlotNode).call(this, replica, true, eagerConnect, addressesInUse, promises5));
        }
        this.shards.push(shard);
        for (let i = from;i <= to; i++) {
          this.slots[i] = shard;
        }
      }
      if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
        if (util_1.types.isPromise(this.pubSubNode.client)) {
          promises5.push(this.pubSubNode.client.then((client) => client.disconnect()));
          this.pubSubNode = undefined;
        } else {
          promises5.push(this.pubSubNode.client.disconnect());
          const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PubSubType.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PubSubType.PATTERNS);
          if (channelsListeners.size || patternsListeners.size) {
            promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiatePubSubClient).call(this, {
              [pub_sub_1.PubSubType.CHANNELS]: channelsListeners,
              [pub_sub_1.PubSubType.PATTERNS]: patternsListeners
            }));
          }
        }
      }
      for (const [address, node] of this.nodeByAddress.entries()) {
        if (addressesInUse.has(address))
          continue;
        if (node.client) {
          promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, node.client, (client) => client.disconnect()));
        }
        const { pubSubClient } = node;
        if (pubSubClient) {
          promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, pubSubClient, (client) => client.disconnect()));
        }
        this.nodeByAddress.delete(address);
      }
      await Promise.all(promises5);
      return true;
    } catch (err2) {
      __classPrivateFieldGet2(this, _RedisClusterSlots_emit, "f").call(this, "error", err2);
      return false;
    }
  }, _RedisClusterSlots_getShards = async function _RedisClusterSlots_getShards(rootNode) {
    const client = new (__classPrivateFieldGet2(this, _RedisClusterSlots_Client, "f"))(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_clientOptionsDefaults).call(this, rootNode, true));
    client.on("error", (err2) => __classPrivateFieldGet2(this, _RedisClusterSlots_emit, "f").call(this, "error", err2));
    await client.connect();
    try {
      return await client.clusterSlots();
    } finally {
      await client.disconnect();
    }
  }, _RedisClusterSlots_getNodeAddress = function _RedisClusterSlots_getNodeAddress(address) {
    switch (typeof __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").nodeAddressMap) {
      case "object":
        return __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").nodeAddressMap[address];
      case "function":
        return __classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").nodeAddressMap(address);
    }
  }, _RedisClusterSlots_clientOptionsDefaults = function _RedisClusterSlots_clientOptionsDefaults(options, disableReconnect) {
    let result;
    if (__classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").defaults) {
      let socket;
      if (__classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").defaults.socket) {
        socket = {
          ...__classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").defaults.socket,
          ...options?.socket
        };
      } else {
        socket = options?.socket;
      }
      result = {
        ...__classPrivateFieldGet2(this, _RedisClusterSlots_options, "f").defaults,
        ...options,
        socket
      };
    } else {
      result = options;
    }
    if (disableReconnect) {
      result ?? (result = {});
      result.socket ?? (result.socket = {});
      result.socket.reconnectStrategy = false;
    }
    return result;
  }, _RedisClusterSlots_initiateSlotNode = function _RedisClusterSlots_initiateSlotNode({ id, ip, port }, readonly6, eagerConnent, addressesInUse, promises5) {
    const address = `${ip}:${port}`;
    addressesInUse.add(address);
    let node = this.nodeByAddress.get(address);
    if (!node) {
      node = {
        id,
        host: ip,
        port,
        address,
        readonly: readonly6,
        client: undefined
      };
      if (eagerConnent) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createNodeClient).call(this, node));
      }
      this.nodeByAddress.set(address, node);
    }
    (readonly6 ? this.replicas : this.masters).push(node);
    return node;
  }, _RedisClusterSlots_createClient = async function _RedisClusterSlots_createClient(node, readonly6 = node.readonly) {
    const client = new (__classPrivateFieldGet2(this, _RedisClusterSlots_Client, "f"))(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_clientOptionsDefaults).call(this, {
      socket: __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_getNodeAddress).call(this, node.address) ?? {
        host: node.host,
        port: node.port
      },
      readonly: readonly6
    }));
    client.on("error", (err2) => __classPrivateFieldGet2(this, _RedisClusterSlots_emit, "f").call(this, "error", err2));
    await client.connect();
    return client;
  }, _RedisClusterSlots_createNodeClient = function _RedisClusterSlots_createNodeClient(node) {
    const promise2 = __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createClient).call(this, node).then((client) => {
      node.client = client;
      return client;
    }).catch((err2) => {
      node.client = undefined;
      throw err2;
    });
    node.client = promise2;
    return promise2;
  }, _RedisClusterSlots_rediscover = async function _RedisClusterSlots_rediscover(startWith) {
    if (await __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discover).call(this, startWith.options))
      return;
    return __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discoverWithRootNodes).call(this);
  }, _RedisClusterSlots_destroy = async function _RedisClusterSlots_destroy(fn) {
    __classPrivateFieldSet2(this, _RedisClusterSlots_isOpen, false, "f");
    const promises5 = [];
    for (const { master, replicas } of this.shards) {
      if (master.client) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, master.client, fn));
      }
      if (master.pubSubClient) {
        promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, master.pubSubClient, fn));
      }
      if (replicas) {
        for (const { client } of replicas) {
          if (client) {
            promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, client, fn));
          }
        }
      }
    }
    if (this.pubSubNode) {
      promises5.push(__classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, this.pubSubNode.client, fn));
      this.pubSubNode = undefined;
    }
    __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_resetSlots).call(this);
    this.nodeByAddress.clear();
    await Promise.allSettled(promises5);
  }, _RedisClusterSlots_execOnNodeClient = function _RedisClusterSlots_execOnNodeClient(client, fn) {
    return util_1.types.isPromise(client) ? client.then(fn) : fn(client);
  }, _RedisClusterSlots_iterateAllNodes = function* _RedisClusterSlots_iterateAllNodes() {
    let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
    if (i < this.masters.length) {
      do {
        yield this.masters[i];
      } while (++i < this.masters.length);
      for (const replica of this.replicas) {
        yield replica;
      }
    } else {
      i -= this.masters.length;
      do {
        yield this.replicas[i];
      } while (++i < this.replicas.length);
    }
    while (true) {
      for (const master of this.masters) {
        yield master;
      }
      for (const replica of this.replicas) {
        yield replica;
      }
    }
  }, _RedisClusterSlots_slotNodesIterator = function* _RedisClusterSlots_slotNodesIterator(slot) {
    let i = Math.floor(Math.random() * (1 + slot.replicas.length));
    if (i < slot.replicas.length) {
      do {
        yield slot.replicas[i];
      } while (++i < slot.replicas.length);
    }
    while (true) {
      yield slot.master;
      for (const replica of slot.replicas) {
        yield replica;
      }
    }
  }, _RedisClusterSlots_initiatePubSubClient = async function _RedisClusterSlots_initiatePubSubClient(toResubscribe) {
    const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ? this.masters[index] : this.replicas[index - this.masters.length];
    this.pubSubNode = {
      address: node.address,
      client: __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createClient).call(this, node, false).then(async (client) => {
        if (toResubscribe) {
          await Promise.all([
            client.extendPubSubListeners(pub_sub_1.PubSubType.CHANNELS, toResubscribe[pub_sub_1.PubSubType.CHANNELS]),
            client.extendPubSubListeners(pub_sub_1.PubSubType.PATTERNS, toResubscribe[pub_sub_1.PubSubType.PATTERNS])
          ]);
        }
        this.pubSubNode.client = client;
        return client;
      }).catch((err2) => {
        this.pubSubNode = undefined;
        throw err2;
      })
    };
    return this.pubSubNode.client;
  }, _RedisClusterSlots_initiateShardedPubSubClient = function _RedisClusterSlots_initiateShardedPubSubClient(master) {
    const promise2 = __classPrivateFieldGet2(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createClient).call(this, master, false).then((client) => {
      client.on("server-sunsubscribe", async (channel, listeners) => {
        try {
          await this.rediscover(client);
          const redirectTo = await this.getShardedPubSubClient(channel);
          redirectTo.extendPubSubChannelListeners(pub_sub_1.PubSubType.SHARDED, channel, listeners);
        } catch (err2) {
          __classPrivateFieldGet2(this, _RedisClusterSlots_emit, "f").call(this, "sharded-shannel-moved-error", err2, channel, listeners);
        }
      });
      master.pubSubClient = client;
      return client;
    }).catch((err2) => {
      master.pubSubClient = undefined;
      throw err2;
    });
    master.pubSubClient = promise2;
    return promise2;
  };
  _RedisClusterSlots_SLOTS = { value: 16384 };
  exports.default = RedisClusterSlots;
});

// node_modules/@redis/client/dist/lib/cluster/multi-command.js
var require_multi_command3 = __commonJS((exports) => {
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _RedisClusterMultiCommand_multi;
  var _RedisClusterMultiCommand_executor;
  var _RedisClusterMultiCommand_firstKey;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands();
  var multi_command_1 = require_multi_command();
  var commander_1 = require_commander();
  var _1 = require_cluster2();

  class RedisClusterMultiCommand {
    static extend(extensions2) {
      return (0, commander_1.attachExtensions)({
        BaseClass: RedisClusterMultiCommand,
        modulesExecutor: RedisClusterMultiCommand.prototype.commandsExecutor,
        modules: extensions2?.modules,
        functionsExecutor: RedisClusterMultiCommand.prototype.functionsExecutor,
        functions: extensions2?.functions,
        scriptsExecutor: RedisClusterMultiCommand.prototype.scriptsExecutor,
        scripts: extensions2?.scripts
      });
    }
    constructor(executor, firstKey) {
      _RedisClusterMultiCommand_multi.set(this, new multi_command_1.default);
      _RedisClusterMultiCommand_executor.set(this, undefined);
      _RedisClusterMultiCommand_firstKey.set(this, undefined);
      Object.defineProperty(this, "EXEC", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.exec
      });
      __classPrivateFieldSet2(this, _RedisClusterMultiCommand_executor, executor, "f");
      __classPrivateFieldSet2(this, _RedisClusterMultiCommand_firstKey, firstKey, "f");
    }
    commandsExecutor(command, args) {
      const transformedArguments = command.transformArguments(...args);
      __classPrivateFieldSet2(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_firstKey, "f") ?? _1.default.extractFirstKey(command, args, transformedArguments), "f");
      return this.addCommand(undefined, transformedArguments, command.transformReply);
    }
    addCommand(firstKey, args, transformReply) {
      __classPrivateFieldSet2(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_firstKey, "f") ?? firstKey, "f");
      __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").addCommand(args, transformReply);
      return this;
    }
    functionsExecutor(fn, args, name) {
      const transformedArguments = __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").addFunction(name, fn, args);
      __classPrivateFieldSet2(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_firstKey, "f") ?? _1.default.extractFirstKey(fn, args, transformedArguments), "f");
      return this;
    }
    scriptsExecutor(script, args) {
      const transformedArguments = __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").addScript(script, args);
      __classPrivateFieldSet2(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_firstKey, "f") ?? _1.default.extractFirstKey(script, args, transformedArguments), "f");
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline) {
        return this.execAsPipeline();
      }
      return __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").handleExecReplies(await __classPrivateFieldGet2(this, _RedisClusterMultiCommand_executor, "f").call(this, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").queue, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_firstKey, "f"), multi_command_1.default.generateChainId()));
    }
    async execAsPipeline() {
      return __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").transformReplies(await __classPrivateFieldGet2(this, _RedisClusterMultiCommand_executor, "f").call(this, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_multi, "f").queue, __classPrivateFieldGet2(this, _RedisClusterMultiCommand_firstKey, "f")));
    }
  }
  _RedisClusterMultiCommand_multi = new WeakMap, _RedisClusterMultiCommand_executor = new WeakMap, _RedisClusterMultiCommand_firstKey = new WeakMap;
  exports.default = RedisClusterMultiCommand;
  (0, commander_1.attachCommands)({
    BaseClass: RedisClusterMultiCommand,
    commands: commands_1.default,
    executor: RedisClusterMultiCommand.prototype.commandsExecutor
  });
});

// node_modules/@redis/client/dist/lib/cluster/index.js
var require_cluster2 = __commonJS((exports) => {
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var _RedisCluster_instances;
  var _RedisCluster_options;
  var _RedisCluster_slots;
  var _RedisCluster_Multi;
  var _RedisCluster_execute;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands();
  var cluster_slots_1 = require_cluster_slots();
  var commander_1 = require_commander();
  var events_1 = import.meta.require("events");
  var multi_command_1 = require_multi_command3();
  var errors_1 = require_errors3();

  class RedisCluster extends events_1.EventEmitter {
    static extractFirstKey(command, originalArgs, redisArgs) {
      if (command.FIRST_KEY_INDEX === undefined) {
        return;
      } else if (typeof command.FIRST_KEY_INDEX === "number") {
        return redisArgs[command.FIRST_KEY_INDEX];
      }
      return command.FIRST_KEY_INDEX(...originalArgs);
    }
    static create(options) {
      return new ((0, commander_1.attachExtensions)({
        BaseClass: RedisCluster,
        modulesExecutor: RedisCluster.prototype.commandsExecutor,
        modules: options?.modules,
        functionsExecutor: RedisCluster.prototype.functionsExecutor,
        functions: options?.functions,
        scriptsExecutor: RedisCluster.prototype.scriptsExecutor,
        scripts: options?.scripts
      }))(options);
    }
    get slots() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").slots;
    }
    get shards() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").shards;
    }
    get masters() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").masters;
    }
    get replicas() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").replicas;
    }
    get nodeByAddress() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").nodeByAddress;
    }
    get pubSubNode() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").pubSubNode;
    }
    get isOpen() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").isOpen;
    }
    constructor(options) {
      super();
      _RedisCluster_instances.add(this);
      _RedisCluster_options.set(this, undefined);
      _RedisCluster_slots.set(this, undefined);
      _RedisCluster_Multi.set(this, undefined);
      Object.defineProperty(this, "multi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.MULTI
      });
      Object.defineProperty(this, "subscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUBSCRIBE
      });
      Object.defineProperty(this, "unsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.UNSUBSCRIBE
      });
      Object.defineProperty(this, "pSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PSUBSCRIBE
      });
      Object.defineProperty(this, "pUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PUNSUBSCRIBE
      });
      Object.defineProperty(this, "sSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SSUBSCRIBE
      });
      Object.defineProperty(this, "sUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUNSUBSCRIBE
      });
      __classPrivateFieldSet2(this, _RedisCluster_options, options, "f");
      __classPrivateFieldSet2(this, _RedisCluster_slots, new cluster_slots_1.default(options, this.emit.bind(this)), "f");
      __classPrivateFieldSet2(this, _RedisCluster_Multi, multi_command_1.default.extend(options), "f");
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...__classPrivateFieldGet2(this, _RedisCluster_options, "f"),
        ...overrides
      });
    }
    connect() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").connect();
    }
    async commandsExecutor(command, args) {
      const { jsArgs, args: redisArgs, options } = (0, commander_1.transformCommandArguments)(command, args);
      return (0, commander_1.transformCommandReply)(command, await this.sendCommand(RedisCluster.extractFirstKey(command, jsArgs, redisArgs), command.IS_READ_ONLY, redisArgs, options), redisArgs.preserve);
    }
    async sendCommand(firstKey, isReadonly, args, options) {
      return __classPrivateFieldGet2(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, firstKey, isReadonly, (client) => client.sendCommand(args, options));
    }
    async functionsExecutor(fn, args, name) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(fn, args);
      return (0, commander_1.transformCommandReply)(fn, await this.executeFunction(name, fn, args, redisArgs, options), redisArgs.preserve);
    }
    async executeFunction(name, fn, originalArgs, redisArgs, options) {
      return __classPrivateFieldGet2(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, RedisCluster.extractFirstKey(fn, originalArgs, redisArgs), fn.IS_READ_ONLY, (client) => client.executeFunction(name, fn, redisArgs, options));
    }
    async scriptsExecutor(script, args) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(script, args);
      return (0, commander_1.transformCommandReply)(script, await this.executeScript(script, args, redisArgs, options), redisArgs.preserve);
    }
    async executeScript(script, originalArgs, redisArgs, options) {
      return __classPrivateFieldGet2(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, RedisCluster.extractFirstKey(script, originalArgs, redisArgs), script.IS_READ_ONLY, (client) => client.executeScript(script, redisArgs, options));
    }
    MULTI(routing) {
      return new (__classPrivateFieldGet2(this, _RedisCluster_Multi, "f"))((commands, firstKey, chainId) => {
        return __classPrivateFieldGet2(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, firstKey, false, (client) => client.multiExecutor(commands, undefined, chainId));
      }, routing);
    }
    async SUBSCRIBE(channels, listener, bufferMode) {
      return (await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getPubSubClient()).SUBSCRIBE(channels, listener, bufferMode);
    }
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").executeUnsubscribeCommand((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    async PSUBSCRIBE(patterns4, listener, bufferMode) {
      return (await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getPubSubClient()).PSUBSCRIBE(patterns4, listener, bufferMode);
    }
    async PUNSUBSCRIBE(patterns4, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").executeUnsubscribeCommand((client) => client.PUNSUBSCRIBE(patterns4, listener, bufferMode));
    }
    async SSUBSCRIBE(channels, listener, bufferMode) {
      const maxCommandRedirections = __classPrivateFieldGet2(this, _RedisCluster_options, "f").maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
      let client = await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getShardedPubSubClient(firstChannel);
      for (let i = 0;; i++) {
        try {
          return await client.SSUBSCRIBE(channels, listener, bufferMode);
        } catch (err2) {
          if (++i > maxCommandRedirections || !(err2 instanceof errors_1.ErrorReply)) {
            throw err2;
          }
          if (err2.message.startsWith("MOVED")) {
            await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").rediscover(client);
            client = await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getShardedPubSubClient(firstChannel);
            continue;
          }
          throw err2;
        }
      }
    }
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, (client) => client.SUNSUBSCRIBE(channels, listener, bufferMode));
    }
    quit() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").quit();
    }
    disconnect() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").disconnect();
    }
    nodeClient(node) {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").nodeClient(node);
    }
    getRandomNode() {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getRandomNode();
    }
    getSlotRandomNode(slot) {
      return __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getSlotRandomNode(slot);
    }
    getMasters() {
      return this.masters;
    }
    getSlotMaster(slot) {
      return this.slots[slot].master;
    }
  }
  _RedisCluster_options = new WeakMap, _RedisCluster_slots = new WeakMap, _RedisCluster_Multi = new WeakMap, _RedisCluster_instances = new WeakSet, _RedisCluster_execute = async function _RedisCluster_execute(firstKey, isReadonly, executor) {
    const maxCommandRedirections = __classPrivateFieldGet2(this, _RedisCluster_options, "f").maxCommandRedirections ?? 16;
    let client = await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getClient(firstKey, isReadonly);
    for (let i = 0;; i++) {
      try {
        return await executor(client);
      } catch (err2) {
        if (++i > maxCommandRedirections || !(err2 instanceof errors_1.ErrorReply)) {
          throw err2;
        }
        if (err2.message.startsWith("ASK")) {
          const address = err2.message.substring(err2.message.lastIndexOf(" ") + 1);
          let redirectTo = await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getMasterByAddress(address);
          if (!redirectTo) {
            await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").rediscover(client);
            redirectTo = await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getMasterByAddress(address);
          }
          if (!redirectTo) {
            throw new Error(`Cannot find node ${address}`);
          }
          await redirectTo.asking();
          client = redirectTo;
          continue;
        } else if (err2.message.startsWith("MOVED")) {
          await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").rediscover(client);
          client = await __classPrivateFieldGet2(this, _RedisCluster_slots, "f").getClient(firstKey, isReadonly);
          continue;
        }
        throw err2;
      }
    }
  };
  exports.default = RedisCluster;
  (0, commander_1.attachCommands)({
    BaseClass: RedisCluster,
    commands: commands_1.default,
    executor: RedisCluster.prototype.commandsExecutor
  });
});

// node_modules/@redis/client/dist/lib/lua-script.js
var require_lua_script = __commonJS((exports) => {
  var defineScript = function(script) {
    return {
      ...script,
      SHA1: scriptSha1(script.SCRIPT)
    };
  };
  var scriptSha1 = function(script) {
    return (0, crypto_1.createHash)("sha1").update(script).digest("hex");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptSha1 = exports.defineScript = undefined;
  var crypto_1 = import.meta.require("crypto");
  exports.defineScript = defineScript;
  exports.scriptSha1 = scriptSha1;
});

// node_modules/@redis/client/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisFlushModes = exports.GeoReplyWith = exports.defineScript = exports.createCluster = exports.commandOptions = exports.createClient = undefined;
  var client_1 = require_client();
  var cluster_1 = require_cluster2();
  exports.createClient = client_1.default.create;
  exports.commandOptions = client_1.default.commandOptions;
  exports.createCluster = cluster_1.default.create;
  var lua_script_1 = require_lua_script();
  Object.defineProperty(exports, "defineScript", { enumerable: true, get: function() {
    return lua_script_1.defineScript;
  } });
  __exportStar(require_errors3(), exports);
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "GeoReplyWith", { enumerable: true, get: function() {
    return generic_transformers_1.GeoReplyWith;
  } });
  var FLUSHALL_1 = require_FLUSHALL();
  Object.defineProperty(exports, "RedisFlushModes", { enumerable: true, get: function() {
    return FLUSHALL_1.RedisFlushModes;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/ADD.js
var require_ADD = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["BF.ADD", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/CARD.js
var require_CARD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["BF.CARD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/bloom/EXISTS.js
var require_EXISTS2 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["BF.EXISTS", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/INFO.js
var require_INFO2 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["BF.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      capacity: reply[1],
      size: reply[3],
      numberOfFilters: reply[5],
      numberOfInsertedItems: reply[7],
      expansionRate: reply[9]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/bloom/INSERT.js
var require_INSERT = __commonJS((exports) => {
  var transformArguments = function(key, items, options) {
    const args = ["BF.INSERT", key];
    if (options?.CAPACITY) {
      args.push("CAPACITY", options.CAPACITY.toString());
    }
    if (options?.ERROR) {
      args.push("ERROR", options.ERROR.toString());
    }
    if (options?.EXPANSION) {
      args.push("EXPANSION", options.EXPANSION.toString());
    }
    if (options?.NOCREATE) {
      args.push("NOCREATE");
    }
    if (options?.NONSCALING) {
      args.push("NONSCALING");
    }
    args.push("ITEMS");
    return (0, generic_transformers_1.pushVerdictArguments)(args, items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/LOADCHUNK.js
var require_LOADCHUNK = __commonJS((exports) => {
  var transformArguments = function(key, iteretor, chunk) {
    return ["BF.LOADCHUNK", key, iteretor.toString(), chunk];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/bloom/MADD.js
var require_MADD = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return ["BF.MADD", key, ...items];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/MEXISTS.js
var require_MEXISTS = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return ["BF.MEXISTS", key, ...items];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/RESERVE.js
var require_RESERVE = __commonJS((exports) => {
  var transformArguments = function(key, errorRate, capacity, options) {
    const args = ["BF.RESERVE", key, errorRate.toString(), capacity.toString()];
    if (options?.EXPANSION) {
      args.push("EXPANSION", options.EXPANSION.toString());
    }
    if (options?.NONSCALING) {
      args.push("NONSCALING");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/bloom/SCANDUMP.js
var require_SCANDUMP = __commonJS((exports) => {
  var transformArguments = function(key, iterator3) {
    return ["BF.SCANDUMP", key, iterator3.toString()];
  };
  var transformReply = function([iterator3, chunk]) {
    return {
      iterator: iterator3,
      chunk
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/bloom/index.js
var require_bloom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD = require_ADD();
  var CARD = require_CARD();
  var EXISTS = require_EXISTS2();
  var INFO = require_INFO2();
  var INSERT = require_INSERT();
  var LOADCHUNK = require_LOADCHUNK();
  var MADD = require_MADD();
  var MEXISTS = require_MEXISTS();
  var RESERVE = require_RESERVE();
  var SCANDUMP = require_SCANDUMP();
  exports.default = {
    ADD,
    add: ADD,
    CARD,
    card: CARD,
    EXISTS,
    exists: EXISTS,
    INFO,
    info: INFO,
    INSERT,
    insert: INSERT,
    LOADCHUNK,
    loadChunk: LOADCHUNK,
    MADD,
    mAdd: MADD,
    MEXISTS,
    mExists: MEXISTS,
    RESERVE,
    reserve: RESERVE,
    SCANDUMP,
    scanDump: SCANDUMP
  };
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INCRBY.js
var require_INCRBY2 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    const args = ["CMS.INCRBY", key];
    if (Array.isArray(items)) {
      for (const item of items) {
        pushIncrByItem(args, item);
      }
    } else {
      pushIncrByItem(args, items);
    }
    return args;
  };
  var pushIncrByItem = function(args, { item, incrementBy }) {
    args.push(item, incrementBy.toString());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INFO.js
var require_INFO3 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["CMS.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      width: reply[1],
      depth: reply[3],
      count: reply[5]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INITBYDIM.js
var require_INITBYDIM = __commonJS((exports) => {
  var transformArguments = function(key, width, depth) {
    return ["CMS.INITBYDIM", key, width.toString(), depth.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INITBYPROB.js
var require_INITBYPROB = __commonJS((exports) => {
  var transformArguments = function(key, error23, probability) {
    return ["CMS.INITBYPROB", key, error23.toString(), probability.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/MERGE.js
var require_MERGE = __commonJS((exports) => {
  var transformArguments = function(dest, src) {
    const args = [
      "CMS.MERGE",
      dest,
      src.length.toString()
    ];
    if (isStringSketches(src)) {
      args.push(...src);
    } else {
      for (const sketch of src) {
        args.push(sketch.name);
      }
      args.push("WEIGHTS");
      for (const sketch of src) {
        args.push(sketch.weight.toString());
      }
    }
    return args;
  };
  var isStringSketches = function(src) {
    return typeof src[0] === "string";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/QUERY.js
var require_QUERY = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["CMS.QUERY", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/index.js
var require_count_min_sketch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY = require_INCRBY2();
  var INFO = require_INFO3();
  var INITBYDIM = require_INITBYDIM();
  var INITBYPROB = require_INITBYPROB();
  var MERGE = require_MERGE();
  var QUERY = require_QUERY();
  exports.default = {
    INCRBY,
    incrBy: INCRBY,
    INFO,
    info: INFO,
    INITBYDIM,
    initByDim: INITBYDIM,
    INITBYPROB,
    initByProb: INITBYPROB,
    MERGE,
    merge: MERGE,
    QUERY,
    query: QUERY
  };
});

// node_modules/@redis/bloom/dist/commands/cuckoo/ADD.js
var require_ADD2 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.ADD", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/ADDNX.js
var require_ADDNX = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.ADDNX", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/COUNT.js
var require_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.COUNT", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/DEL.js
var require_DEL2 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.DEL", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/EXISTS.js
var require_EXISTS3 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.EXISTS", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/INFO.js
var require_INFO4 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["CF.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      size: reply[1],
      numberOfBuckets: reply[3],
      numberOfFilters: reply[5],
      numberOfInsertedItems: reply[7],
      numberOfDeletedItems: reply[9],
      bucketSize: reply[11],
      expansionRate: reply[13],
      maxIteration: reply[15]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/INSERT.js
var require_INSERT2 = __commonJS((exports) => {
  var transformArguments = function(key, items, options) {
    return (0, _1.pushInsertOptions)(["CF.INSERT", key], items, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_cuckoo();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/INSERTNX.js
var require_INSERTNX = __commonJS((exports) => {
  var transformArguments = function(key, items, options) {
    return (0, _1.pushInsertOptions)(["CF.INSERTNX", key], items, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_cuckoo();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/LOADCHUNK.js
var require_LOADCHUNK2 = __commonJS((exports) => {
  var transformArguments = function(key, iterator3, chunk) {
    return ["CF.LOADCHUNK", key, iterator3.toString(), chunk];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/RESERVE.js
var require_RESERVE2 = __commonJS((exports) => {
  var transformArguments = function(key, capacity, options) {
    const args = ["CF.RESERVE", key, capacity.toString()];
    if (options?.BUCKETSIZE) {
      args.push("BUCKETSIZE", options.BUCKETSIZE.toString());
    }
    if (options?.MAXITERATIONS) {
      args.push("MAXITERATIONS", options.MAXITERATIONS.toString());
    }
    if (options?.EXPANSION) {
      args.push("EXPANSION", options.EXPANSION.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/SCANDUMP.js
var require_SCANDUMP2 = __commonJS((exports) => {
  var transformArguments = function(key, iterator3) {
    return ["CF.SCANDUMP", key, iterator3.toString()];
  };
  var transformReply = function([iterator3, chunk]) {
    return {
      iterator: iterator3,
      chunk
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/index.js
var require_cuckoo = __commonJS((exports) => {
  var pushInsertOptions = function(args, items, options) {
    if (options?.CAPACITY) {
      args.push("CAPACITY");
      args.push(options.CAPACITY.toString());
    }
    if (options?.NOCREATE) {
      args.push("NOCREATE");
    }
    args.push("ITEMS");
    return (0, generic_transformers_1.pushVerdictArguments)(args, items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushInsertOptions = undefined;
  var ADD = require_ADD2();
  var ADDNX = require_ADDNX();
  var COUNT = require_COUNT();
  var DEL = require_DEL2();
  var EXISTS = require_EXISTS3();
  var INFO = require_INFO4();
  var INSERT = require_INSERT2();
  var INSERTNX = require_INSERTNX();
  var LOADCHUNK = require_LOADCHUNK2();
  var RESERVE = require_RESERVE2();
  var SCANDUMP = require_SCANDUMP2();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    ADD,
    add: ADD,
    ADDNX,
    addNX: ADDNX,
    COUNT,
    count: COUNT,
    DEL,
    del: DEL,
    EXISTS,
    exists: EXISTS,
    INFO,
    info: INFO,
    INSERT,
    insert: INSERT,
    INSERTNX,
    insertNX: INSERTNX,
    LOADCHUNK,
    loadChunk: LOADCHUNK,
    RESERVE,
    reserve: RESERVE,
    SCANDUMP,
    scanDump: SCANDUMP
  };
  exports.pushInsertOptions = pushInsertOptions;
});

// node_modules/@redis/bloom/dist/commands/t-digest/ADD.js
var require_ADD3 = __commonJS((exports) => {
  var transformArguments = function(key, values) {
    const args = ["TDIGEST.ADD", key];
    for (const item of values) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/BYRANK.js
var require_BYRANK = __commonJS((exports) => {
  var transformArguments = function(key, ranks) {
    const args = ["TDIGEST.BYRANK", key];
    for (const rank of ranks) {
      args.push(rank.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/BYREVRANK.js
var require_BYREVRANK = __commonJS((exports) => {
  var transformArguments = function(key, ranks) {
    const args = ["TDIGEST.BYREVRANK", key];
    for (const rank of ranks) {
      args.push(rank.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/CDF.js
var require_CDF = __commonJS((exports) => {
  var transformArguments = function(key, values) {
    const args = ["TDIGEST.CDF", key];
    for (const item of values) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/CREATE.js
var require_CREATE = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, _1.pushCompressionArgument)(["TDIGEST.CREATE", key], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_t_digest();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/INFO.js
var require_INFO5 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "TDIGEST.INFO",
      key
    ];
  };
  var transformReply = function(reply) {
    return {
      comperssion: reply[1],
      capacity: reply[3],
      mergedNodes: reply[5],
      unmergedNodes: reply[7],
      mergedWeight: Number(reply[9]),
      unmergedWeight: Number(reply[11]),
      totalCompression: reply[13]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/t-digest/MAX.js
var require_MAX = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "TDIGEST.MAX",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoubleReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/MERGE.js
var require_MERGE2 = __commonJS((exports) => {
  var transformArguments = function(destKey, srcKeys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["TDIGEST.MERGE", destKey], srcKeys);
    (0, _1.pushCompressionArgument)(args, options);
    if (options?.OVERRIDE) {
      args.push("OVERRIDE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var _1 = require_t_digest();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/MIN.js
var require_MIN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "TDIGEST.MIN",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoubleReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/QUANTILE.js
var require_QUANTILE = __commonJS((exports) => {
  var transformArguments = function(key, quantiles) {
    const args = [
      "TDIGEST.QUANTILE",
      key
    ];
    for (const quantile of quantiles) {
      args.push(quantile.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/RANK.js
var require_RANK = __commonJS((exports) => {
  var transformArguments = function(key, values) {
    const args = ["TDIGEST.RANK", key];
    for (const item of values) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/RESET.js
var require_RESET = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TDIGEST.RESET", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/REVRANK.js
var require_REVRANK = __commonJS((exports) => {
  var transformArguments = function(key, values) {
    const args = ["TDIGEST.REVRANK", key];
    for (const item of values) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/TRIMMED_MEAN.js
var require_TRIMMED_MEAN = __commonJS((exports) => {
  var transformArguments = function(key, lowCutPercentile, highCutPercentile) {
    return [
      "TDIGEST.TRIMMED_MEAN",
      key,
      lowCutPercentile.toString(),
      highCutPercentile.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoubleReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/index.js
var require_t_digest = __commonJS((exports) => {
  var pushCompressionArgument = function(args, options) {
    if (options?.COMPRESSION) {
      args.push("COMPRESSION", options.COMPRESSION.toString());
    }
    return args;
  };
  var transformDoubleReply = function(reply) {
    switch (reply) {
      case "inf":
        return Infinity;
      case "-inf":
        return (-Infinity);
      case "nan":
        return NaN;
      default:
        return parseFloat(reply);
    }
  };
  var transformDoublesReply = function(reply) {
    return reply.map(transformDoubleReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformDoublesReply = exports.transformDoubleReply = exports.pushCompressionArgument = undefined;
  var ADD = require_ADD3();
  var BYRANK = require_BYRANK();
  var BYREVRANK = require_BYREVRANK();
  var CDF = require_CDF();
  var CREATE = require_CREATE();
  var INFO = require_INFO5();
  var MAX = require_MAX();
  var MERGE = require_MERGE2();
  var MIN = require_MIN();
  var QUANTILE = require_QUANTILE();
  var RANK = require_RANK();
  var RESET = require_RESET();
  var REVRANK = require_REVRANK();
  var TRIMMED_MEAN = require_TRIMMED_MEAN();
  exports.default = {
    ADD,
    add: ADD,
    BYRANK,
    byRank: BYRANK,
    BYREVRANK,
    byRevRank: BYREVRANK,
    CDF,
    cdf: CDF,
    CREATE,
    create: CREATE,
    INFO,
    info: INFO,
    MAX,
    max: MAX,
    MERGE,
    merge: MERGE,
    MIN,
    min: MIN,
    QUANTILE,
    quantile: QUANTILE,
    RANK,
    rank: RANK,
    RESET,
    reset: RESET,
    REVRANK,
    revRank: REVRANK,
    TRIMMED_MEAN,
    trimmedMean: TRIMMED_MEAN
  };
  exports.pushCompressionArgument = pushCompressionArgument;
  exports.transformDoubleReply = transformDoubleReply;
  exports.transformDoublesReply = transformDoublesReply;
});

// node_modules/@redis/bloom/dist/commands/top-k/ADD.js
var require_ADD4 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOPK.ADD", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/COUNT.js
var require_COUNT2 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOPK.COUNT", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/INCRBY.js
var require_INCRBY3 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    const args = ["TOPK.INCRBY", key];
    if (Array.isArray(items)) {
      for (const item of items) {
        pushIncrByItem(args, item);
      }
    } else {
      pushIncrByItem(args, items);
    }
    return args;
  };
  var pushIncrByItem = function(args, { item, incrementBy }) {
    args.push(item, incrementBy.toString());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/INFO.js
var require_INFO6 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TOPK.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      k: reply[1],
      width: reply[3],
      depth: reply[5],
      decay: Number(reply[7])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/top-k/LIST_WITHCOUNT.js
var require_LIST_WITHCOUNT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TOPK.LIST", key, "WITHCOUNT"];
  };
  var transformReply = function(rawReply) {
    const reply = [];
    for (let i = 0;i < rawReply.length; i++) {
      reply.push({
        item: rawReply[i],
        count: rawReply[++i]
      });
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/top-k/LIST.js
var require_LIST = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TOPK.LIST", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/QUERY.js
var require_QUERY2 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOPK.QUERY", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/RESERVE.js
var require_RESERVE3 = __commonJS((exports) => {
  var transformArguments = function(key, topK, options) {
    const args = ["TOPK.RESERVE", key, topK.toString()];
    if (options) {
      args.push(options.width.toString(), options.depth.toString(), options.decay.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/index.js
var require_top_k = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD = require_ADD4();
  var COUNT = require_COUNT2();
  var INCRBY = require_INCRBY3();
  var INFO = require_INFO6();
  var LIST_WITHCOUNT = require_LIST_WITHCOUNT();
  var LIST = require_LIST();
  var QUERY = require_QUERY2();
  var RESERVE = require_RESERVE3();
  exports.default = {
    ADD,
    add: ADD,
    COUNT,
    count: COUNT,
    INCRBY,
    incrBy: INCRBY,
    INFO,
    info: INFO,
    LIST_WITHCOUNT,
    listWithCount: LIST_WITHCOUNT,
    LIST,
    list: LIST,
    QUERY,
    query: QUERY,
    RESERVE,
    reserve: RESERVE
  };
});

// node_modules/@redis/bloom/dist/commands/index.js
var require_commands3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  var count_min_sketch_1 = require_count_min_sketch();
  var cuckoo_1 = require_cuckoo();
  var t_digest_1 = require_t_digest();
  var top_k_1 = require_top_k();
  exports.default = {
    bf: bloom_1.default,
    cms: count_min_sketch_1.default,
    cf: cuckoo_1.default,
    tDigest: t_digest_1.default,
    topK: top_k_1.default
  };
});

// node_modules/@redis/bloom/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands3();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
});

// node_modules/@redis/graph/dist/commands/CONFIG_GET.js
var require_CONFIG_GET2 = __commonJS((exports) => {
  var transformArguments = function(configKey) {
    return ["GRAPH.CONFIG", "GET", configKey];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/CONFIG_SET.js
var require_CONFIG_SET2 = __commonJS((exports) => {
  var transformArguments = function(configKey, value26) {
    return [
      "GRAPH.CONFIG",
      "SET",
      configKey,
      value26.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/DELETE.js
var require_DELETE = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GRAPH.DELETE", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/EXPLAIN.js
var require_EXPLAIN = __commonJS((exports) => {
  var transformArguments = function(key, query) {
    return ["GRAPH.EXPLAIN", key, query];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/LIST.js
var require_LIST2 = __commonJS((exports) => {
  var transformArguments = function() {
    return ["GRAPH.LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/PROFILE.js
var require_PROFILE = __commonJS((exports) => {
  var transformArguments = function(key, query) {
    return ["GRAPH.PROFILE", key, query];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/QUERY.js
var require_QUERY3 = __commonJS((exports) => {
  var transformArguments = function(graph, query, options, compact) {
    return (0, _1.pushQueryArguments)(["GRAPH.QUERY"], graph, query, options, compact);
  };
  var transformReply = function(reply) {
    return reply.length === 1 ? {
      headers: undefined,
      data: undefined,
      metadata: reply[0]
    } : {
      headers: reply[0],
      data: reply[1],
      metadata: reply[2]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands4();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/graph/dist/commands/RO_QUERY.js
var require_RO_QUERY = __commonJS((exports) => {
  var transformArguments = function(graph, query, options, compact) {
    return (0, _1.pushQueryArguments)(["GRAPH.RO_QUERY"], graph, query, options, compact);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands4();
  var QUERY_1 = require_QUERY3();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return QUERY_1.FIRST_KEY_INDEX;
  } });
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var QUERY_2 = require_QUERY3();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return QUERY_2.transformReply;
  } });
});

// node_modules/@redis/graph/dist/commands/SLOWLOG.js
var require_SLOWLOG = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GRAPH.SLOWLOG", key];
  };
  var transformReply = function(logs) {
    return logs.map(([timestamp, command, query, took]) => ({
      timestamp: new Date(Number(timestamp) * 1000),
      command,
      query,
      took: Number(took)
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/graph/dist/commands/index.js
var require_commands4 = __commonJS((exports) => {
  var pushQueryArguments = function(args, graph, query, options, compact) {
    args.push(graph);
    if (typeof options === "number") {
      args.push(query);
      pushTimeout(args, options);
    } else {
      args.push(options?.params ? `CYPHER ${queryParamsToString(options.params)} ${query}` : query);
      if (options?.TIMEOUT !== undefined) {
        pushTimeout(args, options.TIMEOUT);
      }
    }
    if (compact) {
      args.push("--compact");
    }
    return args;
  };
  var pushTimeout = function(args, timeout) {
    args.push("TIMEOUT", timeout.toString());
  };
  var queryParamsToString = function(params) {
    const parts = [];
    for (const [key, value26] of Object.entries(params)) {
      parts.push(`${key}=${queryParamToString(value26)}`);
    }
    return parts.join(" ");
  };
  var queryParamToString = function(param) {
    if (param === null) {
      return "null";
    }
    switch (typeof param) {
      case "string":
        return `"${param.replace(/["\\]/g, "\\$&")}"`;
      case "number":
      case "boolean":
        return param.toString();
    }
    if (Array.isArray(param)) {
      return `[${param.map(queryParamToString).join(",")}]`;
    } else if (typeof param === "object") {
      const body = [];
      for (const [key, value26] of Object.entries(param)) {
        body.push(`${key}:${queryParamToString(value26)}`);
      }
      return `{${body.join(",")}}`;
    } else {
      throw new TypeError(`Unexpected param type ${typeof param} ${param}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushQueryArguments = undefined;
  var CONFIG_GET = require_CONFIG_GET2();
  var CONFIG_SET = require_CONFIG_SET2();
  var DELETE = require_DELETE();
  var EXPLAIN = require_EXPLAIN();
  var LIST = require_LIST2();
  var PROFILE = require_PROFILE();
  var QUERY = require_QUERY3();
  var RO_QUERY = require_RO_QUERY();
  var SLOWLOG = require_SLOWLOG();
  exports.default = {
    CONFIG_GET,
    configGet: CONFIG_GET,
    CONFIG_SET,
    configSet: CONFIG_SET,
    DELETE,
    delete: DELETE,
    EXPLAIN,
    explain: EXPLAIN,
    LIST,
    list: LIST,
    PROFILE,
    profile: PROFILE,
    QUERY,
    query: QUERY,
    RO_QUERY,
    roQuery: RO_QUERY,
    SLOWLOG,
    slowLog: SLOWLOG
  };
  exports.pushQueryArguments = pushQueryArguments;
});

// node_modules/@redis/graph/dist/graph.js
var require_graph = __commonJS((exports) => {
  var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value26, kind31, f) {
    if (kind31 === "m")
      throw new TypeError("Private method is not writable");
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind31 === "a" ? f.call(receiver, value26) : f ? f.value = value26 : state.set(receiver, value26), value26;
  };
  var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind31, f) {
    if (kind31 === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind31 === "m" ? f : kind31 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Graph_instances;
  var _Graph_client;
  var _Graph_name;
  var _Graph_metadata;
  var _Graph_setMetadataPromise;
  var _Graph_updateMetadata;
  var _Graph_setMetadata;
  var _Graph_cleanMetadataArray;
  var _Graph_getMetadata;
  var _Graph_getMetadataAsync;
  var _Graph_parseReply;
  var _Graph_parseValue;
  var _Graph_parseEdge;
  var _Graph_parseNode;
  var _Graph_parseProperties;
  Object.defineProperty(exports, "__esModule", { value: true });
  var GraphValueTypes;
  (function(GraphValueTypes2) {
    GraphValueTypes2[GraphValueTypes2["UNKNOWN"] = 0] = "UNKNOWN";
    GraphValueTypes2[GraphValueTypes2["NULL"] = 1] = "NULL";
    GraphValueTypes2[GraphValueTypes2["STRING"] = 2] = "STRING";
    GraphValueTypes2[GraphValueTypes2["INTEGER"] = 3] = "INTEGER";
    GraphValueTypes2[GraphValueTypes2["BOOLEAN"] = 4] = "BOOLEAN";
    GraphValueTypes2[GraphValueTypes2["DOUBLE"] = 5] = "DOUBLE";
    GraphValueTypes2[GraphValueTypes2["ARRAY"] = 6] = "ARRAY";
    GraphValueTypes2[GraphValueTypes2["EDGE"] = 7] = "EDGE";
    GraphValueTypes2[GraphValueTypes2["NODE"] = 8] = "NODE";
    GraphValueTypes2[GraphValueTypes2["PATH"] = 9] = "PATH";
    GraphValueTypes2[GraphValueTypes2["MAP"] = 10] = "MAP";
    GraphValueTypes2[GraphValueTypes2["POINT"] = 11] = "POINT";
  })(GraphValueTypes || (GraphValueTypes = {}));

  class Graph {
    constructor(client, name) {
      _Graph_instances.add(this);
      _Graph_client.set(this, undefined);
      _Graph_name.set(this, undefined);
      _Graph_metadata.set(this, undefined);
      _Graph_setMetadataPromise.set(this, undefined);
      __classPrivateFieldSet2(this, _Graph_client, client, "f");
      __classPrivateFieldSet2(this, _Graph_name, name, "f");
    }
    async query(query, options) {
      return __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseReply).call(this, await __classPrivateFieldGet2(this, _Graph_client, "f").graph.query(__classPrivateFieldGet2(this, _Graph_name, "f"), query, options, true));
    }
    async roQuery(query, options) {
      return __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseReply).call(this, await __classPrivateFieldGet2(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet2(this, _Graph_name, "f"), query, options, true));
    }
  }
  _Graph_client = new WeakMap, _Graph_name = new WeakMap, _Graph_metadata = new WeakMap, _Graph_setMetadataPromise = new WeakMap, _Graph_instances = new WeakSet, _Graph_updateMetadata = function _Graph_updateMetadata() {
    __classPrivateFieldSet2(this, _Graph_setMetadataPromise, __classPrivateFieldGet2(this, _Graph_setMetadataPromise, "f") ?? __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_setMetadata).call(this).finally(() => __classPrivateFieldSet2(this, _Graph_setMetadataPromise, undefined, "f")), "f");
    return __classPrivateFieldGet2(this, _Graph_setMetadataPromise, "f");
  }, _Graph_setMetadata = async function _Graph_setMetadata() {
    const [labels, relationshipTypes, propertyKeys] = await Promise.all([
      __classPrivateFieldGet2(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet2(this, _Graph_name, "f"), "CALL db.labels()"),
      __classPrivateFieldGet2(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet2(this, _Graph_name, "f"), "CALL db.relationshipTypes()"),
      __classPrivateFieldGet2(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet2(this, _Graph_name, "f"), "CALL db.propertyKeys()")
    ]);
    __classPrivateFieldSet2(this, _Graph_metadata, {
      labels: __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_cleanMetadataArray).call(this, labels.data),
      relationshipTypes: __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_cleanMetadataArray).call(this, relationshipTypes.data),
      propertyKeys: __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_cleanMetadataArray).call(this, propertyKeys.data)
    }, "f");
    return __classPrivateFieldGet2(this, _Graph_metadata, "f");
  }, _Graph_cleanMetadataArray = function _Graph_cleanMetadataArray(arr) {
    return arr.map(([value26]) => value26);
  }, _Graph_getMetadata = function _Graph_getMetadata(key, id) {
    return __classPrivateFieldGet2(this, _Graph_metadata, "f")?.[key][id] ?? __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_getMetadataAsync).call(this, key, id);
  }, _Graph_getMetadataAsync = async function _Graph_getMetadataAsync(key, id) {
    const value26 = (await __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_updateMetadata).call(this))[key][id];
    if (value26 === undefined)
      throw new Error(`Cannot find value from ${key}[${id}]`);
    return value26;
  }, _Graph_parseReply = async function _Graph_parseReply(reply) {
    if (!reply.data)
      return reply;
    const promises5 = [], parsed = {
      metadata: reply.metadata,
      data: reply.data.map((row) => {
        const data = {};
        for (let i = 0;i < row.length; i++) {
          data[reply.headers[i][1]] = __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseValue).call(this, row[i], promises5);
        }
        return data;
      })
    };
    if (promises5.length)
      await Promise.all(promises5);
    return parsed;
  }, _Graph_parseValue = function _Graph_parseValue([valueType, value26], promises5) {
    switch (valueType) {
      case GraphValueTypes.NULL:
        return null;
      case GraphValueTypes.STRING:
      case GraphValueTypes.INTEGER:
        return value26;
      case GraphValueTypes.BOOLEAN:
        return value26 === "true";
      case GraphValueTypes.DOUBLE:
        return parseFloat(value26);
      case GraphValueTypes.ARRAY:
        return value26.map((x) => __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseValue).call(this, x, promises5));
      case GraphValueTypes.EDGE:
        return __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseEdge).call(this, value26, promises5);
      case GraphValueTypes.NODE:
        return __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseNode).call(this, value26, promises5);
      case GraphValueTypes.PATH:
        return {
          nodes: value26[0][1].map(([, node]) => __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseNode).call(this, node, promises5)),
          edges: value26[1][1].map(([, edge]) => __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseEdge).call(this, edge, promises5))
        };
      case GraphValueTypes.MAP:
        const map3 = {};
        for (let i = 0;i < value26.length; i++) {
          map3[value26[i++]] = __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseValue).call(this, value26[i], promises5);
        }
        return map3;
      case GraphValueTypes.POINT:
        return {
          latitude: parseFloat(value26[0]),
          longitude: parseFloat(value26[1])
        };
      default:
        throw new Error(`unknown scalar type: ${valueType}`);
    }
  }, _Graph_parseEdge = function _Graph_parseEdge([id, relationshipTypeId, sourceId, destinationId, properties], promises5) {
    const edge = {
      id,
      sourceId,
      destinationId,
      properties: __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseProperties).call(this, properties, promises5)
    };
    const relationshipType = __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_getMetadata).call(this, "relationshipTypes", relationshipTypeId);
    if (relationshipType instanceof Promise) {
      promises5.push(relationshipType.then((value26) => edge.relationshipType = value26));
    } else {
      edge.relationshipType = relationshipType;
    }
    return edge;
  }, _Graph_parseNode = function _Graph_parseNode([id, labelIds, properties], promises5) {
    const labels = new Array(labelIds.length);
    for (let i = 0;i < labelIds.length; i++) {
      const value26 = __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_getMetadata).call(this, "labels", labelIds[i]);
      if (value26 instanceof Promise) {
        promises5.push(value26.then((value27) => labels[i] = value27));
      } else {
        labels[i] = value26;
      }
    }
    return {
      id,
      labels,
      properties: __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseProperties).call(this, properties, promises5)
    };
  }, _Graph_parseProperties = function _Graph_parseProperties(raw, promises5) {
    const parsed = {};
    for (const [id, type54, value26] of raw) {
      const parsedValue = __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_parseValue).call(this, [type54, value26], promises5), key = __classPrivateFieldGet2(this, _Graph_instances, "m", _Graph_getMetadata).call(this, "propertyKeys", id);
      if (key instanceof Promise) {
        promises5.push(key.then((key2) => parsed[key2] = parsedValue));
      } else {
        parsed[key] = parsedValue;
      }
    }
    return parsed;
  };
  exports.default = Graph;
});

// node_modules/@redis/graph/dist/index.js
var require_dist5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Graph = exports.default = undefined;
  var commands_1 = require_commands4();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
  var graph_1 = require_graph();
  Object.defineProperty(exports, "Graph", { enumerable: true, get: function() {
    return graph_1.default;
  } });
});

// node_modules/@redis/json/dist/commands/ARRAPPEND.js
var require_ARRAPPEND = __commonJS((exports) => {
  var transformArguments = function(key, path, ...jsons) {
    const args = ["JSON.ARRAPPEND", key, path];
    for (const json of jsons) {
      args.push((0, _1.transformRedisJsonArgument)(json));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRINDEX.js
var require_ARRINDEX = __commonJS((exports) => {
  var transformArguments = function(key, path, json, start, stop) {
    const args = ["JSON.ARRINDEX", key, path, (0, _1.transformRedisJsonArgument)(json)];
    if (start !== undefined && start !== null) {
      args.push(start.toString());
      if (stop !== undefined && stop !== null) {
        args.push(stop.toString());
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRINSERT.js
var require_ARRINSERT = __commonJS((exports) => {
  var transformArguments = function(key, path, index, ...jsons) {
    const args = ["JSON.ARRINSERT", key, path, index.toString()];
    for (const json of jsons) {
      args.push((0, _1.transformRedisJsonArgument)(json));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRLEN.js
var require_ARRLEN = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.ARRLEN", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRPOP.js
var require_ARRPOP = __commonJS((exports) => {
  var transformArguments = function(key, path, index) {
    const args = ["JSON.ARRPOP", key];
    if (path) {
      args.push(path);
      if (index !== undefined && index !== null) {
        args.push(index.toString());
      }
    }
    return args;
  };
  var transformReply = function(reply) {
    if (reply === null)
      return null;
    if (Array.isArray(reply)) {
      return reply.map(_1.transformRedisJsonNullReply);
    }
    return (0, _1.transformRedisJsonNullReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/json/dist/commands/ARRTRIM.js
var require_ARRTRIM = __commonJS((exports) => {
  var transformArguments = function(key, path, start, stop) {
    return ["JSON.ARRTRIM", key, path, start.toString(), stop.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/DEBUG_MEMORY.js
var require_DEBUG_MEMORY = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.DEBUG", "MEMORY", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/DEL.js
var require_DEL3 = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.DEL", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/FORGET.js
var require_FORGET = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.FORGET", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/GET.js
var require_GET2 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    let args = ["JSON.GET", key];
    if (options?.path) {
      args = (0, generic_transformers_1.pushVerdictArguments)(args, options.path);
    }
    if (options?.INDENT) {
      args.push("INDENT", options.INDENT);
    }
    if (options?.NEWLINE) {
      args.push("NEWLINE", options.NEWLINE);
    }
    if (options?.SPACE) {
      args.push("SPACE", options.SPACE);
    }
    if (options?.NOESCAPE) {
      args.push("NOESCAPE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_commands5();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformRedisJsonNullReply;
  } });
});

// node_modules/@redis/json/dist/commands/MERGE.js
var require_MERGE3 = __commonJS((exports) => {
  var transformArguments = function(key, path, json) {
    return ["JSON.MERGE", key, path, (0, _1.transformRedisJsonArgument)(json)];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/MGET.js
var require_MGET2 = __commonJS((exports) => {
  var transformArguments = function(keys, path) {
    return [
      "JSON.MGET",
      ...keys,
      path
    ];
  };
  var transformReply = function(reply) {
    return reply.map(_1.transformRedisJsonNullReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/json/dist/commands/MSET.js
var require_MSET2 = __commonJS((exports) => {
  var transformArguments = function(items) {
    const args = new Array(1 + items.length * 3);
    args[0] = "JSON.MSET";
    let argsIndex = 1;
    for (let i = 0;i < items.length; i++) {
      const item = items[i];
      args[argsIndex++] = item.key;
      args[argsIndex++] = item.path;
      args[argsIndex++] = (0, _1.transformRedisJsonArgument)(item.value);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/NUMINCRBY.js
var require_NUMINCRBY = __commonJS((exports) => {
  var transformArguments = function(key, path, by) {
    return ["JSON.NUMINCRBY", key, path, by.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var _1 = require_commands5();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformNumbersReply;
  } });
});

// node_modules/@redis/json/dist/commands/NUMMULTBY.js
var require_NUMMULTBY = __commonJS((exports) => {
  var transformArguments = function(key, path, by) {
    return ["JSON.NUMMULTBY", key, path, by.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var _1 = require_commands5();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformNumbersReply;
  } });
});

// node_modules/@redis/json/dist/commands/OBJKEYS.js
var require_OBJKEYS = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.OBJKEYS", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/OBJLEN.js
var require_OBJLEN = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.OBJLEN", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/RESP.js
var require_RESP = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.RESP", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/SET.js
var require_SET2 = __commonJS((exports) => {
  var transformArguments = function(key, path, json, options) {
    const args = ["JSON.SET", key, path, (0, _1.transformRedisJsonArgument)(json)];
    if (options?.NX) {
      args.push("NX");
    } else if (options?.XX) {
      args.push("XX");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/STRAPPEND.js
var require_STRAPPEND = __commonJS((exports) => {
  var transformArguments = function(...[key, pathOrAppend, append]) {
    const args = ["JSON.STRAPPEND", key];
    if (append !== undefined && append !== null) {
      args.push(pathOrAppend, (0, _1.transformRedisJsonArgument)(append));
    } else {
      args.push((0, _1.transformRedisJsonArgument)(pathOrAppend));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/STRLEN.js
var require_STRLEN2 = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.STRLEN", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/TYPE.js
var require_TYPE2 = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.TYPE", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/index.js
var require_commands5 = __commonJS((exports) => {
  var transformRedisJsonArgument = function(json) {
    return JSON.stringify(json);
  };
  var transformRedisJsonReply = function(json) {
    return JSON.parse(json);
  };
  var transformRedisJsonNullReply = function(json) {
    if (json === null)
      return null;
    return transformRedisJsonReply(json);
  };
  var transformNumbersReply = function(reply) {
    return JSON.parse(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformNumbersReply = exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = undefined;
  var ARRAPPEND = require_ARRAPPEND();
  var ARRINDEX = require_ARRINDEX();
  var ARRINSERT = require_ARRINSERT();
  var ARRLEN = require_ARRLEN();
  var ARRPOP = require_ARRPOP();
  var ARRTRIM = require_ARRTRIM();
  var DEBUG_MEMORY = require_DEBUG_MEMORY();
  var DEL = require_DEL3();
  var FORGET = require_FORGET();
  var GET = require_GET2();
  var MERGE = require_MERGE3();
  var MGET = require_MGET2();
  var MSET = require_MSET2();
  var NUMINCRBY = require_NUMINCRBY();
  var NUMMULTBY = require_NUMMULTBY();
  var OBJKEYS = require_OBJKEYS();
  var OBJLEN = require_OBJLEN();
  var RESP = require_RESP();
  var SET = require_SET2();
  var STRAPPEND = require_STRAPPEND();
  var STRLEN = require_STRLEN2();
  var TYPE = require_TYPE2();
  exports.default = {
    ARRAPPEND,
    arrAppend: ARRAPPEND,
    ARRINDEX,
    arrIndex: ARRINDEX,
    ARRINSERT,
    arrInsert: ARRINSERT,
    ARRLEN,
    arrLen: ARRLEN,
    ARRPOP,
    arrPop: ARRPOP,
    ARRTRIM,
    arrTrim: ARRTRIM,
    DEBUG_MEMORY,
    debugMemory: DEBUG_MEMORY,
    DEL,
    del: DEL,
    FORGET,
    forget: FORGET,
    GET,
    get: GET,
    MERGE,
    merge: MERGE,
    MGET,
    mGet: MGET,
    MSET,
    mSet: MSET,
    NUMINCRBY,
    numIncrBy: NUMINCRBY,
    NUMMULTBY,
    numMultBy: NUMMULTBY,
    OBJKEYS,
    objKeys: OBJKEYS,
    OBJLEN,
    objLen: OBJLEN,
    RESP,
    resp: RESP,
    SET,
    set: SET,
    STRAPPEND,
    strAppend: STRAPPEND,
    STRLEN,
    strLen: STRLEN,
    TYPE,
    type: TYPE
  };
  exports.transformRedisJsonArgument = transformRedisJsonArgument;
  exports.transformRedisJsonReply = transformRedisJsonReply;
  exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
  exports.transformNumbersReply = transformNumbersReply;
});

// node_modules/@redis/json/dist/index.js
var require_dist6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands5();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
});

// node_modules/@redis/search/dist/commands/_LIST.js
var require__LIST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FT._LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/ALTER.js
var require_ALTER = __commonJS((exports) => {
  var transformArguments = function(index, schema) {
    const args = ["FT.ALTER", index, "SCHEMA", "ADD"];
    (0, _1.pushSchema)(args, schema);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var _1 = require_commands6();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/AGGREGATE.js
var require_AGGREGATE = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    return pushAggregatehOptions(["FT.AGGREGATE", index, query], options);
  };
  var pushAggregatehOptions = function(args, options) {
    if (options?.VERBATIM) {
      args.push("VERBATIM");
    }
    if (options?.ADDSCORES) {
      args.push("ADDSCORES");
    }
    if (options?.LOAD) {
      args.push("LOAD");
      (0, _1.pushArgumentsWithLength)(args, () => {
        if (Array.isArray(options.LOAD)) {
          for (const load of options.LOAD) {
            pushLoadField(args, load);
          }
        } else {
          pushLoadField(args, options.LOAD);
        }
      });
    }
    if (options?.STEPS) {
      for (const step of options.STEPS) {
        switch (step.type) {
          case AggregateSteps.GROUPBY:
            args.push("GROUPBY");
            if (!step.properties) {
              args.push("0");
            } else {
              (0, generic_transformers_1.pushVerdictArgument)(args, step.properties);
            }
            if (Array.isArray(step.REDUCE)) {
              for (const reducer of step.REDUCE) {
                pushGroupByReducer(args, reducer);
              }
            } else {
              pushGroupByReducer(args, step.REDUCE);
            }
            break;
          case AggregateSteps.SORTBY:
            (0, _1.pushSortByArguments)(args, "SORTBY", step.BY);
            if (step.MAX) {
              args.push("MAX", step.MAX.toString());
            }
            break;
          case AggregateSteps.APPLY:
            args.push("APPLY", step.expression, "AS", step.AS);
            break;
          case AggregateSteps.LIMIT:
            args.push("LIMIT", step.from.toString(), step.size.toString());
            break;
          case AggregateSteps.FILTER:
            args.push("FILTER", step.expression);
            break;
        }
      }
    }
    (0, _1.pushParamsArgs)(args, options?.PARAMS);
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    if (options?.TIMEOUT !== undefined) {
      args.push("TIMEOUT", options.TIMEOUT.toString());
    }
    return args;
  };
  var pushLoadField = function(args, toLoad) {
    if (typeof toLoad === "string") {
      args.push(toLoad);
    } else {
      args.push(toLoad.identifier);
      if (toLoad.AS) {
        args.push("AS", toLoad.AS);
      }
    }
  };
  var pushGroupByReducer = function(args, reducer) {
    args.push("REDUCE", reducer.type);
    switch (reducer.type) {
      case AggregateGroupByReducers.COUNT:
        args.push("0");
        break;
      case AggregateGroupByReducers.COUNT_DISTINCT:
      case AggregateGroupByReducers.COUNT_DISTINCTISH:
      case AggregateGroupByReducers.SUM:
      case AggregateGroupByReducers.MIN:
      case AggregateGroupByReducers.MAX:
      case AggregateGroupByReducers.AVG:
      case AggregateGroupByReducers.STDDEV:
      case AggregateGroupByReducers.TOLIST:
        args.push("1", reducer.property);
        break;
      case AggregateGroupByReducers.QUANTILE:
        args.push("2", reducer.property, reducer.quantile.toString());
        break;
      case AggregateGroupByReducers.FIRST_VALUE: {
        (0, _1.pushArgumentsWithLength)(args, () => {
          args.push(reducer.property);
          if (reducer.BY) {
            args.push("BY");
            if (typeof reducer.BY === "string") {
              args.push(reducer.BY);
            } else {
              args.push(reducer.BY.property);
              if (reducer.BY.direction) {
                args.push(reducer.BY.direction);
              }
            }
          }
        });
        break;
      }
      case AggregateGroupByReducers.RANDOM_SAMPLE:
        args.push("2", reducer.property, reducer.sampleSize.toString());
        break;
    }
    if (reducer.AS) {
      args.push("AS", reducer.AS);
    }
  };
  var transformReply = function(rawReply) {
    const results = [];
    for (let i = 1;i < rawReply.length; i++) {
      results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i]));
    }
    return {
      total: rawReply[0],
      results
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.pushAggregatehOptions = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = exports.AggregateGroupByReducers = exports.AggregateSteps = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var _1 = require_commands6();
  var AggregateSteps;
  (function(AggregateSteps2) {
    AggregateSteps2["GROUPBY"] = "GROUPBY";
    AggregateSteps2["SORTBY"] = "SORTBY";
    AggregateSteps2["APPLY"] = "APPLY";
    AggregateSteps2["LIMIT"] = "LIMIT";
    AggregateSteps2["FILTER"] = "FILTER";
  })(AggregateSteps || (exports.AggregateSteps = AggregateSteps = {}));
  var AggregateGroupByReducers;
  (function(AggregateGroupByReducers2) {
    AggregateGroupByReducers2["COUNT"] = "COUNT";
    AggregateGroupByReducers2["COUNT_DISTINCT"] = "COUNT_DISTINCT";
    AggregateGroupByReducers2["COUNT_DISTINCTISH"] = "COUNT_DISTINCTISH";
    AggregateGroupByReducers2["SUM"] = "SUM";
    AggregateGroupByReducers2["MIN"] = "MIN";
    AggregateGroupByReducers2["MAX"] = "MAX";
    AggregateGroupByReducers2["AVG"] = "AVG";
    AggregateGroupByReducers2["STDDEV"] = "STDDEV";
    AggregateGroupByReducers2["QUANTILE"] = "QUANTILE";
    AggregateGroupByReducers2["TOLIST"] = "TOLIST";
    AggregateGroupByReducers2["TO_LIST"] = "TOLIST";
    AggregateGroupByReducers2["FIRST_VALUE"] = "FIRST_VALUE";
    AggregateGroupByReducers2["RANDOM_SAMPLE"] = "RANDOM_SAMPLE";
  })(AggregateGroupByReducers || (exports.AggregateGroupByReducers = AggregateGroupByReducers = {}));
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.pushAggregatehOptions = pushAggregatehOptions;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/AGGREGATE_WITHCURSOR.js
var require_AGGREGATE_WITHCURSOR = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    const args = (0, AGGREGATE_1.transformArguments)(index, query, options);
    args.push("WITHCURSOR");
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformReply = function(reply) {
    return {
      ...(0, AGGREGATE_1.transformReply)(reply[0]),
      cursor: reply[1]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var AGGREGATE_1 = require_AGGREGATE();
  var AGGREGATE_2 = require_AGGREGATE();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return AGGREGATE_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return AGGREGATE_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/ALIASADD.js
var require_ALIASADD = __commonJS((exports) => {
  var transformArguments = function(name, index) {
    return ["FT.ALIASADD", name, index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/ALIASDEL.js
var require_ALIASDEL = __commonJS((exports) => {
  var transformArguments = function(name, index) {
    return ["FT.ALIASDEL", name, index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/ALIASUPDATE.js
var require_ALIASUPDATE = __commonJS((exports) => {
  var transformArguments = function(name, index) {
    return ["FT.ALIASUPDATE", name, index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CONFIG_GET.js
var require_CONFIG_GET3 = __commonJS((exports) => {
  var transformArguments = function(option) {
    return ["FT.CONFIG", "GET", option];
  };
  var transformReply = function(rawReply) {
    const transformedReply = Object.create(null);
    for (const [key, value26] of rawReply) {
      transformedReply[key] = value26;
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/CONFIG_SET.js
var require_CONFIG_SET3 = __commonJS((exports) => {
  var transformArguments = function(option, value26) {
    return ["FT.CONFIG", "SET", option, value26];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CREATE.js
var require_CREATE2 = __commonJS((exports) => {
  var transformArguments = function(index, schema, options) {
    const args = ["FT.CREATE", index];
    if (options?.ON) {
      args.push("ON", options.ON);
    }
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "PREFIX", options?.PREFIX);
    if (options?.FILTER) {
      args.push("FILTER", options.FILTER);
    }
    if (options?.LANGUAGE) {
      args.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.LANGUAGE_FIELD) {
      args.push("LANGUAGE_FIELD", options.LANGUAGE_FIELD);
    }
    if (options?.SCORE) {
      args.push("SCORE", options.SCORE.toString());
    }
    if (options?.SCORE_FIELD) {
      args.push("SCORE_FIELD", options.SCORE_FIELD);
    }
    if (options?.MAXTEXTFIELDS) {
      args.push("MAXTEXTFIELDS");
    }
    if (options?.TEMPORARY) {
      args.push("TEMPORARY", options.TEMPORARY.toString());
    }
    if (options?.NOOFFSETS) {
      args.push("NOOFFSETS");
    }
    if (options?.NOHL) {
      args.push("NOHL");
    }
    if (options?.NOFIELDS) {
      args.push("NOFIELDS");
    }
    if (options?.NOFREQS) {
      args.push("NOFREQS");
    }
    if (options?.SKIPINITIALSCAN) {
      args.push("SKIPINITIALSCAN");
    }
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "STOPWORDS", options?.STOPWORDS);
    args.push("SCHEMA");
    (0, _1.pushSchema)(args, schema);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var _1 = require_commands6();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CURSOR_DEL.js
var require_CURSOR_DEL = __commonJS((exports) => {
  var transformArguments = function(index, cursorId) {
    return [
      "FT.CURSOR",
      "DEL",
      index,
      cursorId.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CURSOR_READ.js
var require_CURSOR_READ = __commonJS((exports) => {
  var transformArguments = function(index, cursor, options) {
    const args = [
      "FT.CURSOR",
      "READ",
      index,
      cursor.toString()
    ];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var AGGREGATE_WITHCURSOR_1 = require_AGGREGATE_WITHCURSOR();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return AGGREGATE_WITHCURSOR_1.transformReply;
  } });
});

// node_modules/@redis/search/dist/commands/DICTADD.js
var require_DICTADD = __commonJS((exports) => {
  var transformArguments = function(dictionary, term) {
    return (0, generic_transformers_1.pushVerdictArguments)(["FT.DICTADD", dictionary], term);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/DICTDEL.js
var require_DICTDEL = __commonJS((exports) => {
  var transformArguments = function(dictionary, term) {
    return (0, generic_transformers_1.pushVerdictArguments)(["FT.DICTDEL", dictionary], term);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/DICTDUMP.js
var require_DICTDUMP = __commonJS((exports) => {
  var transformArguments = function(dictionary) {
    return ["FT.DICTDUMP", dictionary];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/DROPINDEX.js
var require_DROPINDEX = __commonJS((exports) => {
  var transformArguments = function(index, options) {
    const args = ["FT.DROPINDEX", index];
    if (options?.DD) {
      args.push("DD");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/EXPLAIN.js
var require_EXPLAIN2 = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    const args = ["FT.EXPLAIN", index, query];
    (0, _1.pushParamsArgs)(args, options?.PARAMS);
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands6();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/EXPLAINCLI.js
var require_EXPLAINCLI = __commonJS((exports) => {
  var transformArguments = function(index, query) {
    return ["FT.EXPLAINCLI", index, query];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/INFO.js
var require_INFO7 = __commonJS((exports) => {
  var transformArguments = function(index) {
    return ["FT.INFO", index];
  };
  var transformReply = function(rawReply) {
    return {
      indexName: rawReply[1],
      indexOptions: rawReply[3],
      indexDefinition: (0, generic_transformers_1.transformTuplesReply)(rawReply[5]),
      attributes: rawReply[7].map((attribute) => (0, generic_transformers_1.transformTuplesReply)(attribute)),
      numDocs: rawReply[9],
      maxDocId: rawReply[11],
      numTerms: rawReply[13],
      numRecords: rawReply[15],
      invertedSzMb: rawReply[17],
      vectorIndexSzMb: rawReply[19],
      totalInvertedIndexBlocks: rawReply[21],
      offsetVectorsSzMb: rawReply[23],
      docTableSizeMb: rawReply[25],
      sortableValuesSizeMb: rawReply[27],
      keyTableSizeMb: rawReply[29],
      recordsPerDocAvg: rawReply[31],
      bytesPerRecordAvg: rawReply[33],
      offsetsPerTermAvg: rawReply[35],
      offsetBitsPerRecordAvg: rawReply[37],
      hashIndexingFailures: rawReply[39],
      indexing: rawReply[41],
      percentIndexed: rawReply[43],
      gcStats: {
        bytesCollected: rawReply[45][1],
        totalMsRun: rawReply[45][3],
        totalCycles: rawReply[45][5],
        averageCycleTimeMs: rawReply[45][7],
        lastRunTimeMs: rawReply[45][9],
        gcNumericTreesMissed: rawReply[45][11],
        gcBlocksDenied: rawReply[45][13]
      },
      cursorStats: {
        globalIdle: rawReply[47][1],
        globalTotal: rawReply[47][3],
        indexCapacity: rawReply[47][5],
        idnexTotal: rawReply[47][7]
      },
      stopWords: rawReply[49]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SEARCH.js
var require_SEARCH = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    return (0, _1.pushSearchOptions)(["FT.SEARCH", index, query], options);
  };
  var transformReply = function(reply, withoutDocuments) {
    const documents = [];
    let i = 1;
    while (i < reply.length) {
      documents.push({
        id: reply[i++],
        value: withoutDocuments ? Object.create(null) : documentValue(reply[i++])
      });
    }
    return {
      total: reply[0],
      documents
    };
  };
  var documentValue = function(tuples) {
    const message = Object.create(null);
    let i = 0;
    while (i < tuples.length) {
      const key = tuples[i++], value26 = tuples[i++];
      if (key === "$") {
        try {
          Object.assign(message, JSON.parse(value26));
          continue;
        } catch {
        }
      }
      message[key] = value26;
    }
    return message;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/PROFILE_SEARCH.js
var require_PROFILE_SEARCH = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    let args = ["FT.PROFILE", index, "SEARCH"];
    if (options?.LIMITED) {
      args.push("LIMITED");
    }
    args.push("QUERY", query);
    return (0, _1.pushSearchOptions)(args, options);
  };
  var transformReply = function(reply, withoutDocuments) {
    return {
      results: (0, SEARCH_1.transformReply)(reply[0], withoutDocuments),
      profile: (0, _1.transformProfile)(reply[1])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SEARCH_1 = require_SEARCH();
  var _1 = require_commands6();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/PROFILE_AGGREGATE.js
var require_PROFILE_AGGREGATE = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    const args = ["FT.PROFILE", index, "AGGREGATE"];
    if (options?.LIMITED) {
      args.push("LIMITED");
    }
    args.push("QUERY", query);
    (0, AGGREGATE_1.pushAggregatehOptions)(args, options);
    return args;
  };
  var transformReply = function(reply) {
    return {
      results: (0, AGGREGATE_1.transformReply)(reply[0]),
      profile: (0, _1.transformProfile)(reply[1])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var AGGREGATE_1 = require_AGGREGATE();
  var _1 = require_commands6();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SEARCH_NOCONTENT.js
var require_SEARCH_NOCONTENT = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    return (0, _1.pushSearchOptions)(["FT.SEARCH", index, query, "NOCONTENT"], options);
  };
  var transformReply = function(reply) {
    return {
      total: reply[0],
      documents: reply.slice(1)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SPELLCHECK.js
var require_SPELLCHECK = __commonJS((exports) => {
  var transformArguments = function(index, query, options) {
    const args = ["FT.SPELLCHECK", index, query];
    if (options?.DISTANCE) {
      args.push("DISTANCE", options.DISTANCE.toString());
    }
    if (options?.TERMS) {
      if (Array.isArray(options.TERMS)) {
        for (const term of options.TERMS) {
          pushTerms(args, term);
        }
      } else {
        pushTerms(args, options.TERMS);
      }
    }
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    return args;
  };
  var pushTerms = function(args, { mode, dictionary }) {
    args.push("TERMS", mode, dictionary);
  };
  var transformReply = function(rawReply) {
    return rawReply.map(([, term, suggestions]) => ({
      term,
      suggestions: suggestions.map(([score, suggestion]) => ({
        score: Number(score),
        suggestion
      }))
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGADD.js
var require_SUGADD = __commonJS((exports) => {
  var transformArguments = function(key, string5, score, options) {
    const args = ["FT.SUGADD", key, string5, score.toString()];
    if (options?.INCR) {
      args.push("INCR");
    }
    if (options?.PAYLOAD) {
      args.push("PAYLOAD", options.PAYLOAD);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SUGDEL.js
var require_SUGDEL = __commonJS((exports) => {
  var transformArguments = function(key, string5) {
    return ["FT.SUGDEL", key, string5];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/search/dist/commands/SUGGET.js
var require_SUGGET = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    const args = ["FT.SUGGET", key, prefix];
    if (options?.FUZZY) {
      args.push("FUZZY");
    }
    if (options?.MAX) {
      args.push("MAX", options.MAX.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SUGGET_WITHPAYLOADS.js
var require_SUGGET_WITHPAYLOADS = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    return [
      ...(0, SUGGET_1.transformArguments)(key, prefix, options),
      "WITHPAYLOADS"
    ];
  };
  var transformReply = function(rawReply) {
    if (rawReply === null)
      return null;
    const transformedReply = [];
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply.push({
        suggestion: rawReply[i],
        payload: rawReply[i + 1]
      });
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SUGGET_1 = require_SUGGET();
  var SUGGET_2 = require_SUGGET();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return SUGGET_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGGET_WITHSCORES_WITHPAYLOADS.js
var require_SUGGET_WITHSCORES_WITHPAYLOADS = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    return [
      ...(0, SUGGET_1.transformArguments)(key, prefix, options),
      "WITHSCORES",
      "WITHPAYLOADS"
    ];
  };
  var transformReply = function(rawReply) {
    if (rawReply === null)
      return null;
    const transformedReply = [];
    for (let i = 0;i < rawReply.length; i += 3) {
      transformedReply.push({
        suggestion: rawReply[i],
        score: Number(rawReply[i + 1]),
        payload: rawReply[i + 2]
      });
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SUGGET_1 = require_SUGGET();
  var SUGGET_2 = require_SUGGET();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return SUGGET_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGGET_WITHSCORES.js
var require_SUGGET_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    return [
      ...(0, SUGGET_1.transformArguments)(key, prefix, options),
      "WITHSCORES"
    ];
  };
  var transformReply = function(rawReply) {
    if (rawReply === null)
      return null;
    const transformedReply = [];
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply.push({
        suggestion: rawReply[i],
        score: Number(rawReply[i + 1])
      });
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SUGGET_1 = require_SUGGET();
  var SUGGET_2 = require_SUGGET();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return SUGGET_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGLEN.js
var require_SUGLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["FT.SUGLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SYNDUMP.js
var require_SYNDUMP = __commonJS((exports) => {
  var transformArguments = function(index) {
    return ["FT.SYNDUMP", index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SYNUPDATE.js
var require_SYNUPDATE = __commonJS((exports) => {
  var transformArguments = function(index, groupId, terms, options) {
    const args = ["FT.SYNUPDATE", index, groupId];
    if (options?.SKIPINITIALSCAN) {
      args.push("SKIPINITIALSCAN");
    }
    return (0, generic_transformers_1.pushVerdictArguments)(args, terms);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/TAGVALS.js
var require_TAGVALS = __commonJS((exports) => {
  var transformArguments = function(index, fieldName) {
    return ["FT.TAGVALS", index, fieldName];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/index.js
var require_commands6 = __commonJS((exports) => {
  var pushSortByProperty = function(args, sortBy) {
    if (typeof sortBy === "string") {
      args.push(sortBy);
    } else {
      args.push(sortBy.BY);
      if (sortBy.DIRECTION) {
        args.push(sortBy.DIRECTION);
      }
    }
  };
  var pushSortByArguments = function(args, name, sortBy) {
    const lengthBefore = args.push(name, "");
    if (Array.isArray(sortBy)) {
      for (const field of sortBy) {
        pushSortByProperty(args, field);
      }
    } else {
      pushSortByProperty(args, sortBy);
    }
    args[lengthBefore - 1] = (args.length - lengthBefore).toString();
    return args;
  };
  var pushArgumentsWithLength = function(args, fn) {
    const lengthIndex = args.push("") - 1;
    fn(args);
    args[lengthIndex] = (args.length - lengthIndex - 1).toString();
    return args;
  };
  var pushCommonFieldArguments = function(args, fieldOptions) {
    if (fieldOptions.SORTABLE) {
      args.push("SORTABLE");
      if (fieldOptions.SORTABLE === "UNF") {
        args.push("UNF");
      }
    }
    if (fieldOptions.NOINDEX) {
      args.push("NOINDEX");
    }
  };
  var pushSchema = function(args, schema) {
    for (const [field, fieldOptions] of Object.entries(schema)) {
      args.push(field);
      if (typeof fieldOptions === "string") {
        args.push(fieldOptions);
        continue;
      }
      if (fieldOptions.AS) {
        args.push("AS", fieldOptions.AS);
      }
      args.push(fieldOptions.type);
      switch (fieldOptions.type) {
        case SchemaFieldTypes.TEXT:
          if (fieldOptions.NOSTEM) {
            args.push("NOSTEM");
          }
          if (fieldOptions.WEIGHT) {
            args.push("WEIGHT", fieldOptions.WEIGHT.toString());
          }
          if (fieldOptions.PHONETIC) {
            args.push("PHONETIC", fieldOptions.PHONETIC);
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            args.push("WITHSUFFIXTRIE");
          }
          pushCommonFieldArguments(args, fieldOptions);
          if (fieldOptions.INDEXEMPTY) {
            args.push("INDEXEMPTY");
          }
          break;
        case SchemaFieldTypes.NUMERIC:
        case SchemaFieldTypes.GEO:
          pushCommonFieldArguments(args, fieldOptions);
          break;
        case SchemaFieldTypes.TAG:
          if (fieldOptions.SEPARATOR) {
            args.push("SEPARATOR", fieldOptions.SEPARATOR);
          }
          if (fieldOptions.CASESENSITIVE) {
            args.push("CASESENSITIVE");
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            args.push("WITHSUFFIXTRIE");
          }
          pushCommonFieldArguments(args, fieldOptions);
          if (fieldOptions.INDEXEMPTY) {
            args.push("INDEXEMPTY");
          }
          break;
        case SchemaFieldTypes.VECTOR:
          args.push(fieldOptions.ALGORITHM);
          pushArgumentsWithLength(args, () => {
            args.push("TYPE", fieldOptions.TYPE, "DIM", fieldOptions.DIM.toString(), "DISTANCE_METRIC", fieldOptions.DISTANCE_METRIC);
            if (fieldOptions.INITIAL_CAP) {
              args.push("INITIAL_CAP", fieldOptions.INITIAL_CAP.toString());
            }
            switch (fieldOptions.ALGORITHM) {
              case VectorAlgorithms.FLAT:
                if (fieldOptions.BLOCK_SIZE) {
                  args.push("BLOCK_SIZE", fieldOptions.BLOCK_SIZE.toString());
                }
                break;
              case VectorAlgorithms.HNSW:
                if (fieldOptions.M) {
                  args.push("M", fieldOptions.M.toString());
                }
                if (fieldOptions.EF_CONSTRUCTION) {
                  args.push("EF_CONSTRUCTION", fieldOptions.EF_CONSTRUCTION.toString());
                }
                if (fieldOptions.EF_RUNTIME) {
                  args.push("EF_RUNTIME", fieldOptions.EF_RUNTIME.toString());
                }
                break;
            }
          });
          break;
        case SchemaFieldTypes.GEOSHAPE:
          if (fieldOptions.COORD_SYSTEM !== undefined) {
            args.push("COORD_SYSTEM", fieldOptions.COORD_SYSTEM);
          }
          pushCommonFieldArguments(args, fieldOptions);
          break;
      }
      if (fieldOptions.INDEXMISSING) {
        args.push("INDEXMISSING");
      }
    }
  };
  var pushParamsArgs = function(args, params) {
    if (params) {
      const enrties = Object.entries(params);
      args.push("PARAMS", (enrties.length * 2).toString());
      for (const [key, value26] of enrties) {
        args.push(key, typeof value26 === "number" ? value26.toString() : value26);
      }
    }
    return args;
  };
  var pushSearchOptions = function(args, options) {
    if (options?.VERBATIM) {
      args.push("VERBATIM");
    }
    if (options?.NOSTOPWORDS) {
      args.push("NOSTOPWORDS");
    }
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "INKEYS", options?.INKEYS);
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "INFIELDS", options?.INFIELDS);
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "RETURN", options?.RETURN);
    if (options?.SUMMARIZE) {
      args.push("SUMMARIZE");
      if (typeof options.SUMMARIZE === "object") {
        if (options.SUMMARIZE.FIELDS) {
          args.push("FIELDS");
          (0, generic_transformers_1.pushVerdictArgument)(args, options.SUMMARIZE.FIELDS);
        }
        if (options.SUMMARIZE.FRAGS) {
          args.push("FRAGS", options.SUMMARIZE.FRAGS.toString());
        }
        if (options.SUMMARIZE.LEN) {
          args.push("LEN", options.SUMMARIZE.LEN.toString());
        }
        if (options.SUMMARIZE.SEPARATOR) {
          args.push("SEPARATOR", options.SUMMARIZE.SEPARATOR);
        }
      }
    }
    if (options?.HIGHLIGHT) {
      args.push("HIGHLIGHT");
      if (typeof options.HIGHLIGHT === "object") {
        if (options.HIGHLIGHT.FIELDS) {
          args.push("FIELDS");
          (0, generic_transformers_1.pushVerdictArgument)(args, options.HIGHLIGHT.FIELDS);
        }
        if (options.HIGHLIGHT.TAGS) {
          args.push("TAGS", options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
        }
      }
    }
    if (options?.SLOP) {
      args.push("SLOP", options.SLOP.toString());
    }
    if (options?.INORDER) {
      args.push("INORDER");
    }
    if (options?.LANGUAGE) {
      args.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.EXPANDER) {
      args.push("EXPANDER", options.EXPANDER);
    }
    if (options?.SCORER) {
      args.push("SCORER", options.SCORER);
    }
    if (options?.SORTBY) {
      args.push("SORTBY");
      pushSortByProperty(args, options.SORTBY);
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.from.toString(), options.LIMIT.size.toString());
    }
    if (options?.PARAMS) {
      pushParamsArgs(args, options.PARAMS);
    }
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    if (options?.RETURN?.length === 0) {
      args.preserve = true;
    }
    if (options?.TIMEOUT !== undefined) {
      args.push("TIMEOUT", options.TIMEOUT.toString());
    }
    return args;
  };
  var transformProfile = function(reply) {
    return {
      totalProfileTime: reply[0][1],
      parsingTime: reply[1][1],
      pipelineCreationTime: reply[2][1],
      iteratorsProfile: transformIterators(reply[3][1])
    };
  };
  var transformIterators = function(IteratorsProfile) {
    var res = {};
    for (let i = 0;i < IteratorsProfile.length; i += 2) {
      const value26 = IteratorsProfile[i + 1];
      switch (IteratorsProfile[i]) {
        case "Type":
          res.type = value26;
          break;
        case "Counter":
          res.counter = value26;
          break;
        case "Time":
          res.time = value26;
          break;
        case "Query type":
          res.queryType = value26;
          break;
        case "Child iterators":
          res.childIterators = value26.map(transformChildIterators);
          break;
      }
    }
    return res;
  };
  var transformChildIterators = function(IteratorsProfile) {
    var res = {};
    for (let i = 1;i < IteratorsProfile.length; i += 2) {
      const value26 = IteratorsProfile[i + 1];
      switch (IteratorsProfile[i]) {
        case "Type":
          res.type = value26;
          break;
        case "Counter":
          res.counter = value26;
          break;
        case "Time":
          res.time = value26;
          break;
        case "Size":
          res.size = value26;
          break;
        case "Term":
          res.term = value26;
          break;
        case "Child iterators":
          res.childIterators = value26.map(transformChildIterators);
          break;
      }
    }
    return res;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformProfile = exports.pushSearchOptions = exports.pushParamsArgs = exports.pushSchema = exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = exports.VectorAlgorithms = exports.SchemaTextFieldPhonetics = exports.SchemaFieldTypes = exports.pushArgumentsWithLength = exports.pushSortByArguments = exports.pushSortByProperty = exports.RedisSearchLanguages = undefined;
  var _LIST = require__LIST();
  var ALTER = require_ALTER();
  var AGGREGATE_WITHCURSOR = require_AGGREGATE_WITHCURSOR();
  var AGGREGATE = require_AGGREGATE();
  var ALIASADD = require_ALIASADD();
  var ALIASDEL = require_ALIASDEL();
  var ALIASUPDATE = require_ALIASUPDATE();
  var CONFIG_GET = require_CONFIG_GET3();
  var CONFIG_SET = require_CONFIG_SET3();
  var CREATE = require_CREATE2();
  var CURSOR_DEL = require_CURSOR_DEL();
  var CURSOR_READ = require_CURSOR_READ();
  var DICTADD = require_DICTADD();
  var DICTDEL = require_DICTDEL();
  var DICTDUMP = require_DICTDUMP();
  var DROPINDEX = require_DROPINDEX();
  var EXPLAIN = require_EXPLAIN2();
  var EXPLAINCLI = require_EXPLAINCLI();
  var INFO = require_INFO7();
  var PROFILESEARCH = require_PROFILE_SEARCH();
  var PROFILEAGGREGATE = require_PROFILE_AGGREGATE();
  var SEARCH = require_SEARCH();
  var SEARCH_NOCONTENT = require_SEARCH_NOCONTENT();
  var SPELLCHECK = require_SPELLCHECK();
  var SUGADD = require_SUGADD();
  var SUGDEL = require_SUGDEL();
  var SUGGET_WITHPAYLOADS = require_SUGGET_WITHPAYLOADS();
  var SUGGET_WITHSCORES_WITHPAYLOADS = require_SUGGET_WITHSCORES_WITHPAYLOADS();
  var SUGGET_WITHSCORES = require_SUGGET_WITHSCORES();
  var SUGGET = require_SUGGET();
  var SUGLEN = require_SUGLEN();
  var SYNDUMP = require_SYNDUMP();
  var SYNUPDATE = require_SYNUPDATE();
  var TAGVALS = require_TAGVALS();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    _LIST,
    _list: _LIST,
    ALTER,
    alter: ALTER,
    AGGREGATE_WITHCURSOR,
    aggregateWithCursor: AGGREGATE_WITHCURSOR,
    AGGREGATE,
    aggregate: AGGREGATE,
    ALIASADD,
    aliasAdd: ALIASADD,
    ALIASDEL,
    aliasDel: ALIASDEL,
    ALIASUPDATE,
    aliasUpdate: ALIASUPDATE,
    CONFIG_GET,
    configGet: CONFIG_GET,
    CONFIG_SET,
    configSet: CONFIG_SET,
    CREATE,
    create: CREATE,
    CURSOR_DEL,
    cursorDel: CURSOR_DEL,
    CURSOR_READ,
    cursorRead: CURSOR_READ,
    DICTADD,
    dictAdd: DICTADD,
    DICTDEL,
    dictDel: DICTDEL,
    DICTDUMP,
    dictDump: DICTDUMP,
    DROPINDEX,
    dropIndex: DROPINDEX,
    EXPLAIN,
    explain: EXPLAIN,
    EXPLAINCLI,
    explainCli: EXPLAINCLI,
    INFO,
    info: INFO,
    PROFILESEARCH,
    profileSearch: PROFILESEARCH,
    PROFILEAGGREGATE,
    profileAggregate: PROFILEAGGREGATE,
    SEARCH,
    search: SEARCH,
    SEARCH_NOCONTENT,
    searchNoContent: SEARCH_NOCONTENT,
    SPELLCHECK,
    spellCheck: SPELLCHECK,
    SUGADD,
    sugAdd: SUGADD,
    SUGDEL,
    sugDel: SUGDEL,
    SUGGET_WITHPAYLOADS,
    sugGetWithPayloads: SUGGET_WITHPAYLOADS,
    SUGGET_WITHSCORES_WITHPAYLOADS,
    sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS,
    SUGGET_WITHSCORES,
    sugGetWithScores: SUGGET_WITHSCORES,
    SUGGET,
    sugGet: SUGGET,
    SUGLEN,
    sugLen: SUGLEN,
    SYNDUMP,
    synDump: SYNDUMP,
    SYNUPDATE,
    synUpdate: SYNUPDATE,
    TAGVALS,
    tagVals: TAGVALS
  };
  var RedisSearchLanguages;
  (function(RedisSearchLanguages2) {
    RedisSearchLanguages2["ARABIC"] = "Arabic";
    RedisSearchLanguages2["BASQUE"] = "Basque";
    RedisSearchLanguages2["CATALANA"] = "Catalan";
    RedisSearchLanguages2["DANISH"] = "Danish";
    RedisSearchLanguages2["DUTCH"] = "Dutch";
    RedisSearchLanguages2["ENGLISH"] = "English";
    RedisSearchLanguages2["FINNISH"] = "Finnish";
    RedisSearchLanguages2["FRENCH"] = "French";
    RedisSearchLanguages2["GERMAN"] = "German";
    RedisSearchLanguages2["GREEK"] = "Greek";
    RedisSearchLanguages2["HUNGARIAN"] = "Hungarian";
    RedisSearchLanguages2["INDONESAIN"] = "Indonesian";
    RedisSearchLanguages2["IRISH"] = "Irish";
    RedisSearchLanguages2["ITALIAN"] = "Italian";
    RedisSearchLanguages2["LITHUANIAN"] = "Lithuanian";
    RedisSearchLanguages2["NEPALI"] = "Nepali";
    RedisSearchLanguages2["NORWEIGAN"] = "Norwegian";
    RedisSearchLanguages2["PORTUGUESE"] = "Portuguese";
    RedisSearchLanguages2["ROMANIAN"] = "Romanian";
    RedisSearchLanguages2["RUSSIAN"] = "Russian";
    RedisSearchLanguages2["SPANISH"] = "Spanish";
    RedisSearchLanguages2["SWEDISH"] = "Swedish";
    RedisSearchLanguages2["TAMIL"] = "Tamil";
    RedisSearchLanguages2["TURKISH"] = "Turkish";
    RedisSearchLanguages2["CHINESE"] = "Chinese";
  })(RedisSearchLanguages || (exports.RedisSearchLanguages = RedisSearchLanguages = {}));
  exports.pushSortByProperty = pushSortByProperty;
  exports.pushSortByArguments = pushSortByArguments;
  exports.pushArgumentsWithLength = pushArgumentsWithLength;
  var SchemaFieldTypes;
  (function(SchemaFieldTypes2) {
    SchemaFieldTypes2["TEXT"] = "TEXT";
    SchemaFieldTypes2["NUMERIC"] = "NUMERIC";
    SchemaFieldTypes2["GEO"] = "GEO";
    SchemaFieldTypes2["TAG"] = "TAG";
    SchemaFieldTypes2["VECTOR"] = "VECTOR";
    SchemaFieldTypes2["GEOSHAPE"] = "GEOSHAPE";
  })(SchemaFieldTypes || (exports.SchemaFieldTypes = SchemaFieldTypes = {}));
  var SchemaTextFieldPhonetics;
  (function(SchemaTextFieldPhonetics2) {
    SchemaTextFieldPhonetics2["DM_EN"] = "dm:en";
    SchemaTextFieldPhonetics2["DM_FR"] = "dm:fr";
    SchemaTextFieldPhonetics2["FM_PT"] = "dm:pt";
    SchemaTextFieldPhonetics2["DM_ES"] = "dm:es";
  })(SchemaTextFieldPhonetics || (exports.SchemaTextFieldPhonetics = SchemaTextFieldPhonetics = {}));
  var VectorAlgorithms;
  (function(VectorAlgorithms2) {
    VectorAlgorithms2["FLAT"] = "FLAT";
    VectorAlgorithms2["HNSW"] = "HNSW";
  })(VectorAlgorithms || (exports.VectorAlgorithms = VectorAlgorithms = {}));
  exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = {
    SPHERICAL: "SPHERICAL",
    FLAT: "FLAT"
  };
  exports.pushSchema = pushSchema;
  exports.pushParamsArgs = pushParamsArgs;
  exports.pushSearchOptions = pushSearchOptions;
  exports.transformProfile = transformProfile;
});

// node_modules/@redis/search/dist/index.js
var require_dist7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateSteps = exports.AggregateGroupByReducers = exports.VectorAlgorithms = exports.SchemaTextFieldPhonetics = exports.SchemaFieldTypes = exports.RedisSearchLanguages = exports.default = undefined;
  var commands_1 = require_commands6();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
  var commands_2 = require_commands6();
  Object.defineProperty(exports, "RedisSearchLanguages", { enumerable: true, get: function() {
    return commands_2.RedisSearchLanguages;
  } });
  Object.defineProperty(exports, "SchemaFieldTypes", { enumerable: true, get: function() {
    return commands_2.SchemaFieldTypes;
  } });
  Object.defineProperty(exports, "SchemaTextFieldPhonetics", { enumerable: true, get: function() {
    return commands_2.SchemaTextFieldPhonetics;
  } });
  Object.defineProperty(exports, "VectorAlgorithms", { enumerable: true, get: function() {
    return commands_2.VectorAlgorithms;
  } });
  var AGGREGATE_1 = require_AGGREGATE();
  Object.defineProperty(exports, "AggregateGroupByReducers", { enumerable: true, get: function() {
    return AGGREGATE_1.AggregateGroupByReducers;
  } });
  Object.defineProperty(exports, "AggregateSteps", { enumerable: true, get: function() {
    return AGGREGATE_1.AggregateSteps;
  } });
});

// node_modules/@redis/time-series/dist/commands/ADD.js
var require_ADD5 = __commonJS((exports) => {
  var transformArguments = function(key, timestamp, value26, options) {
    const args = [
      "TS.ADD",
      key,
      (0, _1.transformTimestampArgument)(timestamp),
      value26.toString()
    ];
    (0, _1.pushRetentionArgument)(args, options?.RETENTION);
    (0, _1.pushEncodingArgument)(args, options?.ENCODING);
    (0, _1.pushChunkSizeArgument)(args, options?.CHUNK_SIZE);
    if (options?.ON_DUPLICATE) {
      args.push("ON_DUPLICATE", options.ON_DUPLICATE);
    }
    (0, _1.pushLabelsArgument)(args, options?.LABELS);
    (0, _1.pushIgnoreArgument)(args, options?.IGNORE);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/ALTER.js
var require_ALTER2 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    const args = ["TS.ALTER", key];
    (0, _1.pushRetentionArgument)(args, options?.RETENTION);
    (0, _1.pushChunkSizeArgument)(args, options?.CHUNK_SIZE);
    (0, _1.pushDuplicatePolicy)(args, options?.DUPLICATE_POLICY);
    (0, _1.pushLabelsArgument)(args, options?.LABELS);
    (0, _1.pushIgnoreArgument)(args, options?.IGNORE);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/CREATE.js
var require_CREATE3 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    const args = ["TS.CREATE", key];
    (0, _1.pushRetentionArgument)(args, options?.RETENTION);
    (0, _1.pushEncodingArgument)(args, options?.ENCODING);
    (0, _1.pushChunkSizeArgument)(args, options?.CHUNK_SIZE);
    (0, _1.pushDuplicatePolicy)(args, options?.DUPLICATE_POLICY);
    (0, _1.pushLabelsArgument)(args, options?.LABELS);
    (0, _1.pushIgnoreArgument)(args, options?.IGNORE);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/CREATERULE.js
var require_CREATERULE = __commonJS((exports) => {
  var transformArguments = function(sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
    const args = [
      "TS.CREATERULE",
      sourceKey,
      destinationKey,
      "AGGREGATION",
      aggregationType,
      bucketDuration.toString()
    ];
    if (alignTimestamp) {
      args.push(alignTimestamp.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/DECRBY.js
var require_DECRBY2 = __commonJS((exports) => {
  var transformArguments = function(key, value26, options) {
    return (0, _1.transformIncrDecrArguments)("TS.DECRBY", key, value26, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/DEL.js
var require_DEL4 = __commonJS((exports) => {
  var transformArguments = function(key, fromTimestamp, toTimestamp) {
    return [
      "TS.DEL",
      key,
      (0, _1.transformTimestampArgument)(fromTimestamp),
      (0, _1.transformTimestampArgument)(toTimestamp)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRTS_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRTS_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/DELETERULE.js
var require_DELETERULE = __commonJS((exports) => {
  var transformArguments = function(sourceKey, destinationKey) {
    return [
      "TS.DELETERULE",
      sourceKey,
      destinationKey
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/GET.js
var require_GET3 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, _1.pushLatestArgument)(["TS.GET", key], options?.LATEST);
  };
  var transformReply = function(reply) {
    if (reply.length === 0)
      return null;
    return (0, _1.transformSampleReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/INCRBY.js
var require_INCRBY4 = __commonJS((exports) => {
  var transformArguments = function(key, value26, options) {
    return (0, _1.transformIncrDecrArguments)("TS.INCRBY", key, value26, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/INFO.js
var require_INFO8 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TS.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      totalSamples: reply[1],
      memoryUsage: reply[3],
      firstTimestamp: reply[5],
      lastTimestamp: reply[7],
      retentionTime: reply[9],
      chunkCount: reply[11],
      chunkSize: reply[13],
      chunkType: reply[15],
      duplicatePolicy: reply[17],
      labels: reply[19].map(([name, value26]) => ({
        name,
        value: value26
      })),
      sourceKey: reply[21],
      rules: reply[23].map(([key, timeBucket, aggregationType]) => ({
        key,
        timeBucket,
        aggregationType
      }))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/INFO_DEBUG.js
var require_INFO_DEBUG = __commonJS((exports) => {
  var transformArguments = function(key) {
    const args = (0, INFO_1.transformArguments)(key);
    args.push("DEBUG");
    return args;
  };
  var transformReply = function(rawReply) {
    const reply = (0, INFO_1.transformReply)(rawReply);
    reply.keySelfName = rawReply[25];
    reply.chunks = rawReply[27].map((chunk) => ({
      startTimestamp: chunk[1],
      endTimestamp: chunk[3],
      samples: chunk[5],
      size: chunk[7],
      bytesPerSample: chunk[9]
    }));
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = exports.IS_READ_ONLY = undefined;
  var INFO_1 = require_INFO8();
  var INFO_2 = require_INFO8();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return INFO_2.IS_READ_ONLY;
  } });
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return INFO_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/MADD.js
var require_MADD2 = __commonJS((exports) => {
  var transformArguments = function(toAdd) {
    const args = ["TS.MADD"];
    for (const { key, timestamp, value: value26 } of toAdd) {
      args.push(key, (0, _1.transformTimestampArgument)(timestamp), value26.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/MGET.js
var require_MGET3 = __commonJS((exports) => {
  var transformArguments = function(filter, options) {
    const args = (0, _1.pushLatestArgument)(["TS.MGET"], options?.LATEST);
    return (0, _1.pushFilterArgument)(args, filter);
  };
  var transformReply = function(reply) {
    return reply.map(([key, _2, sample]) => ({
      key,
      sample: (0, _1.transformSampleReply)(sample)
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/MGET_WITHLABELS.js
var require_MGET_WITHLABELS = __commonJS((exports) => {
  var transformArguments = function(filter, options) {
    const args = (0, _1.pushWithLabelsArgument)(["TS.MGET"], options?.SELECTED_LABELS);
    return (0, _1.pushFilterArgument)(args, filter);
  };
  var transformReply = function(reply) {
    return reply.map(([key, labels, sample]) => ({
      key,
      labels: (0, _1.transformLablesReply)(labels),
      sample: (0, _1.transformSampleReply)(sample)
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/QUERYINDEX.js
var require_QUERYINDEX = __commonJS((exports) => {
  var transformArguments = function(filter) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TS.QUERYINDEX"], filter);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/RANGE.js
var require_RANGE = __commonJS((exports) => {
  var transformArguments = function(key, fromTimestamp, toTimestamp, options) {
    return (0, _1.pushRangeArguments)(["TS.RANGE", key], fromTimestamp, toTimestamp, options);
  };
  var transformReply = function(reply) {
    return (0, _1.transformRangeReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/REVRANGE.js
var require_REVRANGE = __commonJS((exports) => {
  var transformArguments = function(key, fromTimestamp, toTimestamp, options) {
    return (0, _1.pushRangeArguments)(["TS.REVRANGE", key], fromTimestamp, toTimestamp, options);
  };
  var transformReply = function(reply) {
    return (0, _1.transformRangeReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/MRANGE.js
var require_MRANGE = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeArguments)(["TS.MRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands7();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/MRANGE_WITHLABELS.js
var require_MRANGE_WITHLABELS = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeWithLabelsArguments)(["TS.MRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands7();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeWithLabelsReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/MREVRANGE.js
var require_MREVRANGE = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeArguments)(["TS.MREVRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands7();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/MREVRANGE_WITHLABELS.js
var require_MREVRANGE_WITHLABELS = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeWithLabelsArguments)(["TS.MREVRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands7();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeWithLabelsReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/index.js
var require_commands7 = __commonJS((exports) => {
  var transformTimestampArgument = function(timestamp) {
    if (typeof timestamp === "string")
      return timestamp;
    return (typeof timestamp === "number" ? timestamp : timestamp.getTime()).toString();
  };
  var pushIgnoreArgument = function(args, ignore) {
    if (ignore !== undefined) {
      args.push("IGNORE", ignore.MAX_TIME_DIFF.toString(), ignore.MAX_VAL_DIFF.toString());
    }
  };
  var pushRetentionArgument = function(args, retention) {
    if (retention !== undefined) {
      args.push("RETENTION", retention.toString());
    }
    return args;
  };
  var pushEncodingArgument = function(args, encoding) {
    if (encoding !== undefined) {
      args.push("ENCODING", encoding);
    }
    return args;
  };
  var pushChunkSizeArgument = function(args, chunkSize) {
    if (chunkSize !== undefined) {
      args.push("CHUNK_SIZE", chunkSize.toString());
    }
    return args;
  };
  var pushDuplicatePolicy = function(args, duplicatePolicy) {
    if (duplicatePolicy !== undefined) {
      args.push("DUPLICATE_POLICY", duplicatePolicy);
    }
    return args;
  };
  var transformLablesReply = function(reply) {
    const labels = {};
    for (const [key, value26] of reply) {
      labels[key] = value26;
    }
    return labels;
  };
  var pushLabelsArgument = function(args, labels) {
    if (labels) {
      args.push("LABELS");
      for (const [label, value26] of Object.entries(labels)) {
        args.push(label, value26);
      }
    }
    return args;
  };
  var transformIncrDecrArguments = function(command, key, value26, options) {
    const args = [
      command,
      key,
      value26.toString()
    ];
    if (options?.TIMESTAMP !== undefined && options?.TIMESTAMP !== null) {
      args.push("TIMESTAMP", transformTimestampArgument(options.TIMESTAMP));
    }
    pushRetentionArgument(args, options?.RETENTION);
    if (options?.UNCOMPRESSED) {
      args.push("UNCOMPRESSED");
    }
    pushChunkSizeArgument(args, options?.CHUNK_SIZE);
    pushLabelsArgument(args, options?.LABELS);
    return args;
  };
  var transformSampleReply = function(reply) {
    return {
      timestamp: reply[0],
      value: Number(reply[1])
    };
  };
  var pushRangeArguments = function(args, fromTimestamp, toTimestamp, options) {
    args.push(transformTimestampArgument(fromTimestamp), transformTimestampArgument(toTimestamp));
    pushLatestArgument(args, options?.LATEST);
    if (options?.FILTER_BY_TS) {
      args.push("FILTER_BY_TS");
      for (const ts of options.FILTER_BY_TS) {
        args.push(transformTimestampArgument(ts));
      }
    }
    if (options?.FILTER_BY_VALUE) {
      args.push("FILTER_BY_VALUE", options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    if (options?.ALIGN) {
      args.push("ALIGN", transformTimestampArgument(options.ALIGN));
    }
    if (options?.AGGREGATION) {
      args.push("AGGREGATION", options.AGGREGATION.type, transformTimestampArgument(options.AGGREGATION.timeBucket));
      if (options.AGGREGATION.BUCKETTIMESTAMP) {
        args.push("BUCKETTIMESTAMP", options.AGGREGATION.BUCKETTIMESTAMP);
      }
      if (options.AGGREGATION.EMPTY) {
        args.push("EMPTY");
      }
    }
    return args;
  };
  var pushMRangeGroupByArguments = function(args, groupBy) {
    if (groupBy) {
      args.push("GROUPBY", groupBy.label, "REDUCE", groupBy.reducer);
    }
    return args;
  };
  var pushFilterArgument = function(args, filter) {
    args.push("FILTER");
    return (0, generic_transformers_1.pushVerdictArguments)(args, filter);
  };
  var pushMRangeArguments = function(args, fromTimestamp, toTimestamp, filter, options) {
    args = pushRangeArguments(args, fromTimestamp, toTimestamp, options);
    args = pushFilterArgument(args, filter);
    return pushMRangeGroupByArguments(args, options?.GROUPBY);
  };
  var pushWithLabelsArgument = function(args, selectedLabels) {
    if (!selectedLabels) {
      args.push("WITHLABELS");
    } else {
      args.push("SELECTED_LABELS");
      args = (0, generic_transformers_1.pushVerdictArguments)(args, selectedLabels);
    }
    return args;
  };
  var pushMRangeWithLabelsArguments = function(args, fromTimestamp, toTimestamp, filter, options) {
    args = pushRangeArguments(args, fromTimestamp, toTimestamp, options);
    args = pushWithLabelsArgument(args, options?.SELECTED_LABELS);
    args = pushFilterArgument(args, filter);
    return pushMRangeGroupByArguments(args, options?.GROUPBY);
  };
  var transformRangeReply = function(reply) {
    return reply.map(transformSampleReply);
  };
  var transformMRangeReply = function(reply) {
    const args = [];
    for (const [key, _2, sample] of reply) {
      args.push({
        key,
        samples: sample.map(transformSampleReply)
      });
    }
    return args;
  };
  var transformMRangeWithLabelsReply = function(reply) {
    const args = [];
    for (const [key, labels, samples] of reply) {
      args.push({
        key,
        labels: transformLablesReply(labels),
        samples: samples.map(transformSampleReply)
      });
    }
    return args;
  };
  var pushLatestArgument = function(args, latest) {
    if (latest) {
      args.push("LATEST");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushLatestArgument = exports.transformMRangeWithLabelsReply = exports.transformMRangeReply = exports.transformRangeReply = exports.pushMRangeWithLabelsArguments = exports.pushWithLabelsArgument = exports.pushMRangeArguments = exports.pushFilterArgument = exports.pushMRangeGroupByArguments = exports.pushRangeArguments = exports.TimeSeriesBucketTimestamp = exports.transformSampleReply = exports.transformIncrDecrArguments = exports.pushLabelsArgument = exports.transformLablesReply = exports.pushDuplicatePolicy = exports.pushChunkSizeArgument = exports.pushEncodingArgument = exports.TimeSeriesEncoding = exports.pushRetentionArgument = exports.pushIgnoreArgument = exports.transformTimestampArgument = exports.TimeSeriesReducers = exports.TimeSeriesDuplicatePolicies = exports.TimeSeriesAggregationType = undefined;
  var ADD = require_ADD5();
  var ALTER = require_ALTER2();
  var CREATE = require_CREATE3();
  var CREATERULE = require_CREATERULE();
  var DECRBY = require_DECRBY2();
  var DEL = require_DEL4();
  var DELETERULE = require_DELETERULE();
  var GET = require_GET3();
  var INCRBY = require_INCRBY4();
  var INFO_DEBUG = require_INFO_DEBUG();
  var INFO = require_INFO8();
  var MADD = require_MADD2();
  var MGET = require_MGET3();
  var MGET_WITHLABELS = require_MGET_WITHLABELS();
  var QUERYINDEX = require_QUERYINDEX();
  var RANGE = require_RANGE();
  var REVRANGE = require_REVRANGE();
  var MRANGE = require_MRANGE();
  var MRANGE_WITHLABELS = require_MRANGE_WITHLABELS();
  var MREVRANGE = require_MREVRANGE();
  var MREVRANGE_WITHLABELS = require_MREVRANGE_WITHLABELS();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    ADD,
    add: ADD,
    ALTER,
    alter: ALTER,
    CREATE,
    create: CREATE,
    CREATERULE,
    createRule: CREATERULE,
    DECRBY,
    decrBy: DECRBY,
    DEL,
    del: DEL,
    DELETERULE,
    deleteRule: DELETERULE,
    GET,
    get: GET,
    INCRBY,
    incrBy: INCRBY,
    INFO_DEBUG,
    infoDebug: INFO_DEBUG,
    INFO,
    info: INFO,
    MADD,
    mAdd: MADD,
    MGET,
    mGet: MGET,
    MGET_WITHLABELS,
    mGetWithLabels: MGET_WITHLABELS,
    QUERYINDEX,
    queryIndex: QUERYINDEX,
    RANGE,
    range: RANGE,
    REVRANGE,
    revRange: REVRANGE,
    MRANGE,
    mRange: MRANGE,
    MRANGE_WITHLABELS,
    mRangeWithLabels: MRANGE_WITHLABELS,
    MREVRANGE,
    mRevRange: MREVRANGE,
    MREVRANGE_WITHLABELS,
    mRevRangeWithLabels: MREVRANGE_WITHLABELS
  };
  var TimeSeriesAggregationType;
  (function(TimeSeriesAggregationType2) {
    TimeSeriesAggregationType2["AVG"] = "AVG";
    TimeSeriesAggregationType2["AVERAGE"] = "AVG";
    TimeSeriesAggregationType2["FIRST"] = "FIRST";
    TimeSeriesAggregationType2["LAST"] = "LAST";
    TimeSeriesAggregationType2["MIN"] = "MIN";
    TimeSeriesAggregationType2["MINIMUM"] = "MIN";
    TimeSeriesAggregationType2["MAX"] = "MAX";
    TimeSeriesAggregationType2["MAXIMUM"] = "MAX";
    TimeSeriesAggregationType2["SUM"] = "SUM";
    TimeSeriesAggregationType2["RANGE"] = "RANGE";
    TimeSeriesAggregationType2["COUNT"] = "COUNT";
    TimeSeriesAggregationType2["STD_P"] = "STD.P";
    TimeSeriesAggregationType2["STD_S"] = "STD.S";
    TimeSeriesAggregationType2["VAR_P"] = "VAR.P";
    TimeSeriesAggregationType2["VAR_S"] = "VAR.S";
    TimeSeriesAggregationType2["TWA"] = "TWA";
  })(TimeSeriesAggregationType || (exports.TimeSeriesAggregationType = TimeSeriesAggregationType = {}));
  var TimeSeriesDuplicatePolicies;
  (function(TimeSeriesDuplicatePolicies2) {
    TimeSeriesDuplicatePolicies2["BLOCK"] = "BLOCK";
    TimeSeriesDuplicatePolicies2["FIRST"] = "FIRST";
    TimeSeriesDuplicatePolicies2["LAST"] = "LAST";
    TimeSeriesDuplicatePolicies2["MIN"] = "MIN";
    TimeSeriesDuplicatePolicies2["MAX"] = "MAX";
    TimeSeriesDuplicatePolicies2["SUM"] = "SUM";
  })(TimeSeriesDuplicatePolicies || (exports.TimeSeriesDuplicatePolicies = TimeSeriesDuplicatePolicies = {}));
  var TimeSeriesReducers;
  (function(TimeSeriesReducers2) {
    TimeSeriesReducers2["AVG"] = "AVG";
    TimeSeriesReducers2["SUM"] = "SUM";
    TimeSeriesReducers2["MIN"] = "MIN";
    TimeSeriesReducers2["MINIMUM"] = "MIN";
    TimeSeriesReducers2["MAX"] = "MAX";
    TimeSeriesReducers2["MAXIMUM"] = "MAX";
    TimeSeriesReducers2["RANGE"] = "range";
    TimeSeriesReducers2["COUNT"] = "COUNT";
    TimeSeriesReducers2["STD_P"] = "STD.P";
    TimeSeriesReducers2["STD_S"] = "STD.S";
    TimeSeriesReducers2["VAR_P"] = "VAR.P";
    TimeSeriesReducers2["VAR_S"] = "VAR.S";
  })(TimeSeriesReducers || (exports.TimeSeriesReducers = TimeSeriesReducers = {}));
  exports.transformTimestampArgument = transformTimestampArgument;
  exports.pushIgnoreArgument = pushIgnoreArgument;
  exports.pushRetentionArgument = pushRetentionArgument;
  var TimeSeriesEncoding;
  (function(TimeSeriesEncoding2) {
    TimeSeriesEncoding2["COMPRESSED"] = "COMPRESSED";
    TimeSeriesEncoding2["UNCOMPRESSED"] = "UNCOMPRESSED";
  })(TimeSeriesEncoding || (exports.TimeSeriesEncoding = TimeSeriesEncoding = {}));
  exports.pushEncodingArgument = pushEncodingArgument;
  exports.pushChunkSizeArgument = pushChunkSizeArgument;
  exports.pushDuplicatePolicy = pushDuplicatePolicy;
  exports.transformLablesReply = transformLablesReply;
  exports.pushLabelsArgument = pushLabelsArgument;
  exports.transformIncrDecrArguments = transformIncrDecrArguments;
  exports.transformSampleReply = transformSampleReply;
  var TimeSeriesBucketTimestamp;
  (function(TimeSeriesBucketTimestamp2) {
    TimeSeriesBucketTimestamp2["LOW"] = "-";
    TimeSeriesBucketTimestamp2["HIGH"] = "+";
    TimeSeriesBucketTimestamp2["MID"] = "~";
  })(TimeSeriesBucketTimestamp || (exports.TimeSeriesBucketTimestamp = TimeSeriesBucketTimestamp = {}));
  exports.pushRangeArguments = pushRangeArguments;
  exports.pushMRangeGroupByArguments = pushMRangeGroupByArguments;
  exports.pushFilterArgument = pushFilterArgument;
  exports.pushMRangeArguments = pushMRangeArguments;
  exports.pushWithLabelsArgument = pushWithLabelsArgument;
  exports.pushMRangeWithLabelsArguments = pushMRangeWithLabelsArguments;
  exports.transformRangeReply = transformRangeReply;
  exports.transformMRangeReply = transformMRangeReply;
  exports.transformMRangeWithLabelsReply = transformMRangeWithLabelsReply;
  exports.pushLatestArgument = pushLatestArgument;
});

// node_modules/@redis/time-series/dist/index.js
var require_dist8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeSeriesBucketTimestamp = exports.TimeSeriesReducers = exports.TimeSeriesAggregationType = exports.TimeSeriesEncoding = exports.TimeSeriesDuplicatePolicies = exports.default = undefined;
  var commands_1 = require_commands7();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
  var commands_2 = require_commands7();
  Object.defineProperty(exports, "TimeSeriesDuplicatePolicies", { enumerable: true, get: function() {
    return commands_2.TimeSeriesDuplicatePolicies;
  } });
  Object.defineProperty(exports, "TimeSeriesEncoding", { enumerable: true, get: function() {
    return commands_2.TimeSeriesEncoding;
  } });
  Object.defineProperty(exports, "TimeSeriesAggregationType", { enumerable: true, get: function() {
    return commands_2.TimeSeriesAggregationType;
  } });
  Object.defineProperty(exports, "TimeSeriesReducers", { enumerable: true, get: function() {
    return commands_2.TimeSeriesReducers;
  } });
  Object.defineProperty(exports, "TimeSeriesBucketTimestamp", { enumerable: true, get: function() {
    return commands_2.TimeSeriesBucketTimestamp;
  } });
});

// node_modules/redis/dist/index.js
var require_dist9 = __commonJS((exports) => {
  var createClient = function(options) {
    return (0, client_1.createClient)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  };
  var createCluster = function(options) {
    return (0, client_1.createCluster)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCluster = exports.createClient = undefined;
  var client_1 = require_dist3();
  var bloom_1 = require_dist4();
  var graph_1 = require_dist5();
  var json_1 = require_dist6();
  var search_1 = require_dist7();
  var time_series_1 = require_dist8();
  __exportStar(require_dist3(), exports);
  __exportStar(require_dist4(), exports);
  __exportStar(require_dist5(), exports);
  __exportStar(require_dist6(), exports);
  __exportStar(require_dist7(), exports);
  __exportStar(require_dist8(), exports);
  var modules = {
    ...bloom_1.default,
    graph: graph_1.default,
    json: json_1.default,
    ft: search_1.default,
    ts: time_series_1.default
  };
  exports.createClient = createClient;
  exports.createCluster = createCluster;
});

// src/utils/redis.ts
var exports_redis = {};
__export(exports_redis, {
  updateConnectionState: () => {
    {
      return updateConnectionState;
    }
  },
  storeConnectionState: () => {
    {
      return storeConnectionState;
    }
  },
  removeConnectionState: () => {
    {
      return removeConnectionState;
    }
  },
  redisHealthCheck: () => {
    {
      return redisHealthCheck;
    }
  },
  isRedisAvailable: () => {
    {
      return isRedisAvailable;
    }
  },
  initializeRedis: () => {
    {
      return initializeRedis;
    }
  },
  getRedisClient: () => {
    {
      return getRedisClient;
    }
  },
  getConnectionStateTTL: () => {
    {
      return getConnectionStateTTL;
    }
  },
  getConnectionState: () => {
    {
      return getConnectionState;
    }
  },
  getAllConnectionStates: () => {
    {
      return getAllConnectionStates;
    }
  },
  closeRedis: () => {
    {
      return closeRedis;
    }
  },
  cleanupExpiredStates: () => {
    {
      return cleanupExpiredStates;
    }
  }
});
var import_redis, redisClient, REDIS_KEY_PREFIX, REDIS_RECONNECT_TTL, initializeRedis, getRedisClient, isRedisAvailable, storeConnectionState, getConnectionState, updateConnectionState, removeConnectionState, getConnectionStateTTL, getAllConnectionStates, cleanupExpiredStates, closeRedis, redisHealthCheck;
var init_redis = __esm(() => {
  import_redis = __toESM(require_dist9(), 1);
  init_logger();
  redisClient = null;
  REDIS_KEY_PREFIX = "websocket:connection:";
  REDIS_RECONNECT_TTL = 900;
  initializeRedis = async () => {
    try {
      redisClient = import_redis.createClient({
        url: process.env.REDIS_URL || "redis://redis:6379",
        socket: {
          connectTimeout: 5000,
          reconnectStrategy: (retries) => {
            if (retries > 3) {
              return new Error("Too many retries");
            }
            return Math.min(retries * 100, 3000);
          }
        }
      });
      redisClient.on("error", (error23) => {
        logError("Redis connection error", { error: error23.message });
      });
      redisClient.on("connect", () => {
        logInfo("Redis client connected");
      });
      redisClient.on("ready", () => {
        logInfo("Redis client ready");
      });
      redisClient.on("end", () => {
        logWarn("Redis connection ended");
      });
      await redisClient.connect();
      logInfo("Redis connection established successfully");
    } catch (error23) {
      logError("Failed to initialize Redis connection", { error: error23 });
      throw error23;
    }
  };
  getRedisClient = () => {
    return redisClient;
  };
  isRedisAvailable = () => {
    return redisClient !== null && redisClient.isReady;
  };
  storeConnectionState = async (connectionId, messageCount, metadata) => {
    if (!isRedisAvailable()) {
      logWarn("Redis not available, skipping connection state storage", { connectionId });
      return false;
    }
    try {
      const state = {
        connectionId,
        messageCount,
        lastActivity: Date.now(),
        metadata
      };
      const key = `${REDIS_KEY_PREFIX}${connectionId}`;
      await redisClient.setEx(key, REDIS_RECONNECT_TTL, JSON.stringify(state));
      logInfo("Connection state stored in Redis", {
        connectionId,
        messageCount,
        ttl: REDIS_RECONNECT_TTL
      });
      return true;
    } catch (error23) {
      logError("Failed to store connection state in Redis", {
        connectionId,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return false;
    }
  };
  getConnectionState = async (connectionId) => {
    if (!isRedisAvailable()) {
      logWarn("Redis not available, cannot retrieve connection state", { connectionId });
      return null;
    }
    try {
      const key = `${REDIS_KEY_PREFIX}${connectionId}`;
      const stateJson = await redisClient.get(key);
      if (!stateJson) {
        logInfo("No stored connection state found", { connectionId });
        return null;
      }
      const state = JSON.parse(stateJson);
      logInfo("Retrieved connection state from Redis", {
        connectionId,
        messageCount: state.messageCount,
        lastActivity: new Date(state.lastActivity).toISOString()
      });
      return state;
    } catch (error23) {
      logError("Failed to retrieve connection state from Redis", {
        connectionId,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return null;
    }
  };
  updateConnectionState = async (connectionId, messageCount, metadata) => {
    if (!isRedisAvailable()) {
      return false;
    }
    try {
      const key = `${REDIS_KEY_PREFIX}${connectionId}`;
      const exists = await redisClient.exists(key);
      if (!exists) {
        return await storeConnectionState(connectionId, messageCount, metadata);
      }
      const state = {
        connectionId,
        messageCount,
        lastActivity: Date.now(),
        metadata
      };
      await redisClient.setEx(key, REDIS_RECONNECT_TTL, JSON.stringify(state));
      return true;
    } catch (error23) {
      logError("Failed to update connection state in Redis", {
        connectionId,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return false;
    }
  };
  removeConnectionState = async (connectionId) => {
    if (!isRedisAvailable()) {
      return false;
    }
    try {
      const key = `${REDIS_KEY_PREFIX}${connectionId}`;
      const deleted = await redisClient.del(key);
      if (deleted > 0) {
        logInfo("Connection state removed from Redis", { connectionId });
      }
      return deleted > 0;
    } catch (error23) {
      logError("Failed to remove connection state from Redis", {
        connectionId,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return false;
    }
  };
  getConnectionStateTTL = async (connectionId) => {
    if (!isRedisAvailable()) {
      return -1;
    }
    try {
      const key = `${REDIS_KEY_PREFIX}${connectionId}`;
      const ttl = await redisClient.ttl(key);
      return ttl;
    } catch (error23) {
      logError("Failed to get connection state TTL", {
        connectionId,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return -1;
    }
  };
  getAllConnectionStates = async () => {
    if (!isRedisAvailable()) {
      return [];
    }
    try {
      const pattern2 = `${REDIS_KEY_PREFIX}*`;
      const keys = await redisClient.keys(pattern2);
      if (keys.length === 0) {
        return [];
      }
      const states = [];
      for (const key of keys) {
        try {
          const stateJson = await redisClient.get(key);
          if (stateJson) {
            const state = JSON.parse(stateJson);
            states.push(state);
          }
        } catch (parseError) {
          logWarn("Failed to parse connection state", { key, error: parseError });
        }
      }
      return states;
    } catch (error23) {
      logError("Failed to get all connection states", {
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return [];
    }
  };
  cleanupExpiredStates = async () => {
    if (!isRedisAvailable()) {
      return 0;
    }
    try {
      const pattern2 = `${REDIS_KEY_PREFIX}*`;
      const keys = await redisClient.keys(pattern2);
      let cleanedCount = 0;
      for (const key of keys) {
        const ttl = await redisClient.ttl(key);
        if (ttl === -2) {
          cleanedCount++;
        } else if (ttl === -1) {
          await redisClient.del(key);
          cleanedCount++;
        }
      }
      if (cleanedCount > 0) {
        logInfo("Cleaned up expired connection states", { count: cleanedCount });
      }
      return cleanedCount;
    } catch (error23) {
      logError("Failed to cleanup expired connection states", {
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
      return 0;
    }
  };
  closeRedis = async () => {
    if (redisClient) {
      try {
        await redisClient.quit();
        logInfo("Redis connection closed");
      } catch (error23) {
        logError("Error closing Redis connection", { error: error23 });
      } finally {
        redisClient = null;
      }
    }
  };
  redisHealthCheck = async () => {
    if (!isRedisAvailable()) {
      return { status: "unhealthy" };
    }
    try {
      const start = Date.now();
      await redisClient.ping();
      const latency = Date.now() - start;
      return { status: "healthy", latency };
    } catch (error23) {
      logError("Redis health check failed", { error: error23 });
      return { status: "unhealthy" };
    }
  };
});

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol;
    }
  },
  IsString: () => {
    {
      return IsString;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject;
    }
  },
  IsNumber: () => {
    {
      return IsNumber;
    }
  },
  IsNull: () => {
    {
      return IsNull;
    }
  },
  IsIterator: () => {
    {
      return IsIterator;
    }
  },
  IsFunction: () => {
    {
      return IsFunction;
    }
  },
  IsDate: () => {
    {
      return IsDate;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator;
    }
  },
  IsArray: () => {
    {
      return IsArray;
    }
  },
  HasPropertyKey: () => {
    {
      return HasPropertyKey;
    }
  }
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
};
var Visit = function(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value2) {
  return IsObject2(value2) && globalThis.Symbol.asyncIterator in value2;
}
function IsIterator2(value2) {
  return IsObject2(value2) && globalThis.Symbol.iterator in value2;
}
function IsStandardObject(value2) {
  return IsObject2(value2) && (globalThis.Object.getPrototypeOf(value2) === Object.prototype || globalThis.Object.getPrototypeOf(value2) === null);
}
function IsPromise(value2) {
  return value2 instanceof globalThis.Promise;
}
function IsDate2(value2) {
  return value2 instanceof Date && globalThis.Number.isFinite(value2.getTime());
}
function IsMap(value2) {
  return value2 instanceof globalThis.Map;
}
function IsSet(value2) {
  return value2 instanceof globalThis.Set;
}
function IsTypedArray(value2) {
  return globalThis.ArrayBuffer.isView(value2);
}
function IsUint8Array2(value2) {
  return value2 instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value2, key) {
  return key in value2;
}
function IsObject2(value2) {
  return value2 !== null && typeof value2 === "object";
}
function IsArray2(value2) {
  return globalThis.Array.isArray(value2) && !globalThis.ArrayBuffer.isView(value2);
}
function IsUndefined2(value2) {
  return value2 === undefined;
}
function IsNull2(value2) {
  return value2 === null;
}
function IsBoolean2(value2) {
  return typeof value2 === "boolean";
}
function IsNumber2(value2) {
  return typeof value2 === "number";
}
function IsInteger(value2) {
  return globalThis.Number.isInteger(value2);
}
function IsBigInt2(value2) {
  return typeof value2 === "bigint";
}
function IsString2(value2) {
  return typeof value2 === "string";
}
function IsFunction2(value2) {
  return typeof value2 === "function";
}
function IsSymbol2(value2) {
  return typeof value2 === "symbol";
}
function IsValueType(value2) {
  return IsBigInt2(value2) || IsBoolean2(value2) || IsNull2(value2) || IsNumber2(value2) || IsString2(value2) || IsSymbol2(value2) || IsUndefined2(value2);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value2, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value2 : value2[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    const isObject = IsObject2(value2);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value2);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return IsObjectLike(value2) && !(value2 instanceof Date) && !(value2 instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value2) : Number.isFinite(value2);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    const isUndefined = IsUndefined2(value2);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value2 === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
var ImmutableArray = function(value2) {
  return globalThis.Object.freeze(value2).map((value3) => Immutable(value3));
};
var ImmutableDate = function(value2) {
  return value2;
};
var ImmutableUint8Array = function(value2) {
  return value2;
};
var ImmutableRegExp = function(value2) {
  return value2;
};
var ImmutableObject = function(value2) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value2)) {
    result[key] = Immutable(value2[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value2)) {
    result[key] = Immutable(value2[key]);
  }
  return globalThis.Object.freeze(result);
};
function Immutable(value2) {
  return IsArray(value2) ? ImmutableArray(value2) : IsDate(value2) ? ImmutableDate(value2) : IsUint8Array(value2) ? ImmutableUint8Array(value2) : IsRegExp(value2) ? ImmutableRegExp(value2) : IsObject(value2) ? ImmutableObject(value2) : value2;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value3) {
  return IsObject(value3) && value3[ReadonlyKind] === "Readonly";
}
function IsOptional(value3) {
  return IsObject(value3) && value3[OptionalKind] === "Optional";
}
function IsAny(value3) {
  return IsKindOf(value3, "Any");
}
function IsArgument(value3) {
  return IsKindOf(value3, "Argument");
}
function IsArray3(value3) {
  return IsKindOf(value3, "Array");
}
function IsAsyncIterator3(value3) {
  return IsKindOf(value3, "AsyncIterator");
}
function IsBigInt3(value3) {
  return IsKindOf(value3, "BigInt");
}
function IsBoolean3(value3) {
  return IsKindOf(value3, "Boolean");
}
function IsComputed(value3) {
  return IsKindOf(value3, "Computed");
}
function IsConstructor(value3) {
  return IsKindOf(value3, "Constructor");
}
function IsDate3(value3) {
  return IsKindOf(value3, "Date");
}
function IsFunction3(value3) {
  return IsKindOf(value3, "Function");
}
function IsInteger2(value3) {
  return IsKindOf(value3, "Integer");
}
function IsIntersect(value3) {
  return IsKindOf(value3, "Intersect");
}
function IsIterator3(value3) {
  return IsKindOf(value3, "Iterator");
}
function IsKindOf(value3, kind) {
  return IsObject(value3) && Kind in value3 && value3[Kind] === kind;
}
function IsLiteralValue(value3) {
  return IsBoolean(value3) || IsNumber(value3) || IsString(value3);
}
function IsLiteral(value3) {
  return IsKindOf(value3, "Literal");
}
function IsMappedKey(value3) {
  return IsKindOf(value3, "MappedKey");
}
function IsMappedResult(value3) {
  return IsKindOf(value3, "MappedResult");
}
function IsNever(value3) {
  return IsKindOf(value3, "Never");
}
function IsNot(value3) {
  return IsKindOf(value3, "Not");
}
function IsNull3(value3) {
  return IsKindOf(value3, "Null");
}
function IsNumber3(value3) {
  return IsKindOf(value3, "Number");
}
function IsObject3(value3) {
  return IsKindOf(value3, "Object");
}
function IsPromise2(value3) {
  return IsKindOf(value3, "Promise");
}
function IsRecord(value3) {
  return IsKindOf(value3, "Record");
}
function IsRef(value3) {
  return IsKindOf(value3, "Ref");
}
function IsRegExp2(value3) {
  return IsKindOf(value3, "RegExp");
}
function IsString3(value3) {
  return IsKindOf(value3, "String");
}
function IsSymbol3(value3) {
  return IsKindOf(value3, "Symbol");
}
function IsTemplateLiteral(value3) {
  return IsKindOf(value3, "TemplateLiteral");
}
function IsThis(value3) {
  return IsKindOf(value3, "This");
}
function IsTransform(value3) {
  return IsObject(value3) && TransformKind in value3;
}
function IsTuple(value3) {
  return IsKindOf(value3, "Tuple");
}
function IsUndefined3(value3) {
  return IsKindOf(value3, "Undefined");
}
function IsUnion(value3) {
  return IsKindOf(value3, "Union");
}
function IsUint8Array3(value3) {
  return IsKindOf(value3, "Uint8Array");
}
function IsUnknown(value3) {
  return IsKindOf(value3, "Unknown");
}
function IsUnsafe(value3) {
  return IsKindOf(value3, "Unsafe");
}
function IsVoid(value3) {
  return IsKindOf(value3, "Void");
}
function IsKind(value3) {
  return IsObject(value3) && Kind in value3 && IsString(value3[Kind]);
}
function IsSchema(value3) {
  return IsAny(value3) || IsArgument(value3) || IsArray3(value3) || IsBoolean3(value3) || IsBigInt3(value3) || IsAsyncIterator3(value3) || IsComputed(value3) || IsConstructor(value3) || IsDate3(value3) || IsFunction3(value3) || IsInteger2(value3) || IsIntersect(value3) || IsIterator3(value3) || IsLiteral(value3) || IsMappedKey(value3) || IsMappedResult(value3) || IsNever(value3) || IsNot(value3) || IsNull3(value3) || IsNumber3(value3) || IsObject3(value3) || IsPromise2(value3) || IsRecord(value3) || IsRef(value3) || IsRegExp2(value3) || IsString3(value3) || IsSymbol3(value3) || IsTemplateLiteral(value3) || IsThis(value3) || IsTuple(value3) || IsUndefined3(value3) || IsUnion(value3) || IsUint8Array3(value3) || IsUnknown(value3) || IsUnsafe(value3) || IsVoid(value3) || IsKind(value3);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid2;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe2;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown2;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion2;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined4;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array4;
    }
  },
  IsTuple: () => {
    {
      return IsTuple2;
    }
  },
  IsTransform: () => {
    {
      return IsTransform2;
    }
  },
  IsThis: () => {
    {
      return IsThis2;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol4;
    }
  },
  IsString: () => {
    {
      return IsString4;
    }
  },
  IsSchema: () => {
    {
      return IsSchema2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp3;
    }
  },
  IsRef: () => {
    {
      return IsRef2;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord2;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly2;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise3;
    }
  },
  IsOptional: () => {
    {
      return IsOptional2;
    }
  },
  IsObject: () => {
    {
      return IsObject4;
    }
  },
  IsNumber: () => {
    {
      return IsNumber4;
    }
  },
  IsNull: () => {
    {
      return IsNull4;
    }
  },
  IsNot: () => {
    {
      return IsNot2;
    }
  },
  IsNever: () => {
    {
      return IsNever2;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult2;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey2;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue2;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral2;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf2;
    }
  },
  IsKind: () => {
    {
      return IsKind2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator4;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect2;
    }
  },
  IsInteger: () => {
    {
      return IsInteger3;
    }
  },
  IsImport: () => {
    {
      return IsImport;
    }
  },
  IsFunction: () => {
    {
      return IsFunction4;
    }
  },
  IsDate: () => {
    {
      return IsDate4;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor2;
    }
  },
  IsComputed: () => {
    {
      return IsComputed2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean4;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt4;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator4;
    }
  },
  IsArray: () => {
    {
      return IsArray4;
    }
  },
  IsArgument: () => {
    {
      return IsArgument2;
    }
  },
  IsAny: () => {
    {
      return IsAny2;
    }
  }
});
var IsPattern = function(value3) {
  try {
    new RegExp(value3);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value3) {
  if (!IsString(value3))
    return false;
  for (let i = 0;i < value3.length; i++) {
    const code = value3.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value3) {
  return IsOptionalBoolean(value3) || IsSchema2(value3);
};
var IsOptionalBigInt = function(value3) {
  return IsUndefined(value3) || IsBigInt(value3);
};
var IsOptionalNumber = function(value3) {
  return IsUndefined(value3) || IsNumber(value3);
};
var IsOptionalBoolean = function(value3) {
  return IsUndefined(value3) || IsBoolean(value3);
};
var IsOptionalString = function(value3) {
  return IsUndefined(value3) || IsString(value3);
};
var IsOptionalPattern = function(value3) {
  return IsUndefined(value3) || IsString(value3) && IsControlCharacterFree(value3) && IsPattern(value3);
};
var IsOptionalFormat = function(value3) {
  return IsUndefined(value3) || IsString(value3) && IsControlCharacterFree(value3);
};
var IsOptionalSchema = function(value3) {
  return IsUndefined(value3) || IsSchema2(value3);
};
function IsReadonly2(value3) {
  return IsObject(value3) && value3[ReadonlyKind] === "Readonly";
}
function IsOptional2(value3) {
  return IsObject(value3) && value3[OptionalKind] === "Optional";
}
function IsAny2(value3) {
  return IsKindOf2(value3, "Any") && IsOptionalString(value3.$id);
}
function IsArgument2(value3) {
  return IsKindOf2(value3, "Argument") && IsNumber(value3.index);
}
function IsArray4(value3) {
  return IsKindOf2(value3, "Array") && value3.type === "array" && IsOptionalString(value3.$id) && IsSchema2(value3.items) && IsOptionalNumber(value3.minItems) && IsOptionalNumber(value3.maxItems) && IsOptionalBoolean(value3.uniqueItems) && IsOptionalSchema(value3.contains) && IsOptionalNumber(value3.minContains) && IsOptionalNumber(value3.maxContains);
}
function IsAsyncIterator4(value3) {
  return IsKindOf2(value3, "AsyncIterator") && value3.type === "AsyncIterator" && IsOptionalString(value3.$id) && IsSchema2(value3.items);
}
function IsBigInt4(value3) {
  return IsKindOf2(value3, "BigInt") && value3.type === "bigint" && IsOptionalString(value3.$id) && IsOptionalBigInt(value3.exclusiveMaximum) && IsOptionalBigInt(value3.exclusiveMinimum) && IsOptionalBigInt(value3.maximum) && IsOptionalBigInt(value3.minimum) && IsOptionalBigInt(value3.multipleOf);
}
function IsBoolean4(value3) {
  return IsKindOf2(value3, "Boolean") && value3.type === "boolean" && IsOptionalString(value3.$id);
}
function IsComputed2(value3) {
  return IsKindOf2(value3, "Computed") && IsString(value3.target) && IsArray(value3.parameters) && value3.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value3) {
  return IsKindOf2(value3, "Constructor") && value3.type === "Constructor" && IsOptionalString(value3.$id) && IsArray(value3.parameters) && value3.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value3.returns);
}
function IsDate4(value3) {
  return IsKindOf2(value3, "Date") && value3.type === "Date" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.exclusiveMaximumTimestamp) && IsOptionalNumber(value3.exclusiveMinimumTimestamp) && IsOptionalNumber(value3.maximumTimestamp) && IsOptionalNumber(value3.minimumTimestamp) && IsOptionalNumber(value3.multipleOfTimestamp);
}
function IsFunction4(value3) {
  return IsKindOf2(value3, "Function") && value3.type === "Function" && IsOptionalString(value3.$id) && IsArray(value3.parameters) && value3.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value3.returns);
}
function IsImport(value3) {
  return IsKindOf2(value3, "Import") && HasPropertyKey(value3, "$defs") && IsObject(value3.$defs) && IsProperties(value3.$defs) && HasPropertyKey(value3, "$ref") && IsString(value3.$ref) && value3.$ref in value3.$defs;
}
function IsInteger3(value3) {
  return IsKindOf2(value3, "Integer") && value3.type === "integer" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.exclusiveMaximum) && IsOptionalNumber(value3.exclusiveMinimum) && IsOptionalNumber(value3.maximum) && IsOptionalNumber(value3.minimum) && IsOptionalNumber(value3.multipleOf);
}
function IsProperties(value3) {
  return IsObject(value3) && Object.entries(value3).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value3) {
  return IsKindOf2(value3, "Intersect") && (IsString(value3.type) && value3.type !== "object" ? false : true) && IsArray(value3.allOf) && value3.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value3.type) && (IsOptionalBoolean(value3.unevaluatedProperties) || IsOptionalSchema(value3.unevaluatedProperties)) && IsOptionalString(value3.$id);
}
function IsIterator4(value3) {
  return IsKindOf2(value3, "Iterator") && value3.type === "Iterator" && IsOptionalString(value3.$id) && IsSchema2(value3.items);
}
function IsKindOf2(value3, kind) {
  return IsObject(value3) && Kind in value3 && value3[Kind] === kind;
}
function IsLiteralString(value3) {
  return IsLiteral2(value3) && IsString(value3.const);
}
function IsLiteralNumber(value3) {
  return IsLiteral2(value3) && IsNumber(value3.const);
}
function IsLiteralBoolean(value3) {
  return IsLiteral2(value3) && IsBoolean(value3.const);
}
function IsLiteral2(value3) {
  return IsKindOf2(value3, "Literal") && IsOptionalString(value3.$id) && IsLiteralValue2(value3.const);
}
function IsLiteralValue2(value3) {
  return IsBoolean(value3) || IsNumber(value3) || IsString(value3);
}
function IsMappedKey2(value3) {
  return IsKindOf2(value3, "MappedKey") && IsArray(value3.keys) && value3.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value3) {
  return IsKindOf2(value3, "MappedResult") && IsProperties(value3.properties);
}
function IsNever2(value3) {
  return IsKindOf2(value3, "Never") && IsObject(value3.not) && Object.getOwnPropertyNames(value3.not).length === 0;
}
function IsNot2(value3) {
  return IsKindOf2(value3, "Not") && IsSchema2(value3.not);
}
function IsNull4(value3) {
  return IsKindOf2(value3, "Null") && value3.type === "null" && IsOptionalString(value3.$id);
}
function IsNumber4(value3) {
  return IsKindOf2(value3, "Number") && value3.type === "number" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.exclusiveMaximum) && IsOptionalNumber(value3.exclusiveMinimum) && IsOptionalNumber(value3.maximum) && IsOptionalNumber(value3.minimum) && IsOptionalNumber(value3.multipleOf);
}
function IsObject4(value3) {
  return IsKindOf2(value3, "Object") && value3.type === "object" && IsOptionalString(value3.$id) && IsProperties(value3.properties) && IsAdditionalProperties(value3.additionalProperties) && IsOptionalNumber(value3.minProperties) && IsOptionalNumber(value3.maxProperties);
}
function IsPromise3(value3) {
  return IsKindOf2(value3, "Promise") && value3.type === "Promise" && IsOptionalString(value3.$id) && IsSchema2(value3.item);
}
function IsRecord2(value3) {
  return IsKindOf2(value3, "Record") && value3.type === "object" && IsOptionalString(value3.$id) && IsAdditionalProperties(value3.additionalProperties) && IsObject(value3.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value3);
}
function IsRecursive(value3) {
  return IsObject(value3) && Hint in value3 && value3[Hint] === "Recursive";
}
function IsRef2(value3) {
  return IsKindOf2(value3, "Ref") && IsOptionalString(value3.$id) && IsString(value3.$ref);
}
function IsRegExp3(value3) {
  return IsKindOf2(value3, "RegExp") && IsOptionalString(value3.$id) && IsString(value3.source) && IsString(value3.flags) && IsOptionalNumber(value3.maxLength) && IsOptionalNumber(value3.minLength);
}
function IsString4(value3) {
  return IsKindOf2(value3, "String") && value3.type === "string" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.minLength) && IsOptionalNumber(value3.maxLength) && IsOptionalPattern(value3.pattern) && IsOptionalFormat(value3.format);
}
function IsSymbol4(value3) {
  return IsKindOf2(value3, "Symbol") && value3.type === "symbol" && IsOptionalString(value3.$id);
}
function IsTemplateLiteral2(value3) {
  return IsKindOf2(value3, "TemplateLiteral") && value3.type === "string" && IsString(value3.pattern) && value3.pattern[0] === "^" && value3.pattern[value3.pattern.length - 1] === "$";
}
function IsThis2(value3) {
  return IsKindOf2(value3, "This") && IsOptionalString(value3.$id) && IsString(value3.$ref);
}
function IsTransform2(value3) {
  return IsObject(value3) && TransformKind in value3;
}
function IsTuple2(value3) {
  return IsKindOf2(value3, "Tuple") && value3.type === "array" && IsOptionalString(value3.$id) && IsNumber(value3.minItems) && IsNumber(value3.maxItems) && value3.minItems === value3.maxItems && (IsUndefined(value3.items) && IsUndefined(value3.additionalItems) && value3.minItems === 0 || IsArray(value3.items) && value3.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value3) {
  return IsKindOf2(value3, "Undefined") && value3.type === "undefined" && IsOptionalString(value3.$id);
}
function IsUnionLiteral(value3) {
  return IsUnion2(value3) && value3.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value3) {
  return IsKindOf2(value3, "Union") && IsOptionalString(value3.$id) && IsObject(value3) && IsArray(value3.anyOf) && value3.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value3) {
  return IsKindOf2(value3, "Uint8Array") && value3.type === "Uint8Array" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.minByteLength) && IsOptionalNumber(value3.maxByteLength);
}
function IsUnknown2(value3) {
  return IsKindOf2(value3, "Unknown") && IsOptionalString(value3.$id);
}
function IsUnsafe2(value3) {
  return IsKindOf2(value3, "Unsafe");
}
function IsVoid2(value3) {
  return IsKindOf2(value3, "Void") && value3.type === "void" && IsOptionalString(value3.$id);
}
function IsKind2(value3) {
  return IsObject(value3) && Kind in value3 && IsString(value3[Kind]) && !KnownTypes.includes(value3[Kind]);
}
function IsSchema2(value3) {
  return IsObject(value3) && (IsAny2(value3) || IsArgument2(value3) || IsArray4(value3) || IsBoolean4(value3) || IsBigInt4(value3) || IsAsyncIterator4(value3) || IsComputed2(value3) || IsConstructor2(value3) || IsDate4(value3) || IsFunction4(value3) || IsInteger3(value3) || IsIntersect2(value3) || IsIterator4(value3) || IsLiteral2(value3) || IsMappedKey2(value3) || IsMappedResult2(value3) || IsNever2(value3) || IsNot2(value3) || IsNull4(value3) || IsNumber4(value3) || IsObject4(value3) || IsPromise3(value3) || IsRecord2(value3) || IsRef2(value3) || IsRegExp3(value3) || IsString4(value3) || IsSymbol4(value3) || IsTemplateLiteral2(value3) || IsThis2(value3) || IsTuple2(value3) || IsUndefined4(value3) || IsUnion2(value3) || IsUint8Array4(value3) || IsUnknown2(value3) || IsUnsafe2(value3) || IsVoid2(value3) || IsKind2(value3));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
var PatternNeverExact = `^${PatternNever}\$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
var DiscardKey = function(value3, key) {
  const { [key]: _, ...rest } = value3;
  return rest;
};
function Discard(value3, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value3);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
var IsUnionOptional = function(types) {
  return types.some((type10) => IsOptional(type10));
};
var RemoveOptionalFromRest = function(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
};
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
var Unescape = function(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value3, index) {
    if (!IsOpenParen(value3, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value3.length; scan++) {
      if (IsOpenParen(value3, scan))
        count += 1;
      if (IsCloseParen(value3, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value3, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value3,
    type: typeof value3
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
var Escape = function(value3) {
  return value3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern2 = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
};
var FromUnion2 = function(types) {
  const result = [];
  for (const type15 of types)
    result.push(...IndexPropertyKeys(type15));
  return result;
};
var FromLiteral = function(literalValue) {
  return [literalValue.toString()];
};
function IndexPropertyKeys(type15) {
  return [...new Set(IsTemplateLiteral(type15) ? FromTemplateLiteral(type15) : IsUnion(type15) ? FromUnion2(type15.anyOf) : IsLiteral(type15) ? FromLiteral(type15.const) : IsNumber3(type15) ? ["[number]"] : IsInteger2(type15) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
var FromProperties = function(type15, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type15, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
};
var FromMappedResult = function(type15, mappedResult, options) {
  return FromProperties(type15, mappedResult.properties, options);
};
function IndexFromMappedResult(type15, mappedResult, options) {
  const properties = FromMappedResult(type15, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
var FromRest = function(types, key) {
  return types.map((type16) => IndexFromPropertyKey(type16, key));
};
var FromIntersectRest = function(types) {
  return types.filter((type16) => !IsNever(type16));
};
var FromIntersect = function(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
};
var FromUnionRest = function(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
};
var FromUnion3 = function(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
};
var FromTuple = function(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
};
var FromArray = function(type16, key) {
  return key === "[number]" ? type16 : Never();
};
var FromProperty = function(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
};
function IndexFromPropertyKey(type16, propertyKey) {
  return IsIntersect(type16) ? FromIntersect(type16.allOf, propertyKey) : IsUnion(type16) ? FromUnion3(type16.anyOf, propertyKey) : IsTuple(type16) ? FromTuple(type16.items ?? [], propertyKey) : IsArray3(type16) ? FromArray(type16.items, propertyKey) : IsObject3(type16) ? FromProperty(type16.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type16, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type16, propertyKey));
}
var FromSchema = function(type16, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type16, propertyKeys));
};
function Index(type16, key, options) {
  if (IsRef(type16) || IsRef(key)) {
    const error7 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type16) || !IsSchema(key))
      throw new TypeBoxError(error7);
    return Computed("Index", [type16, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type16, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type16, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type16, IndexPropertyKeys(key)) : FromSchema(type16, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(type16, key, options) {
  return { [key]: Index(type16, [key], Clone(options)) };
};
var MappedIndexPropertyKeys = function(type16, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type16, left, options) };
  }, {});
};
var MappedIndexProperties = function(type16, mappedKey, options) {
  return MappedIndexPropertyKeys(type16, mappedKey.keys, options);
};
function IndexFromMappedKey(type16, mappedKey, options) {
  const properties = MappedIndexProperties(type16, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
var RequiredKeys = function(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
};
var _Object = function(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
};
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
};
var AddReadonly = function(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
var FromProperties2 = function(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
};
var FromMappedResult2 = function(R, F) {
  return FromProperties2(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
var FromMappedResult3 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties3 = function(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
};
var FromSchemaType = function(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
};
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
};
var AddOptional = function(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
var FromProperties4 = function(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
};
var FromMappedResult4 = function(R, F) {
  return FromProperties4(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(types) {
  return types.every((left) => IsOptional(left));
};
var RemoveOptionalFromType2 = function(type24) {
  return Discard(type24, [OptionalKind]);
};
var RemoveOptionalFromRest2 = function(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
};
var ResolveIntersect = function(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
};
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
var FromComputed = function(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
};
var FromRef = function($ref) {
  return Computed("Awaited", [Ref($ref)]);
};
var FromIntersect2 = function(types) {
  return Intersect(FromRest3(types));
};
var FromUnion4 = function(types) {
  return Union(FromRest3(types));
};
var FromPromise = function(type27) {
  return Awaited(type27);
};
var FromRest3 = function(types) {
  return types.map((type27) => Awaited(type27));
};
function Awaited(type27, options) {
  return CreateType(IsComputed(type27) ? FromComputed(type27.target, type27.parameters) : IsIntersect(type27) ? FromIntersect2(type27.allOf) : IsUnion(type27) ? FromUnion4(type27.anyOf) : IsPromise2(type27) ? FromPromise(type27.item) : IsRef(type27) ? FromRef(type27.$ref) : type27, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
var FromRest4 = function(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
};
var FromIntersect3 = function(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
};
var FromUnion5 = function(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
};
var FromTuple2 = function(types) {
  return types.map((_, indexer) => indexer.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(type27) {
  return IsIntersect(type27) ? FromIntersect3(type27.allOf) : IsUnion(type27) ? FromUnion5(type27.anyOf) : IsTuple(type27) ? FromTuple2(type27.items ?? []) : IsArray3(type27) ? FromArray2(type27.items) : IsObject3(type27) ? FromProperties5(type27.properties) : IsRecord(type27) ? FromPatternProperties(type27.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
var FromComputed2 = function(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
};
var FromRef2 = function($ref) {
  return Computed("KeyOf", [Ref($ref)]);
};
var KeyOfFromType = function(type28, options) {
  const propertyKeys = KeyOfPropertyKeys(type28);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
};
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type28, options) {
  return IsComputed(type28) ? FromComputed2(type28.target, type28.parameters) : IsRef(type28) ? FromRef2(type28.$ref) : IsMappedResult(type28) ? KeyOfFromMappedResult(type28, options) : KeyOfFromType(type28, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
};
var FromMappedResult5 = function(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
};
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
var CompositeKeys = function(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
};
var CompositeProperties = function(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
};
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
var FromArray3 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties7 = function(value7) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value7))
    Acc[K] = Readonly(FromValue(value7[K], false));
  return Acc;
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value7, root) {
  return IsAsyncIterator(value7) ? ConditionalReadonly(Any(), root) : IsIterator(value7) ? ConditionalReadonly(Any(), root) : IsArray(value7) ? Readonly(Tuple(FromArray3(value7))) : IsUint8Array(value7) ? Uint8Array2() : IsDate(value7) ? Date2() : IsObject(value7) ? ConditionalReadonly(Object2(FromProperties7(value7)), root) : IsFunction(value7) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value7) ? Undefined() : IsNull(value7) ? Null() : IsSymbol(value7) ? Symbol2() : IsBigInt(value7) ? BigInt2() : IsNumber(value7) ? Literal(value7) : IsBoolean(value7) ? Literal(value7) : IsString(value7) ? Literal(value7) : Object2({});
};
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value8) => Literal(value8));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type.IsNever(right) || exports_type.IsIntersect(right) || exports_type.IsUnion(right) || exports_type.IsUnknown(right) || exports_type.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny = function(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) && right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right) ? ExtendsResult.Union : exports_type.IsUnknown(right) ? ExtendsResult.True : exports_type.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
};
var FromAsyncIterator = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
};
var FromBigInt = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
};
var FromDate = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger = function(left, right) {
  return exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
};
var FromLiteral2 = function(left, right) {
  return exports_type.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot = function(left, right) {
  return exports_type.IsNot(left) ? Visit3(UnwrapTNot(left), right) : exports_type.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type.IsLiteralNumber(left) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left) && !exports_type.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) || exports_type.IsLiteralString(left) && IsObjectStringLike(right) || exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type.IsString(left) && IsObjectStringLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsNumber(left) && IsObjectNumberLike(right) || exports_type.IsInteger(left) && IsObjectNumberLike(right) || exports_type.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type.IsDate(left) && IsObjectDateLike(right) || exports_type.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : !exports_type.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type.IsLiteralString(left) && exports_type.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsString(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsArray(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
};
var FromRegExp = function(left, right) {
  const L = exports_type.IsRegExp(left) ? String2() : left;
  const R = exports_type.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral2 = function(left, right) {
  return exports_type.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : exports_type.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type.IsNever(left) ? ExtendsResult.True : exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple3 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsVoid(right) ? FromVoidRight(left, right) : exports_type.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown = function(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type.IsArray(right) ? FromArrayRight(left, right) : exports_type.IsTuple(right) ? FromTupleRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type.IsUndefined(left) ? ExtendsResult.True : exports_type.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid = function(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit3 = function(left, right) {
  return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : exports_type.IsRegExp(left) || exports_type.IsRegExp(right) ? FromRegExp(left, right) : exports_type.IsNot(left) || exports_type.IsNot(right) ? FromNot(left, right) : exports_type.IsAny(left) ? FromAny(left, right) : exports_type.IsArray(left) ? FromArray4(left, right) : exports_type.IsBigInt(left) ? FromBigInt(left, right) : exports_type.IsBoolean(left) ? FromBoolean(left, right) : exports_type.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : exports_type.IsConstructor(left) ? FromConstructor(left, right) : exports_type.IsDate(left) ? FromDate(left, right) : exports_type.IsFunction(left) ? FromFunction(left, right) : exports_type.IsInteger(left) ? FromInteger(left, right) : exports_type.IsIntersect(left) ? FromIntersect4(left, right) : exports_type.IsIterator(left) ? FromIterator(left, right) : exports_type.IsLiteral(left) ? FromLiteral2(left, right) : exports_type.IsNever(left) ? FromNever(left, right) : exports_type.IsNull(left) ? FromNull(left, right) : exports_type.IsNumber(left) ? FromNumber(left, right) : exports_type.IsObject(left) ? FromObject(left, right) : exports_type.IsRecord(left) ? FromRecord(left, right) : exports_type.IsString(left) ? FromString(left, right) : exports_type.IsSymbol(left) ? FromSymbol(left, right) : exports_type.IsTuple(left) ? FromTuple3(left, right) : exports_type.IsPromise(left) ? FromPromise2(left, right) : exports_type.IsUint8Array(left) ? FromUint8Array(left, right) : exports_type.IsUndefined(left) ? FromUndefined(left, right) : exports_type.IsUnion(left) ? FromUnion6(left, right) : exports_type.IsUnknown(left) ? FromUnknown(left, right) : exports_type.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
var FromProperties8 = function(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
var FromProperties9 = function(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
};
var FromMappedResult7 = function(R, T) {
  return FromProperties9(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
var FromProperties10 = function(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
};
var FromMappedResult8 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
var RecordCreateFromPattern = function(pattern2, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern2]: T } }, options);
};
var RecordCreateFromKeys = function(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(key, type39, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type39, options);
};
var FromLiteralKey = function(key, type39, options) {
  return RecordCreateFromKeys([key.toString()], type39, options);
};
var FromRegExpKey = function(key, type39, options) {
  return RecordCreateFromPattern(key.source, type39, options);
};
var FromStringKey = function(key, type39, options) {
  const pattern2 = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern2, type39, options);
};
var FromAnyKey = function(_, type39, options) {
  return RecordCreateFromPattern(PatternStringExact, type39, options);
};
var FromNeverKey = function(_key, type39, options) {
  return RecordCreateFromPattern(PatternNeverExact, type39, options);
};
var FromBooleanKey = function(_key, type39, options) {
  return Object2({ true: type39, false: type39 }, options);
};
var FromIntegerKey = function(_key, type39, options) {
  return RecordCreateFromPattern(PatternNumberExact, type39, options);
};
var FromNumberKey = function(_, type39, options) {
  return RecordCreateFromPattern(PatternNumberExact, type39, options);
};
function Record(key, type39, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type39, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type39, options) : IsLiteral(key) ? FromLiteralKey(key.const, type39, options) : IsBoolean3(key) ? FromBooleanKey(key, type39, options) : IsInteger2(key) ? FromIntegerKey(key, type39, options) : IsNumber3(key) ? FromNumberKey(key, type39, options) : IsRegExp2(key) ? FromRegExpKey(key, type39, options) : IsString3(key) ? FromStringKey(key, type39, options) : IsAny(key) ? FromAnyKey(key, type39, options) : IsNever(key) ? FromNeverKey(key, type39, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type39) {
  const pattern2 = RecordPattern(type39);
  return pattern2 === PatternStringExact ? String2() : pattern2 === PatternNumberExact ? Number2() : String2({ pattern: pattern2 });
}
function RecordValue2(type39) {
  return type39.patternProperties[RecordPattern(type39)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
var FromConstructor2 = function(args, type40) {
  type40.parameters = FromTypes(args, type40.parameters);
  type40.returns = FromType(args, type40.returns);
  return type40;
};
var FromFunction2 = function(args, type40) {
  type40.parameters = FromTypes(args, type40.parameters);
  type40.returns = FromType(args, type40.returns);
  return type40;
};
var FromIntersect5 = function(args, type40) {
  type40.allOf = FromTypes(args, type40.allOf);
  return type40;
};
var FromUnion7 = function(args, type40) {
  type40.anyOf = FromTypes(args, type40.anyOf);
  return type40;
};
var FromTuple4 = function(args, type40) {
  if (IsUndefined(type40.items))
    return type40;
  type40.items = FromTypes(args, type40.items);
  return type40;
};
var FromArray5 = function(args, type40) {
  type40.items = FromType(args, type40.items);
  return type40;
};
var FromAsyncIterator2 = function(args, type40) {
  type40.items = FromType(args, type40.items);
  return type40;
};
var FromIterator2 = function(args, type40) {
  type40.items = FromType(args, type40.items);
  return type40;
};
var FromPromise3 = function(args, type40) {
  type40.item = FromType(args, type40.item);
  return type40;
};
var FromObject2 = function(args, type40) {
  const mappedProperties = FromProperties11(args, type40.properties);
  return { ...type40, ...Object2(mappedProperties) };
};
var FromRecord2 = function(args, type40) {
  const mappedKey = FromType(args, RecordKey2(type40));
  const mappedValue = FromType(args, RecordValue2(type40));
  const result = Record(mappedKey, mappedValue);
  return { ...type40, ...result };
};
var FromArgument = function(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
};
var FromProperty2 = function(args, type40) {
  const isReadonly = IsReadonly(type40);
  const isOptional = IsOptional(type40);
  const mapped10 = FromType(args, type40);
  return isReadonly && isOptional ? ReadonlyOptional(mapped10) : isReadonly && !isOptional ? Readonly(mapped10) : !isReadonly && isOptional ? Optional(mapped10) : mapped10;
};
var FromProperties11 = function(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
};
function FromTypes(args, types) {
  return types.map((type40) => FromType(args, type40));
}
var FromType = function(args, type40) {
  return IsConstructor(type40) ? FromConstructor2(args, type40) : IsFunction3(type40) ? FromFunction2(args, type40) : IsIntersect(type40) ? FromIntersect5(args, type40) : IsUnion(type40) ? FromUnion7(args, type40) : IsTuple(type40) ? FromTuple4(args, type40) : IsArray3(type40) ? FromArray5(args, type40) : IsAsyncIterator3(type40) ? FromAsyncIterator2(args, type40) : IsIterator3(type40) ? FromIterator2(args, type40) : IsPromise2(type40) ? FromPromise3(args, type40) : IsObject3(type40) ? FromObject2(args, type40) : IsRecord(type40) ? FromRecord2(args, type40) : IsArgument(type40) ? FromArgument(args, type40) : type40;
};
function Instantiate(type40, args) {
  return FromType(args, CloneType(type40));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value12) {
  const [first, rest] = [value12.slice(0, 1), value12.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value12) {
  const [first, rest] = [value12.slice(0, 1), value12.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value12) {
  return value12.toUpperCase();
};
var ApplyLowercase = function(value12) {
  return value12.toLowerCase();
};
var FromTemplateLiteral3 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value12) => Literal(value12));
  const mapped11 = FromRest5(literals, mode);
  const union13 = Union(mapped11);
  return TemplateLiteral([union13], options);
};
var FromLiteralValue = function(value12, mode) {
  return typeof value12 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value12) : mode === "Capitalize" ? ApplyCapitalize(value12) : mode === "Uppercase" ? ApplyUppercase(value12) : mode === "Lowercase" ? ApplyLowercase(value12) : value12 : value12.toString();
};
var FromRest5 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
};
var FromMappedResult9 = function(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
};
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
var FromIntersect6 = function(types, propertyKeys) {
  return types.map((type43) => OmitResolve(type43, propertyKeys));
};
var FromUnion8 = function(types, propertyKeys) {
  return types.map((type43) => OmitResolve(type43, propertyKeys));
};
var FromProperty3 = function(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
};
var FromProperties13 = function(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
};
var FromObject3 = function(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
};
var UnionFromPropertyKeys = function(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
};
var OmitResolve = function(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
};
function Omit(type43, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type43);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type43) ? OmitFromMappedResult(type43, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type43, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type43, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type43, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type43, typeKey], options) : CreateType({ ...OmitResolve(type43, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(type43, key, options) {
  return { [key]: Omit(type43, [key], Clone(options)) };
};
var FromPropertyKeys2 = function(type43, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type43, LK, options) };
  }, {});
};
var FromMappedKey3 = function(type43, mappedKey, options) {
  return FromPropertyKeys2(type43, mappedKey.keys, options);
};
function OmitFromMappedKey(type43, mappedKey, options) {
  const properties = FromMappedKey3(type43, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
var FromProperties14 = function(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
};
var FromMappedResult10 = function(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
};
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
var FromIntersect7 = function(types, propertyKeys) {
  return types.map((type44) => PickResolve(type44, propertyKeys));
};
var FromUnion9 = function(types, propertyKeys) {
  return types.map((type44) => PickResolve(type44, propertyKeys));
};
var FromProperties15 = function(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
};
var FromObject4 = function(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
};
var UnionFromPropertyKeys2 = function(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
};
var PickResolve = function(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
};
function Pick(type44, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type44);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type44) ? PickFromMappedResult(type44, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type44, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type44, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type44, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type44, typeKey], options) : CreateType({ ...PickResolve(type44, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(type44, key, options) {
  return {
    [key]: Pick(type44, [key], Clone(options))
  };
};
var FromPropertyKeys3 = function(type44, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type44, leftKey, options) };
  }, {});
};
var FromMappedKey4 = function(type44, mappedKey, options) {
  return FromPropertyKeys3(type44, mappedKey.keys, options);
};
function PickFromMappedKey(type44, mappedKey, options) {
  const properties = FromMappedKey4(type44, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
var FromComputed3 = function(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
};
var FromRef3 = function($ref) {
  return Computed("Partial", [Ref($ref)]);
};
var FromProperties16 = function(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
};
var FromObject5 = function(type45) {
  const options = Discard(type45, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type45["properties"]);
  return Object2(properties, options);
};
var FromRest6 = function(types) {
  return types.map((type45) => PartialResolve(type45));
};
var PartialResolve = function(type45) {
  return IsComputed(type45) ? FromComputed3(type45.target, type45.parameters) : IsRef(type45) ? FromRef3(type45.$ref) : IsIntersect(type45) ? Intersect(FromRest6(type45.allOf)) : IsUnion(type45) ? Union(FromRest6(type45.anyOf)) : IsObject3(type45) ? FromObject5(type45) : IsBigInt3(type45) ? type45 : IsBoolean3(type45) ? type45 : IsInteger2(type45) ? type45 : IsLiteral(type45) ? type45 : IsNull3(type45) ? type45 : IsNumber3(type45) ? type45 : IsString3(type45) ? type45 : IsSymbol3(type45) ? type45 : IsUndefined3(type45) ? type45 : Object2({});
};
function Partial(type45, options) {
  if (IsMappedResult(type45)) {
    return PartialFromMappedResult(type45, options);
  } else {
    return CreateType({ ...PartialResolve(type45), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
var FromProperties17 = function(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
};
var FromMappedResult11 = function(R, options) {
  return FromProperties17(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
var FromComputed4 = function(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
};
var FromRef4 = function($ref) {
  return Computed("Required", [Ref($ref)]);
};
var FromProperties18 = function(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
};
var FromObject6 = function(type46) {
  const options = Discard(type46, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type46["properties"]);
  return Object2(properties, options);
};
var FromRest7 = function(types) {
  return types.map((type46) => RequiredResolve(type46));
};
var RequiredResolve = function(type46) {
  return IsComputed(type46) ? FromComputed4(type46.target, type46.parameters) : IsRef(type46) ? FromRef4(type46.$ref) : IsIntersect(type46) ? Intersect(FromRest7(type46.allOf)) : IsUnion(type46) ? Union(FromRest7(type46.anyOf)) : IsObject3(type46) ? FromObject6(type46) : IsBigInt3(type46) ? type46 : IsBoolean3(type46) ? type46 : IsInteger2(type46) ? type46 : IsLiteral(type46) ? type46 : IsNull3(type46) ? type46 : IsNumber3(type46) ? type46 : IsString3(type46) ? type46 : IsSymbol3(type46) ? type46 : IsUndefined3(type46) ? type46 : Object2({});
};
function Required(type46, options) {
  if (IsMappedResult(type46)) {
    return RequiredFromMappedResult(type46, options);
  } else {
    return CreateType({ ...RequiredResolve(type46), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
var DereferenceParameters = function(moduleProperties, types) {
  return types.map((type46) => {
    return IsRef(type46) ? Dereference(moduleProperties, type46.$ref) : FromType2(moduleProperties, type46);
  });
};
var Dereference = function(moduleProperties, ref5) {
  return ref5 in moduleProperties ? IsRef(moduleProperties[ref5]) ? Dereference(moduleProperties, moduleProperties[ref5].$ref) : FromType2(moduleProperties, moduleProperties[ref5]) : Never();
};
var FromAwaited = function(parameters) {
  return Awaited(parameters[0]);
};
var FromIndex = function(parameters) {
  return Index(parameters[0], parameters[1]);
};
var FromKeyOf = function(parameters) {
  return KeyOf(parameters[0]);
};
var FromPartial = function(parameters) {
  return Partial(parameters[0]);
};
var FromOmit = function(parameters) {
  return Omit(parameters[0], parameters[1]);
};
var FromPick = function(parameters) {
  return Pick(parameters[0], parameters[1]);
};
var FromRequired = function(parameters) {
  return Required(parameters[0]);
};
var FromComputed5 = function(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
};
var FromArray6 = function(moduleProperties, type46) {
  return Array2(FromType2(moduleProperties, type46));
};
var FromAsyncIterator3 = function(moduleProperties, type46) {
  return AsyncIterator(FromType2(moduleProperties, type46));
};
var FromConstructor3 = function(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
};
var FromFunction3 = function(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
};
var FromIntersect8 = function(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
};
var FromIterator3 = function(moduleProperties, type46) {
  return Iterator(FromType2(moduleProperties, type46));
};
var FromObject7 = function(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
};
var FromRecord3 = function(moduleProperties, type46) {
  const [value19, pattern2] = [FromType2(moduleProperties, RecordValue2(type46)), RecordPattern(type46)];
  const result = CloneType(type46);
  result.patternProperties[pattern2] = value19;
  return result;
};
var FromTransform = function(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
};
var FromTuple5 = function(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
};
var FromUnion10 = function(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
};
var FromTypes2 = function(moduleProperties, types) {
  return types.map((type46) => FromType2(moduleProperties, type46));
};
function FromType2(moduleProperties, type46) {
  return IsOptional(type46) ? CreateType(FromType2(moduleProperties, Discard(type46, [OptionalKind])), type46) : IsReadonly(type46) ? CreateType(FromType2(moduleProperties, Discard(type46, [ReadonlyKind])), type46) : IsTransform(type46) ? CreateType(FromTransform(moduleProperties, type46), type46) : IsArray3(type46) ? CreateType(FromArray6(moduleProperties, type46.items), type46) : IsAsyncIterator3(type46) ? CreateType(FromAsyncIterator3(moduleProperties, type46.items), type46) : IsComputed(type46) ? CreateType(FromComputed5(moduleProperties, type46.target, type46.parameters)) : IsConstructor(type46) ? CreateType(FromConstructor3(moduleProperties, type46.parameters, type46.returns), type46) : IsFunction3(type46) ? CreateType(FromFunction3(moduleProperties, type46.parameters, type46.returns), type46) : IsIntersect(type46) ? CreateType(FromIntersect8(moduleProperties, type46.allOf), type46) : IsIterator3(type46) ? CreateType(FromIterator3(moduleProperties, type46.items), type46) : IsObject3(type46) ? CreateType(FromObject7(moduleProperties, type46.properties), type46) : IsRecord(type46) ? CreateType(FromRecord3(moduleProperties, type46)) : IsTuple(type46) ? CreateType(FromTuple5(moduleProperties, type46.items || []), type46) : IsUnion(type46) ? CreateType(FromUnion10(moduleProperties, type46.anyOf), type46) : type46;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
function Module(properties) {
  return new TModule(properties);
}

class TModule {
  constructor($defs) {
    const computed8 = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed8);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type47, options) {
  return CreateType({ [Kind]: "Not", not: type47 }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}
var Ordinal = 0;

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
};
function Rest(T) {
  return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value21) => schema[TransformKind].Encode(encode(value21));
    const Decode = (value21) => this.decode(schema[TransformKind].Decode(value21));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Module: () => {
    {
      return Module;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  Instantiate: () => {
    {
      return Instantiate;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean2;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Argument: () => {
    {
      return Argument;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/elysia/dist/bun/index.js
var isLeapYear = function(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var date2 = function(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
};
var getTime = function(strictTimeZone) {
  return function time(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
};
var getDateTime = function(strictTimeZone) {
  let time = getTime(strictTimeZone);
  return function date_time(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1]);
  };
};
var uri = function(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
};
var byte = function(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
};
var validateInt32 = function(value21) {
  return Number.isInteger(value21) && value21 <= MAX_INT32 && value21 >= MIN_INT32;
};
var validateInt64 = function(value21) {
  return Number.isInteger(value21);
};
var validateNumber = function() {
  return true;
};
var regex = function(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
};

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error9) {
  switch (error9.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error9.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error9.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error9.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error9.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error9.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error9.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error9.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error9.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error9.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error9.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error9.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error9.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error9.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error9.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error9.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error9.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error9.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error9.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error9.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error9.schema.const === "string" ? `'${error9.schema.const}'` : error9.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error9.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error9.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error9.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error9.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error9.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error9.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error9.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error9.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error9.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error9.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error9.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error9.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error9.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error9.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error9.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error9.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
var Resolve = function(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
};
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$ref}'`);
    this.schema = schema;
  }
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
function* NumberToBytes(value21) {
  const byteCount = value21 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value21) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value21 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value21) {
  FNV1A64(ByteMarker.Array);
  for (const item of value21) {
    Visit4(item);
  }
};
var BooleanType = function(value21) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value21 ? 1 : 0);
};
var BigIntType = function(value21) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value21);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value21) {
  FNV1A64(ByteMarker.Date);
  Visit4(value21.getTime());
};
var NullType = function(value21) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value21) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value21);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value21) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value21).sort()) {
    Visit4(key);
    Visit4(value21[key]);
  }
};
var StringType = function(value21) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value21.length; i++) {
    for (const byte of NumberToBytes(value21.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value21) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value21.description);
};
var Uint8ArrayType2 = function(value21) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value21.length; i++) {
    FNV1A64(value21[i]);
  }
};
var UndefinedType = function(value21) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit4 = function(value21) {
  if (IsArray2(value21))
    return ArrayType2(value21);
  if (IsBoolean2(value21))
    return BooleanType(value21);
  if (IsBigInt2(value21))
    return BigIntType(value21);
  if (IsDate2(value21))
    return DateType2(value21);
  if (IsNull2(value21))
    return NullType(value21);
  if (IsNumber2(value21))
    return NumberType(value21);
  if (IsObject2(value21))
    return ObjectType2(value21);
  if (IsString2(value21))
    return StringType(value21);
  if (IsSymbol2(value21))
    return SymbolType(value21);
  if (IsUint8Array2(value21))
    return Uint8ArrayType2(value21);
  if (IsUndefined2(value21))
    return UndefinedType(value21);
  throw new ValueHashError(value21);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value21) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value21);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  constructor(value21) {
    super(`Unable to hash value`);
    this.value = value21;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined = function(value21) {
  return value21 !== undefined;
};
var FromAny2 = function(schema, references, value21) {
  return true;
};
var FromArgument2 = function(schema, references, value21) {
  return true;
};
var FromArray7 = function(schema, references, value21) {
  if (!IsArray2(value21))
    return false;
  if (IsDefined(schema.minItems) && !(value21.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value21.length <= schema.maxItems)) {
    return false;
  }
  if (!value21.every((value22) => Visit5(schema.items, references, value22))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value21) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value21.reduce((acc, value22) => Visit5(containsSchema, references, value22) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator4 = function(schema, references, value21) {
  return IsAsyncIterator2(value21);
};
var FromBigInt2 = function(schema, references, value21) {
  if (!IsBigInt2(value21))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value21 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value21 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value21 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value21 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value21 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean2 = function(schema, references, value21) {
  return IsBoolean2(value21);
};
var FromConstructor4 = function(schema, references, value21) {
  return Visit5(schema.returns, references, value21.prototype);
};
var FromDate2 = function(schema, references, value21) {
  if (!IsDate2(value21))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value21.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value21.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value21.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value21.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value21.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction4 = function(schema, references, value21) {
  return IsFunction2(value21);
};
var FromImport = function(schema, references, value21) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value21);
};
var FromInteger2 = function(schema, references, value21) {
  if (!IsInteger(value21)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value21 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value21 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value21 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value21 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value21 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect9 = function(schema, references, value21) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value21));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value21).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value21).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value21[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator4 = function(schema, references, value21) {
  return IsIterator2(value21);
};
var FromLiteral3 = function(schema, references, value21) {
  return value21 === schema.const;
};
var FromNever2 = function(schema, references, value21) {
  return false;
};
var FromNot2 = function(schema, references, value21) {
  return !Visit5(schema.not, references, value21);
};
var FromNull2 = function(schema, references, value21) {
  return IsNull2(value21);
};
var FromNumber2 = function(schema, references, value21) {
  if (!TypeSystemPolicy.IsNumberLike(value21))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value21 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value21 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value21 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value21 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value21 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject8 = function(schema, references, value21) {
  if (!TypeSystemPolicy.IsObjectLike(value21))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value21).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value21).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value21[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value21)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value21, knownKey) && !Visit5(property, references, value21[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value21);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value21);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value21[key]));
  } else {
    return true;
  }
};
var FromPromise4 = function(schema, references, value21) {
  return IsPromise(value21);
};
var FromRecord4 = function(schema, references, value21) {
  if (!TypeSystemPolicy.IsRecordLike(value21)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value21).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value21).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value21).every(([key, value22]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value22) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value21).every(([key, value22]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value22) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value21).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef5 = function(schema, references, value21) {
  return Visit5(Deref(schema, references), references, value21);
};
var FromRegExp2 = function(schema, references, value21) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value21.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value21.length <= schema.maxLength))
      return false;
  }
  return regex.test(value21);
};
var FromString2 = function(schema, references, value21) {
  if (!IsString2(value21)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value21.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value21.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value21))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value21);
  }
  return true;
};
var FromSymbol2 = function(schema, references, value21) {
  return IsSymbol2(value21);
};
var FromTemplateLiteral4 = function(schema, references, value21) {
  return IsString2(value21) && new RegExp(schema.pattern).test(value21);
};
var FromThis = function(schema, references, value21) {
  return Visit5(Deref(schema, references), references, value21);
};
var FromTuple6 = function(schema, references, value21) {
  if (!IsArray2(value21)) {
    return false;
  }
  if (schema.items === undefined && !(value21.length === 0)) {
    return false;
  }
  if (!(value21.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value21[i]))
      return false;
  }
  return true;
};
var FromUndefined2 = function(schema, references, value21) {
  return IsUndefined2(value21);
};
var FromUnion11 = function(schema, references, value21) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value21));
};
var FromUint8Array2 = function(schema, references, value21) {
  if (!IsUint8Array2(value21)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value21.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value21.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown2 = function(schema, references, value21) {
  return true;
};
var FromVoid2 = function(schema, references, value21) {
  return TypeSystemPolicy.IsVoidLike(value21);
};
var FromKind = function(schema, references, value21) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value21);
};
var Visit5 = function(schema, references, value21) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value21);
    case "Argument":
      return FromArgument2(schema_, references_, value21);
    case "Array":
      return FromArray7(schema_, references_, value21);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value21);
    case "BigInt":
      return FromBigInt2(schema_, references_, value21);
    case "Boolean":
      return FromBoolean2(schema_, references_, value21);
    case "Constructor":
      return FromConstructor4(schema_, references_, value21);
    case "Date":
      return FromDate2(schema_, references_, value21);
    case "Function":
      return FromFunction4(schema_, references_, value21);
    case "Import":
      return FromImport(schema_, references_, value21);
    case "Integer":
      return FromInteger2(schema_, references_, value21);
    case "Intersect":
      return FromIntersect9(schema_, references_, value21);
    case "Iterator":
      return FromIterator4(schema_, references_, value21);
    case "Literal":
      return FromLiteral3(schema_, references_, value21);
    case "Never":
      return FromNever2(schema_, references_, value21);
    case "Not":
      return FromNot2(schema_, references_, value21);
    case "Null":
      return FromNull2(schema_, references_, value21);
    case "Number":
      return FromNumber2(schema_, references_, value21);
    case "Object":
      return FromObject8(schema_, references_, value21);
    case "Promise":
      return FromPromise4(schema_, references_, value21);
    case "Record":
      return FromRecord4(schema_, references_, value21);
    case "Ref":
      return FromRef5(schema_, references_, value21);
    case "RegExp":
      return FromRegExp2(schema_, references_, value21);
    case "String":
      return FromString2(schema_, references_, value21);
    case "Symbol":
      return FromSymbol2(schema_, references_, value21);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value21);
    case "This":
      return FromThis(schema_, references_, value21);
    case "Tuple":
      return FromTuple6(schema_, references_, value21);
    case "Undefined":
      return FromUndefined2(schema_, references_, value21);
    case "Union":
      return FromUnion11(schema_, references_, value21);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value21);
    case "Unknown":
      return FromUnknown2(schema_, references_, value21);
    case "Void":
      return FromVoid2(schema_, references_, value21);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value21);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined2 = function(value21) {
  return value21 !== undefined;
};
var Create = function(errorType, schema, path, value21, errors2 = []) {
  return {
    type: errorType,
    schema,
    path,
    value: value21,
    message: GetErrorFunction()({ errorType, path, schema, value: value21, errors: errors2 }),
    errors: errors2
  };
};
function* FromAny3(schema, references, path, value21) {
}
function* FromArgument3(schema, references, path, value21) {
}
function* FromArray8(schema, references, path, value21) {
  if (!IsArray2(value21)) {
    return yield Create(ValueErrorType.Array, schema, path, value21);
  }
  if (IsDefined2(schema.minItems) && !(value21.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value21);
  }
  if (IsDefined2(schema.maxItems) && !(value21.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value21);
  }
  for (let i = 0;i < value21.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value21[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value21) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value21);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value21.reduce((acc, value22, index) => Visit6(containsSchema, references, `${path}${index}`, value22).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value21);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value21);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value21);
  }
}
function* FromAsyncIterator5(schema, references, path, value21) {
  if (!IsAsyncIterator2(value21))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value21);
}
function* FromBigInt3(schema, references, path, value21) {
  if (!IsBigInt2(value21))
    return yield Create(ValueErrorType.BigInt, schema, path, value21);
  if (IsDefined2(schema.exclusiveMaximum) && !(value21 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value21);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value21 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value21);
  }
  if (IsDefined2(schema.maximum) && !(value21 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value21);
  }
  if (IsDefined2(schema.minimum) && !(value21 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value21);
  }
  if (IsDefined2(schema.multipleOf) && !(value21 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value21);
  }
}
function* FromBoolean3(schema, references, path, value21) {
  if (!IsBoolean2(value21))
    yield Create(ValueErrorType.Boolean, schema, path, value21);
}
function* FromConstructor5(schema, references, path, value21) {
  yield* Visit6(schema.returns, references, path, value21.prototype);
}
function* FromDate3(schema, references, path, value21) {
  if (!IsDate2(value21))
    return yield Create(ValueErrorType.Date, schema, path, value21);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value21.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value21);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value21.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value21);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value21.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value21);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value21.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value21);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value21.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value21);
  }
}
function* FromFunction5(schema, references, path, value21) {
  if (!IsFunction2(value21))
    yield Create(ValueErrorType.Function, schema, path, value21);
}
function* FromImport2(schema, references, path, value21) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value21);
}
function* FromInteger3(schema, references, path, value21) {
  if (!IsInteger(value21))
    return yield Create(ValueErrorType.Integer, schema, path, value21);
  if (IsDefined2(schema.exclusiveMaximum) && !(value21 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value21);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value21 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value21);
  }
  if (IsDefined2(schema.maximum) && !(value21 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value21);
  }
  if (IsDefined2(schema.minimum) && !(value21 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value21);
  }
  if (IsDefined2(schema.multipleOf) && !(value21 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value21);
  }
}
function* FromIntersect10(schema, references, path, value21) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error13 of Visit6(inner, references, path, value21)) {
      hasError = true;
      yield error13;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value21);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value21)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value21);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value21)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value21[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value21) {
  if (!IsIterator2(value21))
    yield Create(ValueErrorType.Iterator, schema, path, value21);
}
function* FromLiteral4(schema, references, path, value21) {
  if (!(value21 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value21);
}
function* FromNever3(schema, references, path, value21) {
  yield Create(ValueErrorType.Never, schema, path, value21);
}
function* FromNot3(schema, references, path, value21) {
  if (Visit6(schema.not, references, path, value21).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value21);
}
function* FromNull3(schema, references, path, value21) {
  if (!IsNull2(value21))
    yield Create(ValueErrorType.Null, schema, path, value21);
}
function* FromNumber3(schema, references, path, value21) {
  if (!TypeSystemPolicy.IsNumberLike(value21))
    return yield Create(ValueErrorType.Number, schema, path, value21);
  if (IsDefined2(schema.exclusiveMaximum) && !(value21 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value21);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value21 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value21);
  }
  if (IsDefined2(schema.maximum) && !(value21 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value21);
  }
  if (IsDefined2(schema.minimum) && !(value21 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value21);
  }
  if (IsDefined2(schema.multipleOf) && !(value21 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value21);
  }
}
function* FromObject9(schema, references, path, value21) {
  if (!TypeSystemPolicy.IsObjectLike(value21))
    return yield Create(ValueErrorType.Object, schema, path, value21);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value21).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value21);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value21).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value21);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value21);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value21[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value21[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value21[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value21)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value21, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value21[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value21) {
  if (!IsPromise(value21))
    yield Create(ValueErrorType.Promise, schema, path, value21);
}
function* FromRecord5(schema, references, path, value21) {
  if (!TypeSystemPolicy.IsRecordLike(value21))
    return yield Create(ValueErrorType.Object, schema, path, value21);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value21).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value21);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value21).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value21);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value21)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value21)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value21)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value21) {
  yield* Visit6(Deref(schema, references), references, path, value21);
}
function* FromRegExp3(schema, references, path, value21) {
  if (!IsString2(value21))
    return yield Create(ValueErrorType.String, schema, path, value21);
  if (IsDefined2(schema.minLength) && !(value21.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value21);
  }
  if (IsDefined2(schema.maxLength) && !(value21.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value21);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value21)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value21);
  }
}
function* FromString3(schema, references, path, value21) {
  if (!IsString2(value21))
    return yield Create(ValueErrorType.String, schema, path, value21);
  if (IsDefined2(schema.minLength) && !(value21.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value21);
  }
  if (IsDefined2(schema.maxLength) && !(value21.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value21);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value21)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value21);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value21);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value21)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value21);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value21) {
  if (!IsSymbol2(value21))
    yield Create(ValueErrorType.Symbol, schema, path, value21);
}
function* FromTemplateLiteral5(schema, references, path, value21) {
  if (!IsString2(value21))
    return yield Create(ValueErrorType.String, schema, path, value21);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value21)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value21);
  }
}
function* FromThis2(schema, references, path, value21) {
  yield* Visit6(Deref(schema, references), references, path, value21);
}
function* FromTuple7(schema, references, path, value21) {
  if (!IsArray2(value21))
    return yield Create(ValueErrorType.Tuple, schema, path, value21);
  if (schema.items === undefined && !(value21.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value21);
  }
  if (!(value21.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value21);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value21[i]);
  }
}
function* FromUndefined3(schema, references, path, value21) {
  if (!IsUndefined2(value21))
    yield Create(ValueErrorType.Undefined, schema, path, value21);
}
function* FromUnion12(schema, references, path, value21) {
  if (Check(schema, references, value21))
    return;
  const errors2 = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value21)));
  yield Create(ValueErrorType.Union, schema, path, value21, errors2);
}
function* FromUint8Array3(schema, references, path, value21) {
  if (!IsUint8Array2(value21))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value21);
  if (IsDefined2(schema.maxByteLength) && !(value21.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value21);
  }
  if (IsDefined2(schema.minByteLength) && !(value21.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value21);
  }
}
function* FromUnknown3(schema, references, path, value21) {
}
function* FromVoid3(schema, references, path, value21) {
  if (!TypeSystemPolicy.IsVoidLike(value21))
    yield Create(ValueErrorType.Void, schema, path, value21);
}
function* FromKind2(schema, references, path, value21) {
  const check2 = exports_type2.Get(schema[Kind]);
  if (!check2(schema, value21))
    yield Create(ValueErrorType.Kind, schema, path, value21);
}
function* Visit6(schema, references, path, value21) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value21);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value21);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value21);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value21);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value21);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value21);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value21);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value21);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value21);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value21);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value21);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value21);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value21);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value21);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value21);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value21);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value21);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value21);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value21);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value21);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value21);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value21);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value21);
    case "String":
      return yield* FromString3(schema_, references_, path, value21);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value21);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value21);
    case "This":
      return yield* FromThis2(schema_, references_, path, value21);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value21);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value21);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value21);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value21);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value21);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value21);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value21);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var AssertValue = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return;
  throw new AssertError(Errors(schema, references, value21));
};
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}
var __classPrivateFieldSet = function(receiver, state, value21, kind26, f) {
  if (kind26 === "m")
    throw new TypeError("Private method is not writable");
  if (kind26 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind26 === "a" ? f.call(receiver, value21) : f ? f.value = value21 : state.set(receiver, value21), value21;
};
var __classPrivateFieldGet = function(receiver, state, kind26, f) {
  if (kind26 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind26 === "m" ? f : kind26 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator3) {
    const error14 = iterator3.First();
    super(error14 === undefined ? "Invalid Value" : error14.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator3, "f");
    this.error = error14;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
var FromObject10 = function(value21) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value21)) {
    Acc[key] = Clone2(value21[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value21)) {
    Acc[key] = Clone2(value21[key]);
  }
  return Acc;
};
var FromArray9 = function(value21) {
  return value21.map((element) => Clone2(element));
};
var FromTypedArray = function(value21) {
  return value21.slice();
};
var FromMap = function(value21) {
  return new Map(Clone2([...value21.entries()]));
};
var FromSet = function(value21) {
  return new Set(Clone2([...value21.entries()]));
};
var FromDate4 = function(value21) {
  return new Date(value21.toISOString());
};
var FromValue2 = function(value21) {
  return value21;
};
function Clone2(value21) {
  if (IsArray2(value21))
    return FromArray9(value21);
  if (IsDate2(value21))
    return FromDate4(value21);
  if (IsTypedArray(value21))
    return FromTypedArray(value21);
  if (IsMap(value21))
    return FromMap(value21);
  if (IsSet(value21))
    return FromSet(value21);
  if (IsObject2(value21))
    return FromObject10(value21);
  if (IsValueType(value21))
    return FromValue2(value21);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
var FromDefault = function(value21) {
  return IsFunction2(value21) ? value21() : Clone2(value21);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArgument4 = function(schema, references) {
  return {};
};
var FromArray10 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value21 = Visit7(schema.returns, references);
    if (typeof value21 === "object" && !Array.isArray(value21)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value21)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate5 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromImport3 = function(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit7(target, [...references, ...definitions]);
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value21 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value21))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value21;
  }
};
var FromIterator6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject11 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required3 = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required3.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
};
var FromPromise6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromRef7 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral6 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple8 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion13 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray10(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport3(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect11(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord6(schema_, references_);
    case "Ref":
      return FromRef7(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple8(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion13(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value21) {
  if (schema[Kind] === "Object" && typeof value21 === "object" && !IsNull2(value21)) {
    const object11 = schema;
    const keys = Object.getOwnPropertyNames(value21);
    const entries = Object.entries(object11.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal12 = schema2[Kind] === "Literal" && schema2.const === value21[key] ? max : 0;
      const checks = Check(schema2, references, value21[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal12 + checks + exists);
    }, 0);
  } else if (schema[Kind] === "Union") {
    const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
    const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value21));
    return Math.max(...scores);
  } else {
    return Check(schema, references, value21) ? 1 : 0;
  }
};
var SelectUnion = function(union18, references, value21) {
  const schemas = union18.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value21);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union18, references, value21) {
  if ("default" in union18) {
    return typeof value21 === "function" ? union18.default : Clone2(union18.default);
  } else {
    const schema = SelectUnion(union18, references, value21);
    return Cast(schema, references, value21);
  }
};
var DefaultClone = function(schema, references, value21) {
  return Check(schema, references, value21) ? Clone2(value21) : Create2(schema, references);
};
var Default = function(schema, references, value21) {
  return Check(schema, references, value21) ? value21 : Create2(schema, references);
};
var FromArray11 = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return Clone2(value21);
  const created = IsArray2(value21) ? Clone2(value21) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value22) => Visit8(schema.items, references, value22));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor7 = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return Create2(schema, references);
  const required3 = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required3.has(key) && value21.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value21.prototype[key]);
  }
  return result;
};
var FromImport4 = function(schema, references, value21) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit8(target, [...references, ...definitions], value21);
};
var IntersectAssign = function(correct, value21) {
  if (IsObject2(correct) && !IsObject2(value21) || !IsObject2(correct) && IsObject2(value21))
    return correct;
  if (!IsObject2(correct) || !IsObject2(value21))
    return value21;
  return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
    const property = key in value21 ? IntersectAssign(correct[key], value21[key]) : correct[key];
    return { ...result, [key]: property };
  }, {});
};
var FromIntersect12 = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return value21;
  const correct = Create2(schema, references);
  const assigned = IntersectAssign(correct, value21);
  return Check(schema, references, assigned) ? assigned : correct;
};
var FromNever5 = function(schema, references, value21) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject12 = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return value21;
  if (value21 === null || typeof value21 !== "object")
    return Create2(schema, references);
  const required3 = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required3.has(key) && value21[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value21[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value21)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value21[propertyName]);
    }
  }
  return result;
};
var FromRecord7 = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return Clone2(value21);
  if (value21 === null || typeof value21 !== "object" || Array.isArray(value21) || value21 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value21)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef8 = function(schema, references, value21) {
  return Visit8(Deref(schema, references), references, value21);
};
var FromThis4 = function(schema, references, value21) {
  return Visit8(Deref(schema, references), references, value21);
};
var FromTuple9 = function(schema, references, value21) {
  if (Check(schema, references, value21))
    return Clone2(value21);
  if (!IsArray2(value21))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value21[index]));
};
var FromUnion14 = function(schema, references, value21) {
  return Check(schema, references, value21) ? Clone2(value21) : CastUnion(schema, references, value21);
};
var Visit8 = function(schema, references, value21) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value21);
    case "Constructor":
      return FromConstructor7(schema_, references_, value21);
    case "Import":
      return FromImport4(schema_, references_, value21);
    case "Intersect":
      return FromIntersect12(schema_, references_, value21);
    case "Never":
      return FromNever5(schema_, references_, value21);
    case "Object":
      return FromObject12(schema_, references_, value21);
    case "Record":
      return FromRecord7(schema_, references_, value21);
    case "Ref":
      return FromRef8(schema_, references_, value21);
    case "This":
      return FromThis4(schema_, references_, value21);
    case "Tuple":
      return FromTuple9(schema_, references_, value21);
    case "Union":
      return FromUnion14(schema_, references_, value21);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value21);
    default:
      return Default(schema_, references_, value21);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
};
var FromArray12 = function(schema, references, value21) {
  if (!IsArray2(value21))
    return value21;
  return value21.map((value22) => Visit9(schema.items, references, value22));
};
var FromImport5 = function(schema, references, value21) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit9(target, [...references, ...definitions], value21);
};
var FromIntersect13 = function(schema, references, value21) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value21)));
  const composite = intersections.reduce((acc, value22) => IsObject2(value22) ? { ...acc, ...value22 } : value22, {});
  if (!IsObject2(value21) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value21)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value21[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value21[key]);
    }
  }
  return composite;
};
var FromObject13 = function(schema, references, value21) {
  if (!IsObject2(value21) || IsArray2(value21))
    return value21;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value21)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value21[key] = Visit9(schema.properties[key], references, value21[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value21[key])) {
      value21[key] = Visit9(additionalProperties, references, value21[key]);
      continue;
    }
    delete value21[key];
  }
  return value21;
};
var FromRecord8 = function(schema, references, value21) {
  if (!IsObject2(value21))
    return value21;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value21);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value21[key] = Visit9(propertySchema, references, value21[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value21[key])) {
      value21[key] = Visit9(additionalProperties, references, value21[key]);
      continue;
    }
    delete value21[key];
  }
  return value21;
};
var FromRef9 = function(schema, references, value21) {
  return Visit9(Deref(schema, references), references, value21);
};
var FromThis5 = function(schema, references, value21) {
  return Visit9(Deref(schema, references), references, value21);
};
var FromTuple10 = function(schema, references, value21) {
  if (!IsArray2(value21))
    return value21;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value21.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value21[i] = Visit9(schema.items[i], references, value21[i]);
  }
  return value21.length > length ? value21.slice(0, length) : value21;
};
var FromUnion15 = function(schema, references, value21) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value21)) {
      return Visit9(inner, references, value21);
    }
  }
  return value21;
};
var Visit9 = function(schema, references, value21) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value21);
    case "Import":
      return FromImport5(schema_, references_, value21);
    case "Intersect":
      return FromIntersect13(schema_, references_, value21);
    case "Object":
      return FromObject13(schema_, references_, value21);
    case "Record":
      return FromRecord8(schema_, references_, value21);
    case "Ref":
      return FromRef9(schema_, references_, value21);
    case "This":
      return FromThis5(schema_, references_, value21);
    case "Tuple":
      return FromTuple10(schema_, references_, value21);
    case "Union":
      return FromUnion15(schema_, references_, value21);
    default:
      return value21;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
var IsStringNumeric = function(value21) {
  return IsString2(value21) && !isNaN(value21) && !isNaN(parseFloat(value21));
};
var IsValueToString = function(value21) {
  return IsBigInt2(value21) || IsBoolean2(value21) || IsNumber2(value21);
};
var IsValueTrue = function(value21) {
  return value21 === true || IsNumber2(value21) && value21 === 1 || IsBigInt2(value21) && value21 === BigInt("1") || IsString2(value21) && (value21.toLowerCase() === "true" || value21 === "1");
};
var IsValueFalse = function(value21) {
  return value21 === false || IsNumber2(value21) && (value21 === 0 || Object.is(value21, -0)) || IsBigInt2(value21) && value21 === BigInt("0") || IsString2(value21) && (value21.toLowerCase() === "false" || value21 === "0" || value21 === "-0");
};
var IsTimeStringWithTimeZone = function(value21) {
  return IsString2(value21) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value21);
};
var IsTimeStringWithoutTimeZone = function(value21) {
  return IsString2(value21) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value21);
};
var IsDateTimeStringWithTimeZone = function(value21) {
  return IsString2(value21) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value21);
};
var IsDateTimeStringWithoutTimeZone = function(value21) {
  return IsString2(value21) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value21);
};
var IsDateString = function(value21) {
  return IsString2(value21) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value21);
};
var TryConvertLiteralString = function(value21, target) {
  const conversion = TryConvertString(value21);
  return conversion === target ? conversion : value21;
};
var TryConvertLiteralNumber = function(value21, target) {
  const conversion = TryConvertNumber(value21);
  return conversion === target ? conversion : value21;
};
var TryConvertLiteralBoolean = function(value21, target) {
  const conversion = TryConvertBoolean(value21);
  return conversion === target ? conversion : value21;
};
var TryConvertLiteral = function(schema, value21) {
  return IsString2(schema.const) ? TryConvertLiteralString(value21, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value21, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value21, schema.const) : value21;
};
var TryConvertBoolean = function(value21) {
  return IsValueTrue(value21) ? true : IsValueFalse(value21) ? false : value21;
};
var TryConvertBigInt = function(value21) {
  const truncateInteger = (value22) => value22.split(".")[0];
  return IsStringNumeric(value21) ? BigInt(truncateInteger(value21)) : IsNumber2(value21) ? BigInt(Math.trunc(value21)) : IsValueFalse(value21) ? BigInt(0) : IsValueTrue(value21) ? BigInt(1) : value21;
};
var TryConvertString = function(value21) {
  return IsSymbol2(value21) && value21.description !== undefined ? value21.description.toString() : IsValueToString(value21) ? value21.toString() : value21;
};
var TryConvertNumber = function(value21) {
  return IsStringNumeric(value21) ? parseFloat(value21) : IsValueTrue(value21) ? 1 : IsValueFalse(value21) ? 0 : value21;
};
var TryConvertInteger = function(value21) {
  return IsStringNumeric(value21) ? parseInt(value21) : IsNumber2(value21) ? Math.trunc(value21) : IsValueTrue(value21) ? 1 : IsValueFalse(value21) ? 0 : value21;
};
var TryConvertNull = function(value21) {
  return IsString2(value21) && value21.toLowerCase() === "null" ? null : value21;
};
var TryConvertUndefined = function(value21) {
  return IsString2(value21) && value21 === "undefined" ? undefined : value21;
};
var TryConvertDate = function(value21) {
  return IsDate2(value21) ? value21 : IsNumber2(value21) ? new Date(value21) : IsValueTrue(value21) ? new Date(1) : IsValueFalse(value21) ? new Date(0) : IsStringNumeric(value21) ? new Date(parseInt(value21)) : IsTimeStringWithoutTimeZone(value21) ? new Date(`1970-01-01T${value21}.000Z`) : IsTimeStringWithTimeZone(value21) ? new Date(`1970-01-01T${value21}`) : IsDateTimeStringWithoutTimeZone(value21) ? new Date(`${value21}.000Z`) : IsDateTimeStringWithTimeZone(value21) ? new Date(value21) : IsDateString(value21) ? new Date(`${value21}T00:00:00.000Z`) : value21;
};
var Default2 = function(value21) {
  return value21;
};
var FromArray13 = function(schema, references, value21) {
  const elements = IsArray2(value21) ? value21 : [value21];
  return elements.map((element) => Visit10(schema.items, references, element));
};
var FromBigInt5 = function(schema, references, value21) {
  return TryConvertBigInt(value21);
};
var FromBoolean5 = function(schema, references, value21) {
  return TryConvertBoolean(value21);
};
var FromDate6 = function(schema, references, value21) {
  return TryConvertDate(value21);
};
var FromImport6 = function(schema, references, value21) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions], value21);
};
var FromInteger5 = function(schema, references, value21) {
  return TryConvertInteger(value21);
};
var FromIntersect14 = function(schema, references, value21) {
  return schema.allOf.reduce((value22, schema2) => Visit10(schema2, references, value22), value21);
};
var FromLiteral6 = function(schema, references, value21) {
  return TryConvertLiteral(schema, value21);
};
var FromNull5 = function(schema, references, value21) {
  return TryConvertNull(value21);
};
var FromNumber5 = function(schema, references, value21) {
  return TryConvertNumber(value21);
};
var FromObject14 = function(schema, references, value21) {
  if (!IsObject2(value21))
    return value21;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value21, propertyKey))
      continue;
    value21[propertyKey] = Visit10(schema.properties[propertyKey], references, value21[propertyKey]);
  }
  return value21;
};
var FromRecord9 = function(schema, references, value21) {
  const isConvertable = IsObject2(value21);
  if (!isConvertable)
    return value21;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value21)) {
    value21[propKey] = Visit10(property, references, propValue);
  }
  return value21;
};
var FromRef10 = function(schema, references, value21) {
  return Visit10(Deref(schema, references), references, value21);
};
var FromString5 = function(schema, references, value21) {
  return TryConvertString(value21);
};
var FromSymbol5 = function(schema, references, value21) {
  return IsString2(value21) || IsNumber2(value21) ? Symbol(value21) : value21;
};
var FromThis6 = function(schema, references, value21) {
  return Visit10(Deref(schema, references), references, value21);
};
var FromTuple11 = function(schema, references, value21) {
  const isConvertable = IsArray2(value21) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value21;
  return value21.map((value22, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value22) : value22;
  });
};
var FromUndefined5 = function(schema, references, value21) {
  return TryConvertUndefined(value21);
};
var FromUnion16 = function(schema, references, value21) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, Clone2(value21));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value21;
};
var Visit10 = function(schema, references, value21) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_, value21);
    case "BigInt":
      return FromBigInt5(schema_, references_, value21);
    case "Boolean":
      return FromBoolean5(schema_, references_, value21);
    case "Date":
      return FromDate6(schema_, references_, value21);
    case "Import":
      return FromImport6(schema_, references_, value21);
    case "Integer":
      return FromInteger5(schema_, references_, value21);
    case "Intersect":
      return FromIntersect14(schema_, references_, value21);
    case "Literal":
      return FromLiteral6(schema_, references_, value21);
    case "Null":
      return FromNull5(schema_, references_, value21);
    case "Number":
      return FromNumber5(schema_, references_, value21);
    case "Object":
      return FromObject14(schema_, references_, value21);
    case "Record":
      return FromRecord9(schema_, references_, value21);
    case "Ref":
      return FromRef10(schema_, references_, value21);
    case "String":
      return FromString5(schema_, references_, value21);
    case "Symbol":
      return FromSymbol5(schema_, references_, value21);
    case "This":
      return FromThis6(schema_, references_, value21);
    case "Tuple":
      return FromTuple11(schema_, references_, value21);
    case "Undefined":
      return FromUndefined5(schema_, references_, value21);
    case "Union":
      return FromUnion16(schema_, references_, value21);
    default:
      return Default2(value21);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
var Default3 = function(schema, path, value21) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value21) : value21;
  } catch (error17) {
    throw new TransformDecodeError(schema, path, value21, error17);
  }
};
var FromArray14 = function(schema, references, path, value21) {
  return IsArray2(value21) ? Default3(schema, path, value21.map((value22, index) => Visit11(schema.items, references, `${path}/${index}`, value22))) : Default3(schema, path, value21);
};
var FromIntersect15 = function(schema, references, path, value21) {
  if (!IsObject2(value21) || IsValueType(value21))
    return Default3(schema, path, value21);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value21 };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit11(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
};
var FromImport7 = function(schema, references, path, value21) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit11(target, [...references, ...additional], path, value21);
  return Default3(schema, path, result);
};
var FromNot5 = function(schema, references, path, value21) {
  return Default3(schema, path, Visit11(schema.not, references, path, value21));
};
var FromObject15 = function(schema, references, path, value21) {
  if (!IsObject2(value21))
    return Default3(schema, path, value21);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value21 };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit11(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
};
var FromRecord10 = function(schema, references, path, value21) {
  if (!IsObject2(value21))
    return Default3(schema, path, value21);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value21 };
  for (const key of Object.getOwnPropertyNames(value21))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit11(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
};
var FromRef11 = function(schema, references, path, value21) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value21));
};
var FromThis7 = function(schema, references, path, value21) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value21));
};
var FromTuple12 = function(schema, references, path, value21) {
  return IsArray2(value21) && IsArray2(schema.items) ? Default3(schema, path, schema.items.map((schema2, index) => Visit11(schema2, references, `${path}/${index}`, value21[index]))) : Default3(schema, path, value21);
};
var FromUnion17 = function(schema, references, path, value21) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value21))
      continue;
    const decoded = Visit11(subschema, references, path, value21);
    return Default3(schema, path, decoded);
  }
  return Default3(schema, path, value21);
};
var Visit11 = function(schema, references, path, value21) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, path, value21);
    case "Import":
      return FromImport7(schema_, references_, path, value21);
    case "Intersect":
      return FromIntersect15(schema_, references_, path, value21);
    case "Not":
      return FromNot5(schema_, references_, path, value21);
    case "Object":
      return FromObject15(schema_, references_, path, value21);
    case "Record":
      return FromRecord10(schema_, references_, path, value21);
    case "Ref":
      return FromRef11(schema_, references_, path, value21);
    case "Symbol":
      return Default3(schema_, path, value21);
    case "This":
      return FromThis7(schema_, references_, path, value21);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value21);
    case "Union":
      return FromUnion17(schema_, references_, path, value21);
    default:
      return Default3(schema_, path, value21);
  }
};
function TransformDecode(schema, references, value21) {
  return Visit11(schema, references, "", value21);
}

class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value21, error17) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value21;
    this.error = error17;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value21, error17) {
    super(error17 instanceof Error ? error17.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value21;
    this.error = error17;
  }
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
var Default4 = function(schema, path, value21) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value21) : value21;
  } catch (error18) {
    throw new TransformEncodeError(schema, path, value21, error18);
  }
};
var FromArray15 = function(schema, references, path, value21) {
  const defaulted = Default4(schema, path, value21);
  return IsArray2(defaulted) ? defaulted.map((value22, index) => Visit12(schema.items, references, `${path}/${index}`, value22)) : defaulted;
};
var FromImport8 = function(schema, references, path, value21) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default4(schema, path, value21);
  return Visit12(target, [...references, ...additional], path, result);
};
var FromIntersect16 = function(schema, references, path, value21) {
  const defaulted = Default4(schema, path, value21);
  if (!IsObject2(value21) || IsValueType(value21))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit12(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
};
var FromNot6 = function(schema, references, path, value21) {
  return Default4(schema.not, path, Default4(schema, path, value21));
};
var FromObject16 = function(schema, references, path, value21) {
  const defaulted = Default4(schema, path, value21);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit12(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
};
var FromRecord11 = function(schema, references, path, value21) {
  const defaulted = Default4(schema, path, value21);
  if (!IsObject2(value21))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value21))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit12(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
};
var FromRef12 = function(schema, references, path, value21) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value21);
  return Default4(schema, path, resolved);
};
var FromThis8 = function(schema, references, path, value21) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value21);
  return Default4(schema, path, resolved);
};
var FromTuple13 = function(schema, references, path, value21) {
  const value1 = Default4(schema, path, value21);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit12(schema2, references, `${path}/${index}`, value1[index])) : [];
};
var FromUnion18 = function(schema, references, path, value21) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value21))
      continue;
    const value1 = Visit12(subschema, references, path, value21);
    return Default4(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit12(subschema, references, path, value21);
    if (!Check(schema, references, value1))
      continue;
    return Default4(schema, path, value1);
  }
  return Default4(schema, path, value21);
};
var Visit12 = function(schema, references, path, value21) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, path, value21);
    case "Import":
      return FromImport8(schema_, references_, path, value21);
    case "Intersect":
      return FromIntersect16(schema_, references_, path, value21);
    case "Not":
      return FromNot6(schema_, references_, path, value21);
    case "Object":
      return FromObject16(schema_, references_, path, value21);
    case "Record":
      return FromRecord11(schema_, references_, path, value21);
    case "Ref":
      return FromRef12(schema_, references_, path, value21);
    case "This":
      return FromThis8(schema_, references_, path, value21);
    case "Tuple":
      return FromTuple13(schema_, references_, path, value21);
    case "Union":
      return FromUnion18(schema_, references_, path, value21);
    default:
      return Default4(schema_, path, value21);
  }
};
function TransformEncode(schema, references, value21) {
  return Visit12(schema, references, "", value21);
}

class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value21, error18) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value21;
    this.error = error18;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value21, error18) {
    super(`${error18 instanceof Error ? error18.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value21;
    this.error = error18;
  }
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
var FromArray16 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
};
var FromAsyncIterator7 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
};
var FromConstructor8 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
};
var FromFunction7 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
};
var FromIntersect17 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit13(schema2, references));
};
var FromImport9 = function(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit13(target, [...additional, ...references]);
};
var FromIterator7 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.not, references);
};
var FromObject17 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit13(schema2, references)) || IsSchema(schema.additionalProperties) && Visit13(schema.additionalProperties, references);
};
var FromPromise7 = function(schema, references) {
  return IsTransform(schema) || Visit13(schema.item, references);
};
var FromRecord12 = function(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform(schema) || Visit13(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef13 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
};
var FromThis9 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
};
var FromTuple14 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit13(schema2, references));
};
var FromUnion19 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit13(schema2, references));
};
var Visit13 = function(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "Constructor":
      return FromConstructor8(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport9(schema_, references_);
    case "Intersect":
      return FromIntersect17(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject17(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord12(schema_, references_);
    case "Ref":
      return FromRef13(schema_, references_);
    case "This":
      return FromThis9(schema_, references_);
    case "Tuple":
      return FromTuple14(schema_, references_);
    case "Union":
      return FromUnion19(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit13(schema, references);
}
var visited = new Set;

// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value21] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value21))
    throw new TransformDecodeCheckError(schema, value21, Errors(schema, references, value21).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value21) : value21;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
var ValueOrDefault = function(schema, value21) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone7 = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value21) ? clone7 : IsObject2(value21) && IsObject2(clone7) ? Object.assign(clone7, value21) : value21;
};
var HasDefaultProperty = function(schema) {
  return IsKind(schema) && "default" in schema;
};
var FromArray17 = function(schema, references, value21) {
  if (IsArray2(value21)) {
    for (let i = 0;i < value21.length; i++) {
      value21[i] = Visit14(schema.items, references, value21[i]);
    }
    return value21;
  }
  const defaulted = ValueOrDefault(schema, value21);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromDate7 = function(schema, references, value21) {
  return IsDate2(value21) ? value21 : ValueOrDefault(schema, value21);
};
var FromImport10 = function(schema, references, value21) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value21);
};
var FromIntersect18 = function(schema, references, value21) {
  const defaulted = ValueOrDefault(schema, value21);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject18 = function(schema, references, value21) {
  const defaulted = ValueOrDefault(schema, value21);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord13 = function(schema, references, value21) {
  const defaulted = ValueOrDefault(schema, value21);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef14 = function(schema, references, value21) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value21));
};
var FromThis10 = function(schema, references, value21) {
  return Visit14(Deref(schema, references), references, value21);
};
var FromTuple15 = function(schema, references, value21) {
  const defaulted = ValueOrDefault(schema, value21);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion20 = function(schema, references, value21) {
  const defaulted = ValueOrDefault(schema, value21);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit14 = function(schema, references, value21) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value21);
    case "Date":
      return FromDate7(schema_, references_, value21);
    case "Import":
      return FromImport10(schema_, references_, value21);
    case "Intersect":
      return FromIntersect18(schema_, references_, value21);
    case "Object":
      return FromObject18(schema_, references_, value21);
    case "Record":
      return FromRecord13(schema_, references_, value21);
    case "Ref":
      return FromRef14(schema_, references_, value21);
    case "This":
      return FromThis10(schema_, references_, value21);
    case "Tuple":
      return FromTuple15(schema_, references_, value21);
    case "Union":
      return FromUnion20(schema_, references_, value21);
    default:
      return ValueOrDefault(schema_, value21);
  }
};
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value21, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value21, pointer, update);
  let [owner, next, key] = [null, value21, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value21, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value21, pointer);
  let [owner, next, key] = [null, value21, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value21, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value21, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value21, pointer) {
  if (pointer === "")
    return value21;
  let current = value21;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  constructor(value21, path, update) {
    super("Cannot set root value");
    this.value = value21;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value21, path) {
    super("Cannot delete root value");
    this.value = value21;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
var ObjectType3 = function(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType3 = function(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
};
var ArrayType3 = function(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value21, index) => Equal(value21, right[index]));
};
var TypedArrayType = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value21, index) => Equal(value21, right[index]));
};
var ValueType = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var CreateUpdate = function(path, value21) {
  return { type: "update", path, value: value21 };
};
var CreateInsert = function(path, value21) {
  return { type: "insert", path, value: value21 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
var AssertDiffable = function(value21) {
  if (globalThis.Object.getOwnPropertySymbols(value21).length > 0)
    throw new ValueDiffError(value21, "Cannot diff objects with symbols");
};
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value21, message) {
    super(message);
    this.value = value21;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value21] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value21) : value21;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
var IsStandardObject2 = function(value21) {
  return IsObject2(value21) && !IsArray2(value21);
};
var ObjectType5 = function(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType5 = function(root, path, current, next) {
  if (!IsArray2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType3 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType3 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit16 = function(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
};
var IsNonMutableValue = function(value21) {
  return IsTypedArray(value21) || IsValueType(value21);
};
var IsMismatchedValue = function(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
var ParseValue = function(operations, type53, references, value21) {
  return operations.reduce((value22, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type53, references, value22);
  }, value21);
};
function Parse(...args) {
  const [operations, schema, references, value21] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value21);
}

class ParseError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry4 = new Map([
    ["Assert", (type53, references, value21) => {
      Assert(type53, references, value21);
      return value21;
    }],
    ["Cast", (type53, references, value21) => Cast(type53, references, value21)],
    ["Clean", (type53, references, value21) => Clean(type53, references, value21)],
    ["Clone", (_type, _references, value21) => Clone2(value21)],
    ["Convert", (type53, references, value21) => Convert(type53, references, value21)],
    ["Decode", (type53, references, value21) => HasTransform(type53, references) ? TransformDecode(type53, references, value21) : value21],
    ["Default", (type53, references, value21) => Default5(type53, references, value21)],
    ["Encode", (type53, references, value21) => HasTransform(type53, references) ? TransformEncode(type53, references, value21) : value21]
  ]);
  function Delete5(key) {
    registry4.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry4.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry4.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => {
    {
      return ValueErrorIterator;
    }
  },
  Patch: () => {
    {
      return Patch;
    }
  },
  Parse: () => {
    {
      return Parse;
    }
  },
  Mutate: () => {
    {
      return Mutate;
    }
  },
  Hash: () => {
    {
      return Hash;
    }
  },
  Errors: () => {
    {
      return Errors;
    }
  },
  Equal: () => {
    {
      return Equal;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Edit: () => {
    {
      return Edit;
    }
  },
  Diff: () => {
    {
      return Diff;
    }
  },
  Default: () => {
    {
      return Default5;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create2;
    }
  },
  Convert: () => {
    {
      return Convert;
    }
  },
  Clone: () => {
    {
      return Clone2;
    }
  },
  Clean: () => {
    {
      return Clean;
    }
  },
  Check: () => {
    {
      return Check;
    }
  },
  Cast: () => {
    {
      return Cast;
    }
  },
  Assert: () => {
    {
      return Assert;
    }
  }
});
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value21) {
    return Errors(this.schema, this.references, value21);
  }
  Check(value21) {
    return this.checkFunc(value21);
  }
  Decode(value21) {
    if (!this.checkFunc(value21))
      throw new TransformDecodeCheckError(this.schema, value21, this.Errors(value21).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value21) : value21;
  }
  Encode(value21) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value21) : value21;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value21, this.Errors(value21).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value21) {
    if (value21.length === 0)
      return false;
    return Character.IsNumeric(value21.charCodeAt(0));
  }
  function IsAccessor(value21) {
    if (IsFirstCharacterNumeric(value21))
      return false;
    for (let i = 0;i < value21.length; i++) {
      const code = value21.charCodeAt(i);
      const check13 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check13)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object12, key) {
    return IsAccessor(key) ? `${object12}.${key}` : `${object12}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value21, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value21} ? ${expression} : true)` : `(${MemberExpression.Encode(value21, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value21) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value21} === 'object' && ${value21} !== null && !Array.isArray(${value21}))` : `(typeof ${value21} === 'object' && ${value21} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value21) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value21} === 'object' && ${value21} !== null && !Array.isArray(${value21}) && !(${value21} instanceof Date) && !(${value21} instanceof Uint8Array))` : `(typeof ${value21} === 'object' && ${value21} !== null && !(${value21} instanceof Date) && !(${value21} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value21) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value21} === 'number'` : `Number.isFinite(${value21})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value21) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value21} === undefined || ${value21} === null)` : `${value21} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value21) {
    yield "true";
  }
  function* FromArgument5(schema, references, value21) {
    yield "true";
  }
  function* FromArray18(schema, references, value21) {
    yield `Array.isArray(${value21})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value21}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value21}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value21}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check13 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check13}})(${value21})`;
    }
    if (schema.uniqueItems === true) {
      const check13 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check13} }`;
      yield `((${parameter}) => { ${block} )(${value21})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value21) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value21})`;
  }
  function* FromBigInt6(schema, references, value21) {
    yield `(typeof ${value21} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value21} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value21} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value21} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value21} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value21} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value21) {
    yield `(typeof ${value21} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value21) {
    yield* Visit17(schema.returns, references, `${value21}.prototype`);
  }
  function* FromDate8(schema, references, value21) {
    yield `(${value21} instanceof Date) && Number.isFinite(${value21}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value21}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value21}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value21}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value21}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value21}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value21) {
    yield `(typeof ${value21} === 'function')`;
  }
  function* FromImport11(schema, references, value21) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value21);
  }
  function* FromInteger6(schema, references, value21) {
    yield `Number.isInteger(${value21})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value21} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value21} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value21} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value21} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value21} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value21) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value21)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value21}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value21}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value21}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value21) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value21})`;
  }
  function* FromLiteral7(schema, references, value21) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value21} === ${schema.const})`;
    } else {
      yield `(${value21} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value21) {
    yield `false`;
  }
  function* FromNot8(schema, references, value21) {
    const expression = CreateExpression(schema.not, references, value21);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value21) {
    yield `(${value21} === null)`;
  }
  function* FromNumber6(schema, references, value21) {
    yield Policy.IsNumberLike(value21);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value21} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value21} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value21} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value21} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value21} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value21) {
    yield Policy.IsObjectLike(value21);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value21}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value21}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value21, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value21})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value21, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value21}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value21}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value21}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value21}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value21) {
    yield `${value21} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value21) {
    yield Policy.IsRecordLike(value21);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value21}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value21}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value21) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value21}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value21) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value21})`;
    yield* Visit17(target, references, value21);
  }
  function* FromRegExp5(schema, references, value21) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value21} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value21}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value21}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value21})`;
  }
  function* FromString6(schema, references, value21) {
    yield `(typeof ${value21} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value21}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value21}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value21})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value21})`;
    }
  }
  function* FromSymbol6(schema, references, value21) {
    yield `(typeof ${value21} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value21) {
    yield `(typeof ${value21} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value21})`;
  }
  function* FromThis11(schema, references, value21) {
    yield `${CreateFunctionName(schema.$ref)}(${value21})`;
  }
  function* FromTuple16(schema, references, value21) {
    yield `Array.isArray(${value21})`;
    if (schema.items === undefined)
      return yield `${value21}.length === 0`;
    yield `(${value21}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value21}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value21) {
    yield `${value21} === undefined`;
  }
  function* FromUnion21(schema, references, value21) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value21));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value21) {
    yield `${value21} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value21}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value21}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value21) {
    yield "true";
  }
  function* FromVoid5(schema, references, value21) {
    yield Policy.IsVoidLike(value21);
  }
  function* FromKind4(schema, references, value21) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value21})`;
  }
  function* Visit17(schema, references, value21, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value21})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value21})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value21);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value21);
      case "Array":
        return yield* FromArray18(schema_, references_, value21);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value21);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value21);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value21);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value21);
      case "Date":
        return yield* FromDate8(schema_, references_, value21);
      case "Function":
        return yield* FromFunction8(schema_, references_, value21);
      case "Import":
        return yield* FromImport11(schema_, references_, value21);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value21);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value21);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value21);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value21);
      case "Never":
        return yield* FromNever6(schema_, references_, value21);
      case "Not":
        return yield* FromNot8(schema_, references_, value21);
      case "Null":
        return yield* FromNull6(schema_, references_, value21);
      case "Number":
        return yield* FromNumber6(schema_, references_, value21);
      case "Object":
        return yield* FromObject19(schema_, references_, value21);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value21);
      case "Record":
        return yield* FromRecord14(schema_, references_, value21);
      case "Ref":
        return yield* FromRef15(schema_, references_, value21);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value21);
      case "String":
        return yield* FromString6(schema_, references_, value21);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value21);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value21);
      case "This":
        return yield* FromThis11(schema_, references_, value21);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value21);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value21);
      case "Union":
        return yield* FromUnion21(schema_, references_, value21);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value21);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value21);
      case "Void":
        return yield* FromVoid5(schema_, references_, value21);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value21);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value21, useHoisting = true) {
    return `(${[...Visit17(schema, references, value21, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value21, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value21, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type54) {
    const annotation = state.language === "typescript" ? `: ${type54}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type54) {
    return state.language === "typescript" ? `: ${type54}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind31, instance, value21) {
      if (!exports_type2.Has(kind31) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind31);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value21);
    }
    function formatRegistryFunction(format, value21) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value21);
    }
    function hashFunction(value21) {
      return Hash(value21);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/bun/index.js
var removeTrailingEquals = function(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
};
var createType = function(kind31, func) {
  if (!exports_type2.Has(kind31))
    exports_type2.Set(kind31, func);
  return (options = {}) => Unsafe({ ...options, [Kind]: kind31 });
};
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    while (true) {
      let { done, value: value23 } = await reader.read();
      if (done)
        break;
      yield decoder.decode(value23);
    }
  } finally {
    reader.releaseLock();
  }
}
var parseQueryFromURL = function(input, startIndex = 0) {
  let result = Object.create(null), KEY_PLUS_FLAG = 1, KEY_DECODE_FLAG = 2, VALUE_PLUS_FLAG = 4, VALUE_DECODE_FLAG = 8, flags = 0, startingIndex = startIndex - 1, equalityIndex = startingIndex, inputLength = input.length;
  for (let i = startIndex;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= 8;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= 4;
        else
          flags |= 1;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= 8;
        else
          flags |= 2;
        break;
    }
  return processKeyValuePair(inputLength), result;
  function processKeyValuePair(endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, keyEndIndex = hasBothKeyValuePair ? equalityIndex : endIndex;
    if (keyEndIndex <= startingIndex + 1)
      return;
    let keySlice = input.slice(startingIndex + 1, keyEndIndex);
    if (flags & 1)
      keySlice = keySlice.replace(/\+/g, " ");
    if (flags & 2)
      keySlice = import_fast_decode_uri_component2.default(keySlice) || keySlice;
    if (result[keySlice] !== undefined)
      return;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      if (finalValue = input.slice(equalityIndex + 1, endIndex), flags & 4)
        finalValue = finalValue.replace(/\+/g, " ");
      if (flags & 8)
        finalValue = import_fast_decode_uri_component2.default(finalValue) || finalValue;
    }
    result[keySlice] = finalValue;
  }
};
var parseQuery = function(input) {
  let result = Object.create(null), flags = 0, KEY_HAS_PLUS = 1, KEY_NEEDS_DECODE = 2, VALUE_HAS_PLUS = 4, VALUE_NEEDS_DECODE = 8, inputLength = input.length, startingIndex = -1, equalityIndex = -1;
  for (let i = 0;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(input, i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (currentValue === undefined)
      result[finalKey] = finalValue;
    else if (Array.isArray(currentValue))
      currentValue.push(finalValue);
    else
      result[finalKey] = [currentValue, finalValue];
  }
};
var deepClone = function(source, weak = new WeakMap) {
  if (source === null || typeof source !== "object" || typeof source === "function")
    return source;
  if (weak.has(source))
    return weak.get(source);
  if (Array.isArray(source)) {
    let copy = new Array(source.length);
    weak.set(source, copy);
    for (let i = 0;i < source.length; i++)
      copy[i] = deepClone(source[i], weak);
    return copy;
  }
  if (typeof source === "object") {
    let keys = Object.keys(source).concat(Object.getOwnPropertySymbols(source)), cloned = {};
    for (let key of keys)
      cloned[key] = deepClone(source[key], weak);
    return cloned;
  }
  return source;
};
var __create2 = Object.create;
var { getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require2 = import.meta.require;
var require_dist = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse4;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/, domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/, __toString = Object.prototype.toString, NullObject = (() => {
    let C = function() {
    };
    return C.prototype = Object.create(null), C;
  })();
  function parse4(str, options) {
    let obj = new NullObject, len = str.length;
    if (len < 2)
      return obj;
    let dec = options?.decode || decode2, index = 0;
    do {
      let eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      let colonIdx = str.indexOf(";", index), endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      let keyStartIdx = startIndex(str, index, eqIdx), keyEndIdx = endIndex(str, eqIdx, keyStartIdx), key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx), valEndIdx = endIndex(str, endIdx, valStartIdx), value26 = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value26;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max2) {
    do {
      let code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max2);
    return max2;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      let code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    let enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name))
      throw new TypeError(`argument name is invalid: ${name}`);
    let value26 = enc(val);
    if (!cookieValueRegExp.test(value26))
      throw new TypeError(`argument val is invalid: ${val}`);
    let str = name + "=" + value26;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge))
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain))
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path))
        throw new TypeError(`option path is invalid: ${options.path}`);
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly)
      str += "; HttpOnly";
    if (options.secure)
      str += "; Secure";
    if (options.partitioned)
      str += "; Partitioned";
    if (options.priority)
      switch (typeof options.priority === "string" ? options.priority.toLowerCase() : undefined) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    if (options.sameSite)
      switch (typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});
var require_fast_decode_uri_component = __commonJS2((exports, module) => {
  var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7];
  function decodeURIComponent2(uri2) {
    var percentPosition = uri2.indexOf("%");
    if (percentPosition === -1)
      return uri2;
    var length = uri2.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri2[percentPosition + 1], 4), low = hexCodeToInt(uri2[percentPosition + 2], 0), byte2 = high | low, type54 = UTF8_DATA[byte2];
      if (state = UTF8_DATA[256 + state + type54], codepoint = codepoint << 6 | byte2 & UTF8_DATA[364 + type54], state === UTF8_ACCEPT)
        decoded += uri2.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri2.indexOf("%", last);
      else if (state === UTF8_REJECT)
        return null;
      else {
        if (percentPosition += 3, percentPosition < length && uri2.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri2.slice(last);
  }
  var HEX = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});
var Y = (A, b) => {
  let v = b?.length ? {} : null;
  if (v)
    for (let K of b)
      v[K.part.charCodeAt(0)] = K;
  return { part: A, store: null, inert: v, params: null, wildcardStore: null };
};
var k = (A, b) => ({ ...A, part: b });
var T = (A) => ({ name: A, store: null, inert: null });

class _ {
  config;
  root = {};
  history = [];
  deferred = [];
  constructor(A = {}) {
    if (this.config = A, A.lazy)
      this.find = this.lazyFind;
  }
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /(\/:\w+\?)/g };
  lazyFind = (A, b) => {
    if (!this.config.lazy)
      return this.find;
    return this.build(), this.find(A, b);
  };
  build() {
    if (!this.config.lazy)
      return;
    for (let [A, b, v] of this.deferred)
      this.add(A, b, v, { lazy: false, ignoreHistory: true });
    this.deferred = [], this.find = (A, b) => {
      let v = this.root[A];
      if (!v)
        return null;
      return $(b, b.length, v, 0);
    };
  }
  add(A, b, v, { ignoreError: K = false, ignoreHistory: V = false, lazy: U = this.config.lazy } = {}) {
    if (U)
      return this.find = this.lazyFind, this.deferred.push([A, b, v]), v;
    if (typeof b !== "string")
      throw new TypeError("Route path must be a string");
    if (b === "")
      b = "/";
    else if (b[0] !== "/")
      b = `/${b}`;
    let J = b[b.length - 1] === "*", F = b.match(_.regex.optionalParams);
    if (F) {
      let S = b.replaceAll("?", "");
      this.add(A, S, v, { ignoreError: K, ignoreHistory: V, lazy: U });
      for (let D = 0;D < F.length; D++) {
        let B = b.replace(F[D], "");
        this.add(A, B, v, { ignoreError: true, ignoreHistory: V, lazy: U });
      }
      return v;
    }
    if (F)
      b = b.replaceAll("?", "");
    if (this.history.find(([S, D, B]) => S === A && D === b))
      return v;
    if (J || F && b.charCodeAt(b.length - 1) === 63)
      b = b.slice(0, -1);
    if (!V)
      this.history.push([A, b, v]);
    let G = b.split(_.regex.static), X = b.match(_.regex.params) || [];
    if (G[G.length - 1] === "")
      G.pop();
    let q;
    if (!this.root[A])
      q = this.root[A] = Y("/");
    else
      q = this.root[A];
    let O = 0;
    for (let S = 0;S < G.length; ++S) {
      let D = G[S];
      if (S > 0) {
        let B = X[O++].slice(1);
        if (q.params === null)
          q.params = T(B);
        else if (q.params.name !== B)
          if (K)
            return v;
          else
            throw new Error(`Cannot create route "${b}" with parameter "${B}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
        let Q = q.params;
        if (Q.inert === null) {
          q = Q.inert = Y(D);
          continue;
        }
        q = Q.inert;
      }
      for (let B = 0;; ) {
        if (B === D.length) {
          if (B < q.part.length) {
            let Q = k(q, q.part.slice(B));
            Object.assign(q, Y(D, [Q]));
          }
          break;
        }
        if (B === q.part.length) {
          if (q.inert === null)
            q.inert = {};
          let Q = q.inert[D.charCodeAt(B)];
          if (Q) {
            q = Q, D = D.slice(B), B = 0;
            continue;
          }
          let Z = Y(D.slice(B));
          q.inert[D.charCodeAt(B)] = Z, q = Z;
          break;
        }
        if (D[B] !== q.part[B]) {
          let Q = k(q, q.part.slice(B)), Z = Y(D.slice(B));
          Object.assign(q, Y(q.part.slice(0, B), [Q, Z])), q = Z;
          break;
        }
        ++B;
      }
    }
    if (O < X.length) {
      let D = X[O].slice(1);
      if (q.params === null)
        q.params = T(D);
      else if (q.params.name !== D)
        if (K)
          return v;
        else
          throw new Error(`Cannot create route "${b}" with parameter "${D}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
      if (q.params.store === null)
        q.params.store = v;
      return q.params.store;
    }
    if (J) {
      if (q.wildcardStore === null)
        q.wildcardStore = v;
      return q.wildcardStore;
    }
    if (q.store === null)
      q.store = v;
    return q.store;
  }
  find(A, b) {
    let v = this.root[A];
    if (!v)
      return null;
    return $(b, b.length, v, 0);
  }
}
var $ = (A, b, v, K) => {
  let V = v.part, U = V.length, J = K + U;
  if (U > 1) {
    if (J > b)
      return null;
    if (U < 15) {
      for (let F = 1, G = K + 1;F < U; ++F, ++G)
        if (V.charCodeAt(F) !== A.charCodeAt(G))
          return null;
    } else if (A.slice(K, J) !== V)
      return null;
  }
  if (J === b) {
    if (v.store !== null)
      return { store: v.store, params: {} };
    if (v.wildcardStore !== null)
      return { store: v.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (v.inert !== null) {
    let F = v.inert[A.charCodeAt(J)];
    if (F !== undefined) {
      let G = $(A, b, F, J);
      if (G !== null)
        return G;
    }
  }
  if (v.params !== null) {
    let { store: F, name: G, inert: X } = v.params, q = A.indexOf("/", J);
    if (q !== J) {
      if (q === -1 || q >= b) {
        if (F !== null) {
          let O = {};
          return O[G] = A.substring(J, b), { store: F, params: O };
        }
      } else if (X !== null) {
        let O = $(A, b, X, q);
        if (O !== null)
          return O.params[G] = A.substring(J, q), O;
      }
    }
  }
  if (v.wildcardStore !== null)
    return { store: v.wildcardStore, params: { "*": A.substring(J, b) } };
  return null;
};
var fullFormats = { date: date2, time: getTime(true), "date-time": getDateTime(true), "iso-time": getTime(false), "iso-date-time": getDateTime(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte, int32: { type: "number", validate: validateInt32 }, int64: { type: "number", validate: validateInt64 }, float: { type: "number", validate: validateNumber }, double: { type: "number", validate: validateNumber }, password: true, binary: true };
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var parseDateTimeEmptySpace = (str) => {
  if (str.charCodeAt(str.length - 6) === 32)
    return str.slice(0, -6) + "+" + str.slice(-5);
  return str;
};
var DATE_TIME_SEPARATOR = /t|\s/i;
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
var Z_ANCHOR = /[^\\]\\Z/;
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  exports_format.Set("date", (value26) => {
    let temp = parseDateTimeEmptySpace(value26).replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  exports_format.Set("date-time", (value26) => {
    let temp = value26.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      exports_format.Set(formatName, (value26) => formatValue.test(value26));
    else if (typeof formatValue === "function")
      exports_format.Set(formatName, formatValue);
  }
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value26) => !!value26 && !isNaN(+value26));
if (!exports_format.Has("integer"))
  exports_format.Set("integer", (value26) => !!value26 && Number.isInteger(+value26));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value26) => value26 === "true" || value26 === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value26) => {
    let start = value26.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value26.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value26), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value26) => {
    let start = value26.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value26.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value26), true;
    } catch {
      return false;
    }
  });
var isBun = typeof Bun !== "undefined";
var mime = { aac: "audio/aac", abw: "application/x-abiword", ai: "application/postscript", arc: "application/octet-stream", avi: "video/x-msvideo", azw: "application/vnd.amazon.ebook", bin: "application/octet-stream", bz: "application/x-bzip", bz2: "application/x-bzip2", csh: "application/x-csh", css: "text/css", csv: "text/csv", doc: "application/msword", dll: "application/octet-stream", eot: "application/vnd.ms-fontobject", epub: "application/epub+zip", gif: "image/gif", htm: "text/html", html: "text/html", ico: "image/x-icon", ics: "text/calendar", jar: "application/java-archive", jpeg: "image/jpeg", jpg: "image/jpeg", js: "application/javascript", json: "application/json", mid: "audio/midi", midi: "audio/midi", mp2: "audio/mpeg", mp3: "audio/mpeg", mp4: "video/mp4", mpa: "video/mpeg", mpe: "video/mpeg", mpeg: "video/mpeg", mpkg: "application/vnd.apple.installer+xml", odp: "application/vnd.oasis.opendocument.presentation", ods: "application/vnd.oasis.opendocument.spreadsheet", odt: "application/vnd.oasis.opendocument.text", oga: "audio/ogg", ogv: "video/ogg", ogx: "application/ogg", otf: "font/otf", png: "image/png", pdf: "application/pdf", ppt: "application/vnd.ms-powerpoint", rar: "application/x-rar-compressed", rtf: "application/rtf", sh: "application/x-sh", svg: "image/svg+xml", swf: "application/x-shockwave-flash", tar: "application/x-tar", tif: "image/tiff", tiff: "image/tiff", ts: "application/typescript", ttf: "font/ttf", txt: "text/plain", vsd: "application/vnd.visio", wav: "audio/x-wav", weba: "audio/webm", webm: "video/webm", webp: "image/webp", woff: "font/woff", woff2: "font/woff2", xhtml: "application/xhtml+xml", xls: "application/vnd.ms-excel", xlsx: "application/vnd.ms-excel", xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xml: "application/xml", xul: "application/vnd.mozilla.xul+xml", zip: "application/zip", "3gp": "video/3gpp", "3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp", "3gp2": "video/3gpp2", "3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2", "7z": "application/x-7z-compressed" };
var getFileExtension = (path) => {
  let index = path.lastIndexOf(".");
  if (index === -1)
    return "";
  return path.slice(index + 1);
};
var createReadStream;
var stat;

class ElysiaFile {
  path;
  value;
  stats;
  constructor(path) {
    this.path = path;
    if (isBun)
      this.value = Bun.file(path);
    else if (typeof window !== "undefined")
      console.warn("Browser environment does not support file");
    else if (!createReadStream || !stat)
      try {
        this.value = import("fs").then((fs) => {
          return createReadStream = fs.createReadStream, fs.createReadStream(path);
        }), this.stats = import("fs/promises").then((fs) => {
          return stat = fs.stat, fs.stat(path);
        });
      } catch {
      }
    else
      this.value = createReadStream(path), this.stats = stat(path);
  }
  get type() {
    return mime[getFileExtension(this.path)] || "application/octet-stream";
  }
  get length() {
    if (isBun)
      return this.value.size;
    return this.stats?.then((x) => x.size) ?? 0;
  }
}
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, options) => {
  let skipKeys = options?.skipKeys, override = options?.override ?? true;
  if (!isObject(target) || !isObject(source))
    return target;
  for (let [key, value26] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (!isObject(value26) || !(key in target) || isClass(value26)) {
      if (override || !(key in target))
        target[key] = value26;
      continue;
    }
    target[key] = mergeDeep(target[key], value26, { skipKeys, override });
  }
  return target;
};
var mergeCookie = (a, b) => {
  let v = mergeDeep(Object.assign({}, a), b, { skipKeys: ["properties"] });
  if (v.properties)
    delete v.properties;
  return v;
};
var mergeObjectArray = (a, b) => {
  if (!b)
    return a;
  let array3 = [], checksums = [];
  if (a) {
    if (!Array.isArray(a))
      a = [a];
    for (let item of a)
      if (array3.push(item), item.checksum)
        checksums.push(item.checksum);
  }
  if (b) {
    if (!Array.isArray(b))
      b = [b];
    for (let item of b)
      if (!checksums.includes(item.checksum))
        array3.push(item);
  }
  return array3;
};
var primitiveHooks = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a, b) => {
  let isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString);
  if (isRecordNumber(a) && isRecordNumber(b))
    return Object.assign(a, b);
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({ 200: a }, b);
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  if (!a && !b)
    return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response) };
};
var mergeHook = (a, b) => {
  if (!Object.values(b).find((x) => x !== undefined && x !== null))
    return { ...a };
  let hook = { ...a, ...b, body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response), type: a?.type || b?.type, detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}), parse: mergeObjectArray(a?.parse, b?.parse), transform: mergeObjectArray(a?.transform, b?.transform), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a?.resolve, "resolve"), a?.beforeHandle), mergeObjectArray(fnToContainer(b.resolve, "resolve"), b?.beforeHandle)), afterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle), mapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse), afterResponse: mergeObjectArray(a?.afterResponse, b?.afterResponse), trace: mergeObjectArray(a?.trace, b?.trace), error: mergeObjectArray(a?.error, b?.error) };
  if (hook.resolve)
    delete hook.resolve;
  return hook;
};
var lifeCycleToArray = (a) => {
  if (a.parse && !Array.isArray(a.parse))
    a.parse = [a.parse];
  if (a.transform && !Array.isArray(a.transform))
    a.transform = [a.transform];
  if (a.afterHandle && !Array.isArray(a.afterHandle))
    a.afterHandle = [a.afterHandle];
  if (a.mapResponse && !Array.isArray(a.mapResponse))
    a.mapResponse = [a.mapResponse];
  if (a.afterResponse && !Array.isArray(a.afterResponse))
    a.afterResponse = [a.afterResponse];
  if (a.trace && !Array.isArray(a.trace))
    a.trace = [a.trace];
  if (a.error && !Array.isArray(a.error))
    a.error = [a.error];
  let beforeHandle = [];
  if (a.resolve)
    beforeHandle = fnToContainer(Array.isArray(a.resolve) ? a.resolve : [a.resolve], "resolve"), delete a.resolve;
  if (a.beforeHandle)
    if (beforeHandle.length)
      beforeHandle = beforeHandle.concat(Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle]);
    else
      beforeHandle = Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle];
  if (beforeHandle.length)
    a.beforeHandle = beforeHandle;
  return a;
};
var isBun2 = typeof Bun !== "undefined";
var hasBunHash = isBun2 && typeof Bun.hash === "function";
var checksum = (s) => {
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
  return h = h ^ h >>> 9;
};
var injectChecksum = (checksum2, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    let fn = x;
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  let fns = [...x];
  for (let fn of fns) {
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
  return { start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)), request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)), parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)), transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum2, mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))), afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)), mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)), afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)), trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)), error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)), stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)) };
};
var asHookType = (fn, inject, { skipIfHasType = false }) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (let x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array3 = [];
  for (let x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array3.push({ ...x });
        break;
    }
  return array3;
};
var filterGlobalHook = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal(hook?.parse), transform: filterGlobal(hook?.transform), beforeHandle: filterGlobal(hook?.beforeHandle), afterHandle: filterGlobal(hook?.afterHandle), mapResponse: filterGlobal(hook?.mapResponse), afterResponse: filterGlobal(hook?.afterResponse), error: filterGlobal(hook?.error), trace: filterGlobal(hook?.trace) };
};
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k2, v]) => [v, k2]));
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret) === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, manage) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (let [key, value26] of Object.entries(property)) {
    if (primitiveHookMap[key] || !(key in extension))
      continue;
    let v = extension[key];
    if (typeof v === "function") {
      let hook = v(value26);
      if (typeof hook === "object")
        for (let [k2, v2] of Object.entries(hook))
          manage(k2)({ fn: v2 });
    }
    delete property[key];
  }
};
var createMacroManager = ({ globalHook, localHook }) => (stackName) => (type54, fn) => {
  if (typeof type54 === "function")
    type54 = { fn: type54 };
  if (stackName === "resolve")
    type54 = { ...type54, subType: "resolve" };
  if (!localHook[stackName])
    localHook[stackName] = [];
  if (typeof localHook[stackName] === "function")
    localHook[stackName] = [localHook[stackName]];
  if (!Array.isArray(localHook[stackName]))
    localHook[stackName] = [localHook[stackName]];
  if ("fn" in type54 || Array.isArray(type54)) {
    if (Array.isArray(type54))
      localHook[stackName] = localHook[stackName].concat(type54);
    else
      localHook[stackName].push(type54);
    return;
  }
  let { insert = "after", stack = "local" } = type54;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global")
    if (!Array.isArray(fn))
      if (insert === "before")
        globalHook[stackName].unshift(fn);
      else
        globalHook[stackName].push(fn);
    else if (insert === "before")
      globalHook[stackName] = fn.concat(globalHook[stackName]);
    else
      globalHook[stackName] = globalHook[stackName].concat(fn);
  else if (!Array.isArray(fn))
    if (insert === "before")
      localHook[stackName].unshift(fn);
    else
      localHook[stackName].push(fn);
  else if (insert === "before")
    localHook[stackName] = fn.concat(localHook[stackName]);
  else
    localHook[stackName] = localHook[stackName].concat(fn);
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number5 = Number(message);
    if (Number.isNaN(number5) || number5.toString() !== message)
      return null;
    return number5;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  onError;
  onFinally;
  root = null;
  promises = [];
  constructor(onError = console.error, onFinally = () => {
  }) {
    this.onError = onError;
    this.onFinally = onFinally;
  }
  get size() {
    return this.promises.length;
  }
  add(promise2) {
    if (this.promises.push(promise2), this.root ||= this.drain(), this.promises.length === 1)
      this.then(this.onFinally);
    return promise2;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error23) {
        this.onError(error23);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function" || typeof fn === "string")
      return subType ? { fn, subType } : { fn };
    else if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x of fn)
    if (typeof x === "function" || typeof x === "string")
      fns.push(subType ? { fn: x, subType } : { fn: x });
    else if ("fn" in x)
      fns.push(x);
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  if (a.start)
    a.start = fnToContainer(a.start);
  if (a.request)
    a.request = fnToContainer(a.request);
  if (a.parse)
    a.parse = fnToContainer(a.parse);
  if (a.transform)
    a.transform = fnToContainer(a.transform);
  if (a.beforeHandle)
    a.beforeHandle = fnToContainer(a.beforeHandle);
  if (a.afterHandle)
    a.afterHandle = fnToContainer(a.afterHandle);
  if (a.mapResponse)
    a.mapResponse = fnToContainer(a.mapResponse);
  if (a.afterResponse)
    a.afterResponse = fnToContainer(a.afterResponse);
  if (a.trace)
    a.trace = fnToContainer(a.trace);
  if (a.error)
    a.error = fnToContainer(a.error);
  if (a.stop)
    a.stop = fnToContainer(a.stop);
  return a;
};
var lifeCycleToFn = (a) => {
  if (a.start?.map)
    a.start = a.start.map((x) => x.fn);
  if (a.request?.map)
    a.request = a.request.map((x) => x.fn);
  if (a.parse?.map)
    a.parse = a.parse.map((x) => x.fn);
  if (a.transform?.map)
    a.transform = a.transform.map((x) => x.fn);
  if (a.beforeHandle?.map)
    a.beforeHandle = a.beforeHandle.map((x) => x.fn);
  if (a.afterHandle?.map)
    a.afterHandle = a.afterHandle.map((x) => x.fn);
  if (a.mapResponse?.map)
    a.mapResponse = a.mapResponse.map((x) => x.fn);
  if (a.afterResponse?.map)
    a.afterResponse = a.afterResponse.map((x) => x.fn);
  if (a.trace?.map)
    a.trace = a.trace.map((x) => x.fn);
  else
    a.trace = [];
  if (a.error?.map)
    a.error = a.error.map((x) => x.fn);
  if (a.stop?.map)
    a.stop = a.stop.map((x) => x.fn);
  return a;
};
var cloneInference = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server, path: inference.path, route: inference.route, url: inference.url });
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
  let formData = new FormData;
  if (formData[ELYSIA_FORM_DATA] = {}, items)
    for (let [key, value26] of Object.entries(items)) {
      if (Array.isArray(value26)) {
        formData[ELYSIA_FORM_DATA][key] = [];
        for (let v of value26) {
          if (value26 instanceof File)
            formData.append(key, value26, value26.name);
          else if (value26 instanceof ElysiaFile)
            formData.append(key, value26.value, value26.value?.name);
          else
            formData.append(key, value26);
          formData[ELYSIA_FORM_DATA][key].push(value26);
        }
        continue;
      }
      if (value26 instanceof File)
        formData.append(key, value26, value26.name);
      else if (value26 instanceof ElysiaFile)
        formData.append(key, value26.value, value26.value?.name);
      else
        formData.append(key, value26);
      formData[ELYSIA_FORM_DATA][key] = value26;
    }
  return formData;
};
var randomId = () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum = (array3) => {
  if (!array3.length)
    return [];
  let hashes = [];
  for (let i = 0;i < array3.length; i++) {
    let item = array3[i];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array3.splice(i, 1), i--;
      hashes.push(item.checksum);
    }
  }
  return array3;
};
var promoteEvent = (events, as = "scoped") => {
  if (!events)
    return;
  if (as === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let _2 in obj)
    return true;
  return false;
};
var encodePath = (path, { dynamic = false } = {}) => {
  let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
  if (dynamic)
    encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
  return encoded;
};
var supportPerMethodInlineHandler = (() => {
  if (typeof Bun === "undefined")
    return true;
  let semver = Bun.version.split(".");
  if (+semver[0] < 1 || +semver[1] < 2 || +semver[2] < 14)
    return false;
  return true;
})();
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";

class ElysiaCustomStatusResponse {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    this.code = StatusMap[code] ?? code, this.response = res;
  }
}
var status = (code, response) => new ElysiaCustomStatusResponse(code, response);
class NotFoundError extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError2 extends Error {
  code = "PARSE";
  status = 400;
  constructor(cause) {
    super("Bad Request", { cause });
  }
}

class InvalidCookieSignature extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError = (error23) => {
  if (!error23)
    return { summary: undefined };
  let { message, path, value: value26, type: type54 } = error23, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type54) {
    case 42:
      return { ...error23, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error23, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error23, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}` };
    case 54:
      return { ...error23, summary: `${message.slice(0, 9).trim()} property '${property}' to be ${message.slice(8).trim()} but found: ${value26}` };
    case 62:
      let union19 = error23.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return { ...error23, summary: isRoot ? `Value should be one of ${union19}` : `Property '${property}' should be one of: ${union19}` };
    default:
      return { summary: message, ...error23 };
  }
};

class InvalidFileType extends Error {
  property;
  expected;
  message;
  code = "INVALID_FILE_TYPE";
  status = 422;
  constructor(property, expected, message = `"${property}" has invalid file type`) {
    super(message);
    this.property = property;
    this.expected = expected;
    this.message = message;
    Object.setPrototypeOf(this, InvalidFileType.prototype);
  }
  toResponse(headers) {
    if (isProduction)
      return new Response(JSON.stringify({ type: "validation", on: "body" }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
    return new Response(JSON.stringify({ type: "validation", on: "body", summary: "Invalid file type", message: this.message, property: this.property, expected: this.expected }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
  }
}

class ValidationError extends Error {
  type;
  validator;
  value;
  code = "VALIDATION";
  status = 422;
  constructor(type54, validator, value26, errors6) {
    if (value26 && typeof value26 === "object" && value26 instanceof ElysiaCustomStatusResponse)
      value26 = value26.response;
    let error23 = errors6?.First() || (isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value26).First() : exports_value2.Errors(validator, value26).First()), customError = error23?.schema?.message || error23?.schema?.error !== undefined ? typeof error23.schema.error === "function" ? error23.schema.error({ type: type54, validator, value: value26, get errors() {
      return [...validator.Errors(value26)].map(mapValueError);
    } }) : error23.schema.error : undefined, accessor = error23?.path || "root", message = "";
    if (customError !== undefined)
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    else if (isProduction)
      message = JSON.stringify({ type: "validation", on: type54, summary: mapValueError(error23).summary, message: error23?.message, found: value26 });
    else {
      let schema = validator?.schema ?? validator, errors22 = "Errors" in validator ? [...validator.Errors(value26)].map(mapValueError) : [...exports_value2.Errors(validator, value26)].map(mapValueError), expected;
      try {
        expected = exports_value2.Create(schema);
      } catch (error32) {
        expected = { type: "Could not create expected value", message: error32?.message, error: error32 };
      }
      message = JSON.stringify({ type: "validation", on: type54, summary: mapValueError(error23).summary, property: accessor, message: error23?.message, expected, found: value26, errors: errors22 }, null, 2);
    }
    super(message);
    this.type = type54;
    this.validator = validator;
    this.value = value26;
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
}
var tryParse = (v, schema) => {
  try {
    return JSON.parse(v);
  } catch {
    throw new ValidationError("property", schema, v);
  }
};
var compile = (schema) => {
  try {
    let compiler4 = TypeCompiler.Compile(schema);
    return compiler4.Create = () => exports_value2.Create(schema), compiler4.Error = (v) => new ValidationError("property", schema, v, compiler4.Errors(v)), compiler4;
  } catch {
    return { Check: (v) => exports_value2.Check(schema, v), CheckThrow: (v) => {
      if (!exports_value2.Check(schema, v))
        throw new ValidationError("property", schema, v, exports_value2.Errors(schema, v));
    }, Decode: (v) => exports_value2.Decode(schema, v), Create: () => exports_value2.Create(schema), Error: (v) => new ValidationError("property", schema, v, exports_value2.Errors(schema, v)) };
  }
};
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var checkFileExtension = (type54, extension) => {
  if (type54.startsWith(extension))
    return true;
  return extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type54.startsWith(extension.slice(0, -1));
};
var _fileTypeFromBlobWarn = false;
var warnIfFileTypeIsNotInstalled = () => {
  if (!_fileTypeFromBlobWarn)
    console.warn("[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension."), _fileTypeFromBlobWarn = true;
};
var loadFileType = async () => Promise.resolve().then(() => (init_file_type(), exports_file_type)).then((x) => {
  return _fileTypeFromBlob = x.fileTypeFromBlob, _fileTypeFromBlob;
}).catch(warnIfFileTypeIsNotInstalled);
var _fileTypeFromBlob;
var fileTypeFromBlob2 = (file2) => {
  if (_fileTypeFromBlob)
    return _fileTypeFromBlob(file2);
  return loadFileType().then((mod) => {
    if (mod)
      return mod(file2);
  });
};
var validateFileExtension = async (file2, extension, name = file2?.name ?? "") => {
  if (Array.isArray(file2))
    return await Promise.all(file2.map((f) => validateFileExtension(f, extension, name))), true;
  if (!file2)
    return false;
  let result = await fileTypeFromBlob2(file2);
  if (!result)
    throw new InvalidFileType(name, extension);
  if (typeof extension === "string") {
    if (!checkFileExtension(result.mime, extension))
      throw new InvalidFileType(name, extension);
  }
  for (let i = 0;i < extension.length; i++)
    if (checkFileExtension(result.mime, extension[i]))
      return true;
  throw new InvalidFileType(name, extension);
};
var validateFile = (options, value26) => {
  if (value26 instanceof ElysiaFile)
    return true;
  if (!(value26 instanceof Blob))
    return false;
  if (options.minSize && value26.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value26.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension) {
    if (typeof options.extension === "string")
      return checkFileExtension(value26.type, options.extension);
    for (let i = 0;i < options.extension.length; i++)
      if (checkFileExtension(value26.type, options.extension[i]))
        return true;
    return false;
  }
  return true;
};
var t = Object.assign({}, Type);
createType("UnionEnum", (schema, value26) => (typeof value26 === "number" || typeof value26 === "string" || value26 === null) && schema.enum.includes(value26));
var internalFiles = createType("Files", (options, value26) => {
  if (!Array.isArray(value26))
    return validateFile(options, value26);
  if (options.minItems && value26.length < options.minItems)
    return false;
  if (options.maxItems && value26.length > options.maxItems)
    return false;
  for (let i = 0;i < value26.length; i++)
    if (!validateFile(options, value26[i]))
      return false;
  return true;
});
var internalFormData = createType("ElysiaForm", ({ compiler: compiler4, ...schema }, value26) => {
  if (!(value26 instanceof FormData))
    return false;
  if (compiler4) {
    if (!(ELYSIA_FORM_DATA in value26))
      throw new ValidationError("property", schema, value26);
    if (!compiler4.Check(value26[ELYSIA_FORM_DATA]))
      throw compiler4.Error(value26[ELYSIA_FORM_DATA]);
  }
  return true;
});
var ElysiaType = { String: (property) => Type.String(property), Numeric: (property) => {
  let schema = Type.Number(property), compiler4 = compile(schema);
  return t.Transform(t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property)).Decode((value26) => {
    let number5 = +value26;
    if (isNaN(number5))
      return value26;
    if (property && !compiler4.Check(number5))
      throw compiler4.Error(value26);
    return number5;
  }).Encode((value26) => value26);
}, Integer: (property) => {
  let schema = Type.Integer(property), compiler4 = compile(schema);
  return t.Transform(t.Union([t.String({ format: "integer", default: 0 }), Type.Integer(property)], property)).Decode((value26) => {
    let number5 = +value26;
    if (!compiler4.Check(number5))
      throw compiler4.Error(number5);
    return number5;
  }).Encode((value26) => value26);
}, Date: (property) => {
  let schema = Type.Date(property), compiler4 = compile(schema), _default = property?.default ? new Date(property.default) : undefined;
  return t.Transform(t.Union([Type.Date(property), t.String({ format: "date-time", default: _default?.toISOString() }), t.String({ format: "date", default: _default?.toISOString() }), t.Number({ default: _default?.getTime() })], property)).Decode((value26) => {
    if (typeof value26 === "number") {
      let date3 = new Date(value26);
      if (!compiler4.Check(date3))
        throw compiler4.Error(date3);
      return date3;
    }
    if (value26 instanceof Date)
      return value26;
    let date22 = new Date(parseDateTimeEmptySpace(value26));
    if (!date22 || isNaN(date22.getTime()))
      throw new ValidationError("property", schema, date22);
    if (!compiler4.Check(date22))
      throw compiler4.Error(date22);
    return date22;
  }).Encode((value26) => value26.toISOString());
}, BooleanString: (property) => {
  let schema = Type.Boolean(property), compiler4 = compile(schema);
  return t.Transform(t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property)).Decode((value26) => {
    if (typeof value26 === "string")
      return value26 === "true";
    if (value26 !== undefined && !compiler4.Check(value26))
      throw compiler4.Error(value26);
    return value26;
  }).Encode((value26) => value26);
}, ObjectString: (properties, options) => {
  let schema = t.Object(properties, options), compiler4 = compile(schema), defaultValue = JSON.stringify(compiler4.Create());
  return t.Transform(t.Union([t.String({ format: "ObjectString", default: defaultValue }), schema])).Decode((value26) => {
    if (typeof value26 === "string") {
      if (value26.charCodeAt(0) !== 123)
        throw new ValidationError("property", schema, value26);
      if (!compiler4.Check(value26 = tryParse(value26, schema)))
        throw compiler4.Error(value26);
      return compiler4.Decode(value26);
    }
    return value26;
  }).Encode((value26) => {
    let original;
    if (typeof value26 === "string")
      value26 = tryParse(original = value26, schema);
    if (!compiler4.Check(value26))
      throw compiler4.Error(value26);
    return original ?? JSON.stringify(value26);
  });
}, ArrayString: (children = t.String(), options) => {
  let schema = t.Array(children, options), compiler4 = compile(schema), decode2 = (value26, isProperty = false) => {
    if (value26.charCodeAt(0) === 91) {
      if (!compiler4.Check(value26 = tryParse(value26, schema)))
        throw compiler4.Error(value26);
      return compiler4.Decode(value26);
    }
    if (value26.indexOf(",") !== -1) {
      if (!compiler4.Check(value26))
        throw compiler4.Error(value26);
      return compiler4.Decode(value26);
    }
    if (isProperty)
      return value26;
    throw new ValidationError("property", schema, value26);
  };
  return t.Transform(t.Union([t.String({ format: "ArrayString", default: options?.default }), schema])).Decode((value26) => {
    if (Array.isArray(value26)) {
      let values = [];
      for (let i = 0;i < value26.length; i++) {
        let v = value26[i];
        if (typeof v === "string") {
          let t2 = decode2(v, true);
          if (Array.isArray(t2))
            values = values.concat(t2);
          else
            values.push(t2);
          continue;
        }
        values.push(v);
      }
      return values;
    }
    if (typeof value26 === "string")
      return decode2(value26);
    return value26;
  }).Encode((value26) => {
    let original;
    if (typeof value26 === "string")
      value26 = tryParse(original = value26, schema);
    if (!compiler4.Check(value26))
      throw new ValidationError("property", schema, value26);
    return original ?? JSON.stringify(value26);
  });
}, File: createType("File", validateFile), Files: (options = {}) => t.Transform(internalFiles(options)).Decode((value26) => {
  if (Array.isArray(value26))
    return value26;
  return [value26];
}).Encode((value26) => value26), Nullable: (schema, options) => t.Union([schema, t.Null()], options), MaybeEmpty: (schema, options) => t.Union([schema, t.Null(), t.Undefined()], options), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign, ...options } = {}) => {
  let v = t.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign }, v;
}, UnionEnum: (values, options = {}) => {
  let type54 = values.every((value26) => typeof value26 === "string") ? { type: "string" } : values.every((value26) => typeof value26 === "number") ? { type: "number" } : values.every((value26) => value26 === null) ? { type: "null" } : {};
  if (values.some((x) => typeof x === "object" && x !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: values[0], ...options, [Kind]: "UnionEnum", ...type54, enum: values };
}, NoValidate: (v, enabled = true) => {
  return v.noValidate = enabled, v;
}, Form: (v, options = {}) => {
  let schema = t.Object(v, { default: form({}), ...options }), compiler4 = compile(schema);
  return t.Union([schema, internalFormData({ compiler: compiler4 })]);
} };
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
};
t.Files = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
};
t.Nullable = (schema) => ElysiaType.Nullable(schema);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
t.NoValidate = ElysiaType.NoValidate;
t.Form = ElysiaType.Form;
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    if (index = code.indexOf("=>"), index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
  }
  let x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    if (parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  if (parameter = removeColonAlias(parameter), parameter)
    parameters = parameters.concat(parameter.split(","));
  let parameterMap = Object.create(null);
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      parameterMap[p] = true;
      continue;
    }
    for (let q of p.split(","))
      parameterMap[q.trim()] = true;
  }
  return { hasParenthesis, parameters: parameterMap };
};
var findParameterReference = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (parameters.query)
    inference.query = true;
  if (parameters.headers)
    inference.headers = true;
  if (parameters.body)
    inference.body = true;
  if (parameters.cookie)
    inference.cookie = true;
  if (parameters.set)
    inference.set = true;
  if (parameters.server)
    inference.server = true;
  if (parameters.route)
    inference.route = true;
  if (parameters.url)
    inference.url = true;
  if (parameters.path)
    inference.path = true;
  if (hasParenthesis)
    return `{ ${Object.keys(parameters).join(", ")} }`;
  return Object.keys(parameters).join(", ");
};
var findEndIndex = (type54, content, index) => {
  let regex2 = new RegExp(`${type54.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\n\\t,; ]`);
  if (index !== undefined)
    regex2.lastIndex = index;
  let match = regex2.exec(content);
  return match ? match.index : -1;
};
var findAlias = (type54, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex(" = " + type54, content);
    if (index === -1)
      index = findEndIndex("=" + type54, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type54);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type54);
      if (lastIndex + 3 + type54.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end))), content = content.slice(index + 3 + type54.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type54.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.indexOf("...") !== -1)
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type54, alias) => new RegExp(`${alias}\\.(${type54})|${alias}\\["${type54}"\\]|${alias}\\['${type54}'\\]`).test(code);
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters = retrieveRootParamters(alias).parameters;
      if (parameters.query)
        inference.query = true;
      if (parameters.headers)
        inference.headers = true;
      if (parameters.body)
        inference.body = true;
      if (parameters.cookie)
        inference.cookie = true;
      if (parameters.set)
        inference.set = true;
      if (parameters.server)
        inference.server = true;
      if (parameters.url)
        inference.url = true;
      if (parameters.route)
        inference.route = true;
      if (parameters.path)
        inference.path = true;
      continue;
    }
    if (!inference.query && (access("query", alias) || code.includes("return " + alias) || code.includes("return " + alias + ".query")))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (!inference.route && access("route", alias))
      inference.route = true;
    if (!inference.url && access("url", alias))
      inference.url = true;
    if (!inference.path && access("path", alias))
      inference.path = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.route && inference.url && inference.path)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`\\w\\((.*?)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.url = true, inference.route = true, inference.path = true, true;
    return false;
  } catch (error23) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var pendingGC;
var caches = {};
var clearSucroseCache = (delay = 0) => {
  if (pendingGC)
    clearTimeout(pendingGC);
  pendingGC = setTimeout(() => {
    if (caches = {}, pendingGC = undefined, isBun)
      Bun.gc(false);
  }, delay);
};
var mergeInference = (a, b) => {
  return { body: a.body || b.body, cookie: a.cookie || b.cookie, headers: a.headers || b.headers, query: a.query || b.query, set: a.set || b.set, server: a.server || b.server, url: a.url || b.url, route: a.route || b.route, path: a.path || b.path };
};
var sucrose = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }) => {
  let events = [];
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  for (let i = 0;i < events.length; i++) {
    let e = events[i];
    if (!e)
      continue;
    let event = typeof e === "object" ? e.fn : e;
    if (typeof event !== "function")
      continue;
    let content = event.toString(), key = checksum(content), cachedInference = caches[key];
    if (cachedInference) {
      inference = mergeInference(inference, cachedInference);
      continue;
    }
    let fnInference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }, [parameter, body] = separateFunction(content), rootParameters = findParameterReference(parameter, fnInference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body.slice(1, -1));
      aliases.splice(0, -1, mainParameter);
      let code = body;
      if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
        code = code.slice(1, -1);
      if (!isContextPassToFunction(mainParameter, code, fnInference))
        inferBodyReference(code, aliases, fnInference);
      if (!fnInference.query && code.includes("return " + mainParameter + ".query"))
        fnInference.query = true;
    }
    if (!caches[key])
      caches[key] = fnInference;
    if (inference = mergeInference(inference, fnInference), inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.url && inference.route && inference.path)
      break;
  }
  return inference;
};
var import_cookie = __toESM2(require_dist(), 1);
var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component(), 1);

class Cookie {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value26) {
    this.setCookie.value = value26;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config) {
    return this.setCookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config), this;
  }
  set(config) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config === "function" ? config(this.cookie) : config), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, { get(_2, key) {
    if (key in store)
      return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie(key, set2.cookie, Object.assign({}, initial));
  } });
};
var parseCookie = async (set2, cookieString, { secrets, sign, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    if (v === undefined)
      continue;
    let value26 = import_fast_decode_uri_component.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value26, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value26 = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          let temp = await unsignCookie(value26, secrets[i]);
          if (temp !== false) {
            decoded = true, value26 = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = { value: value26 };
  }
  return createCookieJar(set2, jar, initial);
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set2 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value26 = property.value;
    if (value26 === undefined || value26 === null)
      continue;
    set2.push(import_cookie.serialize(key, typeof value26 === "object" ? JSON.stringify(value26) : value26 + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var handleFile = (response, set2) => {
  if (!isBun && response instanceof Promise)
    return response.then((res) => handleFile(res, set2));
  let size = response.size;
  if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        let setHeaders = { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" };
        if (hasHeaderShorthand)
          setHeaders = set2.headers.toJSON();
        else {
          setHeaders = {};
          for (let [key, value26] of set2.headers.entries())
            if (key in set2.headers)
              setHeaders[key] = value26;
        }
        return new Response(response, { status: set2.status, headers: setHeaders });
      }
      if (isNotEmpty(set2.headers))
        return new Response(response, { status: set2.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" }, set2.headers) });
    }
    return new Response(response, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" } });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    let index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var responseToSetHeaders = (response, set2) => {
  if (set2?.headers) {
    if (response) {
      if (hasHeaderShorthand)
        Object.assign(set2.headers, response.headers.toJSON());
      else
        for (let [key, value26] of response.headers.entries())
          if (key in set2.headers)
            set2.headers[key] = value26;
    }
    if (set2.status === 200)
      set2.status = response.status;
    if (set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  if (!response)
    return { headers: {}, status: set2?.status ?? 200 };
  if (hasHeaderShorthand) {
    if (set2 = { headers: response.headers.toJSON(), status: set2?.status ?? 200 }, set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  set2 = { headers: {}, status: set2?.status ?? 200 };
  for (let [key, value26] of response.headers.entries()) {
    if (key === "content-encoding")
      continue;
    if (key in set2.headers)
      set2.headers[key] = value26;
  }
  return set2;
};
var createStreamHandler = ({ mapResponse, mapCompactResponse }) => async (generator, set2, request) => {
  let init = generator.next();
  if (init instanceof Promise)
    init = await init;
  if (typeof init?.done === "undefined" || init?.done) {
    if (set2)
      return mapResponse(init.value, set2, request);
    return mapCompactResponse(init.value, request);
  }
  let contentType = init.value && typeof init.value?.stream ? "text/event-stream" : init.value && typeof init.value === "object" ? "application/json" : "text/plain";
  if (set2?.headers) {
    if (!set2.headers["transfer-encoding"])
      set2.headers["transfer-encoding"] = "chunked";
    if (!set2.headers["content-type"])
      set2.headers["content-type"] = contentType;
    if (!set2.headers["cache-control"])
      set2.headers["cache-control"] = "no-cache";
  } else
    set2 = { status: 200, headers: { "content-type": contentType, "transfer-encoding": "chunked", "cache-control": "no-cache", connection: "keep-alive" } };
  return new Response(new ReadableStream({ async start(controller) {
    let end = false;
    if (request?.signal?.addEventListener("abort", () => {
      end = true;
      try {
        controller.close();
      } catch {
      }
    }), init.value !== undefined && init.value !== null)
      if (init.value.toStream)
        controller.enqueue(init.value.toStream());
      else if (typeof init.value === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(Buffer.from(init.value.toString()));
        }
      else
        controller.enqueue(Buffer.from(init.value.toString()));
    for await (let chunk of generator) {
      if (end)
        break;
      if (chunk === undefined || chunk === null)
        continue;
      if (chunk.toStream)
        controller.enqueue(chunk.toStream());
      else if (typeof chunk === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(chunk)));
        } catch {
          controller.enqueue(Buffer.from(chunk.toString()));
        }
      else
        controller.enqueue(Buffer.from(chunk.toString()));
      await new Promise((resolve) => setTimeout(() => resolve(), 0));
    }
    try {
      controller.close();
    } catch {
    }
  } }), set2);
};
var handleSet = (set2) => {
  if (typeof set2.status === "string")
    set2.status = StatusMap[set2.status];
  if (set2.cookie && isNotEmpty(set2.cookie)) {
    let cookie = serializeCookie(set2.cookie);
    if (cookie)
      set2.headers["set-cookie"] = cookie;
  }
  if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
    set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
};
var createResponseHandler = (handler) => {
  let handleStream = createStreamHandler(handler);
  return (response, set2, request) => {
    let isCookieSet = false;
    if (set2.headers instanceof Headers)
      for (let key of set2.headers.keys())
        if (key === "set-cookie") {
          if (isCookieSet)
            continue;
          isCookieSet = true;
          for (let cookie of set2.headers.getSetCookie())
            response.headers.append("set-cookie", cookie);
        } else
          response.headers.append(key, set2.headers?.get(key) ?? "");
    else
      for (let key in set2.headers)
        response.headers.append(key, set2.headers[key]);
    let status2 = set2.status ?? 200;
    if (response.status !== status2 && status2 !== 200 && (response.status <= 300 || response.status > 400))
      return response.text().then((value26) => {
        let newResponse = new Response(value26, { headers: response.headers, status: set2.status });
        if (!newResponse.headers.has("content-length") && newResponse.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(newResponse), responseToSetHeaders(newResponse, set2), request);
        return newResponse;
      });
    if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
      return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
    return response;
  };
};
var mapResponse = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2, request));
      case "Function":
        return mapResponse(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse(x, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (response instanceof Response && !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
    return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream(response, set2, request);
  return mapCompactResponse(response, request);
};
var mapEarlyResponse = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Promise":
        return response.then((x) => mapEarlyResponse(x, set2));
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case "ReadableStream":
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), responseToSetHeaders(response), request);
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse(x, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: { "Content-Type": "text/plain" } });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleFile(response.value);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, { status: response.code, headers: {} });
    case "ReadableStream":
      return request?.signal?.addEventListener("abort", { handleEvent() {
        if (request?.signal && !request?.signal?.aborted)
          response.cancel();
      } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      if (response.headers.get("transfer-encoding") === "chunked")
        return handleStream(streamResponse(response), responseToSetHeaders(response), request);
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x) => mapCompactResponse(x, request));
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse(x, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function")
        return handleStream(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse = (error23, set2) => new Response(JSON.stringify({ name: error23?.name, message: error23?.message, cause: error23?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return response.clone.bind(response);
};
var handleResponse = createResponseHandler({ mapResponse, mapCompactResponse });
var handleStream = createStreamHandler({ mapResponse, mapCompactResponse });
var WebStandardAdapter = { name: "web-standard", isWebStandard: true, handler: { mapResponse, mapEarlyResponse, mapCompactResponse, createStaticHandler }, composeHandler: { mapResponseContext: "c.request", preferWebstandardHeaders: true, headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`, parser: { json(isOptional) {
  if (isOptional)
    return `try{c.body=await c.request.json()}catch{}
`;
  return `c.body=await c.request.json()
`;
}, text() {
  return `c.body=await c.request.text()
`;
}, urlencoded() {
  return `c.body=parseQuery(await c.request.text())
`;
}, arrayBuffer() {
  return `c.body=await c.request.arrayBuffer()
`;
}, formData(isOptional) {
  let fnLiteral = `
c.body={}
`;
  if (isOptional)
    fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
  else
    fnLiteral += `const form=await c.request.formData()
`;
  return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
} } }, composeGeneralHandler: { parameters: "r", createContext(app) {
  let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.decorator))
    decoratorsLiteral += `,'${key}':decorator['${key}']`;
  let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = !!app.event.trace?.length;
  if (fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?',s+1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace)
    fnLiteral += `const id=randomId()
`;
  if (fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,error:status,status,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({},app.setHeaders)" : "Object.create(null)", fnLiteral += ",status:200}", app.inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  return fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
}, error404(hasEventHook, hasErrorHook) {
  let findDynamicRoute = "if(route===null)return ";
  if (hasErrorHook)
    findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
  else
    findDynamicRoute += hasEventHook ? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "error404.clone()";
  return { declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`, code: findDynamicRoute };
} }, composeError: { mapResponseContext: "", validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})", unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})" }, listen() {
  return () => {
    throw new Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
  };
} };
var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM2(require_fast_decode_uri_component(), 1);
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise: promise2, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error23, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise2;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i = 0;i < (process2.total ?? 0); i++) {
      let { promise: promise22, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error32, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise22;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end2, error: error32, index: i, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end2;
        } };
        resolve2(result2);
        for (let i2 = 0;i2 < callbacks2.length; i2++)
          callbacks2[i2](result2);
        return (error42 = null) => {
          let end3 = performance.now();
          if (error42)
            groupError = error42;
          let detail = { end: end3, error: error42, get elapsed() {
            return end3 - process3.begin;
          } };
          for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
            callbacksEnd2[i2](detail);
          resolveEnd2(end3), resolveError2(error42);
        };
      });
    }
    let result = { ...process2, end, error: error23, onEvent(callback) {
      for (let i = 0;i < processes.length; i++)
        processes[i](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end;
    } };
    resolve(result);
    for (let i = 0;i < callbacks.length; i++)
      callbacks[i](result);
    return { resolveChild: resolvers, resolve(error32 = null) {
      let end2 = performance.now();
      if (!error32 && groupError)
        error32 = groupError;
      let detail = { end: end2, error: error32, get elapsed() {
        return end2 - process2.begin;
      } };
      for (let i = 0;i < callbacksEnd.length; i++)
        callbacksEnd[i](detail);
      resolveEnd(end2), resolveError(error32);
    } };
  }];
};
var createTracer = (traceListener) => {
  return (context) => {
    let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
    return traceListener({ id: context[ELYSIA_REQUEST_ID], context, set: context.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError, time: Date.now(), store: context.store }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var Kind3 = Symbol.for("TypeBox.Kind");
var Hint2 = Symbol.for("TypeBox.Hint");
var isSpecialProperty = (name) => /(\ |-|\t|\n)/.test(name);
var joinProperty = (v1, v2, isOptional = false) => {
  if (typeof v2 === "number")
    return `${v1}[${v2}]`;
  if (isSpecialProperty(v2))
    return `${v1}${isOptional ? "?." : ""}["${v2}"]`;
  return `${v1}${isOptional ? "?" : ""}.${v2}`;
};
var encodeProperty = (v) => isSpecialProperty(v) ? `"${v}"` : v;
var sanitize = (key, sanitize2 = 0, schema) => {
  if (schema.type !== "string" || schema.const || schema.trusted)
    return key;
  let hof = "";
  for (let i = sanitize2 - 1;i >= 0; i--)
    hof += `d.h${i}(`;
  return hof + key + ")".repeat(sanitize2);
};
var mergeObjectIntersection = (schema) => {
  if (!schema.allOf || Kind3 in schema && (schema[Kind3] !== "Intersect" || schema.type !== "object"))
    return schema;
  let { allOf, ...newSchema } = schema;
  if (newSchema.properties = {}, Kind3 in newSchema)
    newSchema[Kind3] = "Object";
  for (let type54 of allOf) {
    if (type54.type !== "object")
      continue;
    let { properties, required: required3, type: _2, [Kind3]: __, ...rest } = type54;
    if (required3)
      newSchema.required = newSchema.required ? newSchema.required.concat(required3) : required3;
    Object.assign(newSchema, rest);
    for (let property in type54.properties)
      newSchema.properties[property] = mergeObjectIntersection(type54.properties[property]);
  }
  return newSchema;
};
var handleRecord = (schema, property, instruction) => {
  let child = schema.patternProperties["^(.*)$"] ?? schema.patternProperties[Object.keys(schema.patternProperties)[0]];
  if (!child)
    return property;
  let i = instruction.array;
  return instruction.array++, `(()=>{const ar${i}s=Object.keys(${property}),ar${i}v={};for(let i=0;i<ar${i}s.length;i++){const ar${i}p=${property}[ar${i}s[i]];ar${i}v[ar${i}s[i]]=${mirror(child, `ar${i}p`, instruction)}}return ar${i}v})()`;
};
var handleTuple = (schema, property, instruction) => {
  let i = instruction.array;
  instruction.array++;
  let isRoot = property === "v" && !instruction.unions.length, v = "";
  if (!isRoot)
    v = "(()=>{";
  v += `const ar${i}v=[`;
  for (let i2 = 0;i2 < schema.length; i2++) {
    if (i2 !== 0)
      v += ",";
    v += mirror(schema[i2], joinProperty(property, i2, instruction.parentIsOptional), instruction);
  }
  if (v += "];", !isRoot)
    v += `return ar${i}v})()`;
  return v;
};
var handleUnion = (schemas, property, instruction) => {
  if (instruction.TypeCompiler === undefined) {
    if (!instruction.typeCompilerWanred)
      console.warn(new Error("[exact-mirror] TypeBox's TypeCompiler is required to use Union")), instruction.typeCompilerWanred = true;
    return property;
  }
  instruction.unionKeys[property] = 1;
  let ui = instruction.unions.length, typeChecks = instruction.unions[ui] = [], v = `(()=>{
`, unwrapRef = (type54) => {
    if (!(Kind3 in type54) || !type54.$ref)
      return type54;
    if (type54[Kind3] === "This")
      return deepClone(instruction.definitions[type54.$ref]);
    else if (type54[Kind3] === "Ref")
      if (!instruction.modules)
        console.warn(new Error("[exact-mirror] modules is required when using nested cyclic reference"));
      else
        return instruction.modules.Import(type54.$ref);
    return type54;
  };
  for (let i = 0;i < schemas.length; i++) {
    let type54 = unwrapRef(schemas[i]);
    if (Array.isArray(type54.anyOf))
      for (let i2 = 0;i2 < type54.anyOf.length; i2++)
        type54.anyOf[i2] = unwrapRef(type54.anyOf[i2]);
    else if (type54.items)
      if (Array.isArray(type54.items))
        for (let i2 = 0;i2 < type54.items.length; i2++)
          type54.items[i2] = unwrapRef(type54.items[i2]);
      else
        type54.items = unwrapRef(type54.items);
    typeChecks.push(TypeCompiler.Compile(type54)), v += `if(d.unions[${ui}][${i}].Check(${property})){return ${mirror(type54, property, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: true })}}
`;
  }
  return v += `return ${instruction.removeUnknownUnionType ? "undefined" : property}})()`, v;
};
var mirror = (schema, property, instruction) => {
  if (!schema)
    return "";
  let isRoot = property === "v" && !instruction.unions.length;
  if (Kind3 in schema && schema[Kind3] === "Import" && schema.$ref in schema.$defs)
    return mirror(schema.$defs[schema.$ref], property, { ...instruction, definitions: Object.assign(instruction.definitions, schema.$defs) });
  if (isRoot && schema.type !== "object" && schema.type !== "array" && !schema.anyOf)
    return `return ${sanitize("v", instruction.sanitize?.length, schema)}`;
  if (instruction.recursion >= instruction.recursionLimit)
    return property;
  let v = "";
  if (schema.$id && Hint2 in schema)
    instruction.definitions[schema.$id] = schema;
  switch (schema.type) {
    case "object":
      if (schema[Kind3] === "Record") {
        v = handleRecord(schema, property, instruction);
        break;
      }
      if (schema = mergeObjectIntersection(schema), v += "{", schema.additionalProperties)
        v += `...${property}`;
      let keys = Object.keys(schema.properties);
      for (let i2 = 0;i2 < keys.length; i2++) {
        let key = keys[i2], isOptional = schema.required && !schema.required.includes(key) || Array.isArray(schema.properties[key].anyOf), name = joinProperty(property, key, instruction.parentIsOptional);
        if (isOptional) {
          let index = instruction.array;
          if (property.startsWith("ar")) {
            let refName = name.slice(name.indexOf(".") + 1), array3 = instruction.optionalsInArray;
            if (array3[index])
              array3[index].push(refName);
            else
              array3[index] = [refName];
          } else
            instruction.optionals.push(name);
        }
        let child = schema.properties[key];
        if (schema.additionalProperties && child.type !== "object")
          continue;
        if (i2 !== 0)
          v += ",";
        v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : ""}${mirror(child, name, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: isOptional })}`;
      }
      v += "}";
      break;
    case "array":
      if (schema.items.type !== "object" && schema.items.type !== "array")
        if (Array.isArray(schema.items)) {
          v = handleTuple(schema.items, property, instruction);
          break;
        } else if (isRoot)
          return "return v";
        else if (Kind3 in schema.items && schema.items.$ref && (schema.items[Kind3] === "Ref" || schema.items[Kind3] === "This"))
          v = mirror(deepClone(instruction.definitions[schema.items.$ref]), property, { ...instruction, parentIsOptional: true, recursion: instruction.recursion + 1 });
        else {
          v = property;
          break;
        }
      let i = instruction.array;
      instruction.array++;
      let reference = property;
      if (isRoot)
        v = `const ar${i}v=new Array(${property}.length);`;
      else
        reference = `ar${i}s`, v = `((${reference})=>{const ar${i}v=new Array(${reference}.length);`;
      v += `for(let i=0;i<${reference}.length;i++){const ar${i}p=${reference}[i];ar${i}v[i]=${mirror(schema.items, `ar${i}p`, instruction)}`;
      let optionals = instruction.optionalsInArray[i + 1];
      if (optionals)
        for (let oi = 0;oi < optionals.length; oi++) {
          let target = `ar${i}v[i].${optionals[oi]}`;
          v += `;if(${target}===undefined)delete ${target}`;
        }
      if (v += "}", !isRoot)
        v += `return ar${i}v})(${property})`;
      break;
    default:
      if (schema.$ref && schema.$ref in instruction.definitions)
        return mirror(instruction.definitions[schema.$ref], property, instruction);
      if (Array.isArray(schema.anyOf)) {
        v = handleUnion(schema.anyOf, property, instruction);
        break;
      }
      v = sanitize(property, instruction.sanitize?.length, schema);
      break;
  }
  if (!isRoot)
    return v;
  if (schema.type === "array")
    return `${v}return ar0v`;
  v = `const x=${v}
`;
  for (let i = 0;i < instruction.optionals.length; i++) {
    let key = instruction.optionals[i], prop = key.slice(1);
    if (v += `if(${key}===undefined`, instruction.unionKeys[key])
      v += `||x${prop}===undefined`;
    v += `)delete x${prop.charCodeAt(0) !== 63 ? "?" : ""}${prop}
`;
  }
  return `${v}return x`;
};
var createMirror = (schema, { TypeCompiler: TypeCompiler22, modules, definitions, sanitize: sanitize2, recursionLimit = 8, removeUnknownUnionType = false } = {}) => {
  let unions = [];
  if (typeof sanitize2 === "function")
    sanitize2 = [sanitize2];
  let f = mirror(schema, "v", { optionals: [], optionalsInArray: [], array: 0, parentIsOptional: false, unions, unionKeys: {}, TypeCompiler: TypeCompiler22, modules, definitions: definitions ?? modules?.$defs ?? {}, sanitize: sanitize2, recursion: 0, recursionLimit, removeUnknownUnionType });
  if (!unions.length && !sanitize2?.length)
    return Function("v", f);
  let hof;
  if (sanitize2?.length) {
    hof = {};
    for (let i = 0;i < sanitize2.length; i++)
      hof[`h${i}`] = sanitize2[i];
  }
  return Function("d", `return function mirror(v){${f}}`)({ unions, ...hof });
};
var isOptional = (schema) => {
  if (!schema)
    return false;
  if (schema?.[Kind] === "Import" && schema.References)
    return schema.References().some(isOptional);
  if (schema.schema)
    schema = schema.schema;
  return !!schema && OptionalKind in schema;
};
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some(hasAdditionalProperties);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasAdditionalProperties(schema.items);
  return false;
};
var hasType = (type54, schema) => {
  if (!schema)
    return false;
  if (Kind in schema && schema[Kind] === type54)
    return true;
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasType(type54, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasType(type54, property.anyOf[i]))
            return true;
      }
      if (Kind in property && property[Kind] === type54)
        return true;
    }
    return false;
  }
  return !!schema.properties && Kind in schema.properties && schema.properties[Kind] === type54;
};
var hasProperty = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var hasRef = (schema) => {
  if (!schema)
    return false;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasRef(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasRef(schema.anyOf[i]))
        return true;
  }
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasRef(schema.oneOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasRef(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasRef(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasRef(property))
        return true;
      if (property.type === "array" && property.items && hasRef(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasRef(schema.items))
    return true;
  return schema[Kind] === "Ref" && "$ref" in schema;
};
var hasTransform = (schema) => {
  if (!schema)
    return false;
  if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform(schema.$defs[schema.$ref]))
    return true;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasTransform(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasTransform(schema.anyOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasTransform(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasTransform(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasTransform(property))
        return true;
      if (property.type === "array" && property.items && hasTransform(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasTransform(schema.items))
    return true;
  return TransformKind in schema;
};
var replaceSchemaType = (schema, options, _config = {}) => {
  let config = _config;
  if (config.root = true, !Array.isArray(options))
    return options.original = schema, _replaceSchemaType(schema, options, config);
  for (let option of options)
    option.original = schema, schema = _replaceSchemaType(schema, option, config);
  return schema;
};
var _replaceSchemaType = (schema, options, config) => {
  if (!schema)
    return schema;
  let root = config.root;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, config);
    return schema;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, config);
    return schema;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, config);
    return schema;
  }
  if (schema.not)
    return _replaceSchemaType(schema.not, options, config);
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema, to = options.to(rest);
    if (!to)
      return schema;
    let transform6, composeProperties = (schema2) => {
      let v = _composeProperties(schema2);
      if (v.$id)
        delete v.$id;
      return v;
    }, _composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value27] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value27, options, { ...config, root: false });
        return { ...rest, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest, ...v, items: _replaceSchemaType(items, options, { ...config, root: false }) };
      let value26 = { ...rest, ...v };
      if (delete value26.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform6 = t.ObjectString(properties2, rest), value26.default = JSON.stringify(exports_value2.Create(t.Object(properties2))), value26.properties = properties2;
      if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform6 = t.ArrayString(items, rest), value26.default = JSON.stringify(exports_value2.Create(t.Array(items))), value26.items = items;
      return value26;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value26] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value26, options, { ...config, root: false });
        return { ...rest, properties: newProperties };
      } else if (items?.map)
        return { ...rest, items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })) };
      return rest;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else if (to.not)
      to.not = composeProperties(to.not);
    if (transform6)
      to[TransformKind] = transform6[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value26] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value26, options, { ...config, root: false });
      return { ...rest, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest, ...to, items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })) };
    return { ...rest, ...to };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value26] of Object.entries(properties))
      switch (value26[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not, type: type54, ...rest } = value26, to = options.to(rest);
          if (!to)
            return schema;
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest, ...to.allOf[i] };
          else if (to.not)
            to.not = { ...rest, ...to.not };
          properties[key] = { ...rest, ..._replaceSchemaType(rest, options, { ...config, root: false }) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value26, options, { ...config, root: false });
          break;
        default:
          if (Array.isArray(value26.items))
            for (let i = 0;i < value26.items.length; i++)
              value26.items[i] = _replaceSchemaType(value26.items[i], options, { ...config, root: false });
          else if (value26.anyOf || value26.oneOf || value26.allOf || value26.not)
            properties[key] = _replaceSchemaType(value26, options, { ...config, root: false });
          else if (value26.type === "array")
            value26.items = _replaceSchemaType(value26.items, options, { ...config, root: false });
          break;
      }
  return schema;
};
var createCleaner = (schema) => (value26) => {
  if (typeof value26 === "object")
    try {
      return exports_value2.Clean(schema, value26);
    } catch {
      try {
        return exports_value2.Clean(schema, value26);
      } catch {
        return value26;
      }
    }
  return value26;
};
var getSchemaValidator = (s, { models = {}, dynamic = false, modules, normalize = false, additionalProperties = false, coerce = false, additionalCoerce = [], validators, sanitize: sanitize2 } = {}) => {
  if (validators = validators?.filter((x) => x), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let doesHaveRef = undefined, replaceSchema = (schema2) => {
    if (coerce)
      return replaceSchemaType(schema2, [{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    return replaceSchemaType(schema2, additionalCoerce);
  }, mapSchema = (s2) => {
    let schema2;
    if (!s2)
      return;
    if (typeof s2 !== "string")
      schema2 = s2;
    else {
      let isArray = s2.endsWith("[]"), key = isArray ? s2.substring(0, s2.length - 2) : s2;
      if (schema2 = modules?.Import(key) ?? models[key], isArray)
        schema2 = t.Array(schema2);
    }
    if (!schema2)
      return;
    let _doesHaveRef;
    if (schema2[Kind] !== "Import" && (_doesHaveRef = hasRef(schema2))) {
      let id = randomId();
      if (doesHaveRef === undefined)
        doesHaveRef = _doesHaveRef;
      schema2 = t.Module({ ...modules?.$defs, [id]: schema2 }).Import(id);
    }
    if (schema2[Kind] === "Import") {
      let newDefs = {};
      for (let [key2, value26] of Object.entries(schema2.$defs))
        newDefs[key2] = replaceSchema(value26);
      let key = schema2.$ref;
      schema2 = t.Module(newDefs).Import(key);
    } else if (coerce || additionalCoerce)
      schema2 = replaceSchema(schema2);
    return schema2;
  }, schema = mapSchema(s);
  if (validators?.length) {
    let hasAdditional = false, { schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([schema, ...validators.map(mapSchema)]);
    if (notObjects) {
      if (schema = t.Intersect([...mergedObjectSchema ? [mergedObjectSchema] : [], ...notObjects.map((x) => {
        let schema2 = mapSchema(x);
        if (schema2.type === "object" && "additionalProperties" in schema2) {
          if (!hasAdditional && schema2.additionalProperties === false)
            hasAdditional = true;
          delete schema2.additionalProperties;
        }
        return schema2;
      })]), schema.type === "object" && hasAdditional)
        schema.additionalProperties = false;
    }
  } else if (schema.type === "object" && "additionalProperties" in schema === false)
    schema.additionalProperties = additionalProperties;
  if (dynamic) {
    let validator = { schema, references: "", checkFunc: () => {
    }, code: "", Check: (value26) => exports_value2.Check(schema, value26), Errors: (value26) => exports_value2.Errors(schema, value26), Code: () => "", Clean: createCleaner(schema), Decode: (value26) => exports_value2.Decode(schema, value26), Encode: (value26) => exports_value2.Encode(schema, value26), get hasAdditionalProperties() {
      if ("~hasAdditionalProperties" in this)
        return this["~hasAdditionalProperties"];
      return this["~hasAdditionalProperties"] = hasAdditionalProperties(schema);
    }, get hasDefault() {
      if ("~hasDefault" in this)
        return this["~hasDefault"];
      return this["~hasDefault"] = hasProperty("default", schema);
    }, get isOptional() {
      if ("~isOptional" in this)
        return this["~isOptional"];
      return this["~isOptional"] = isOptional(schema);
    }, get hasTransform() {
      if ("~hasTransform" in this)
        return this["~hasTransform"];
      return this["~hasTransform"] = hasTransform(schema);
    }, "~hasRef": doesHaveRef, get hasRef() {
      if ("~hasRef" in this)
        return this["~hasRef"];
      return this["~hasRef"] = hasTransform(schema);
    } };
    if (schema.config) {
      if (validator.config = schema.config, validator?.schema?.config)
        delete validator.schema.config;
    }
    if (normalize && schema.additionalProperties === false)
      if (normalize === true || normalize === "exactMirror")
        try {
          validator.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
        } catch {
          console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), validator.Clean = createCleaner(schema);
        }
      else
        validator.Clean = createCleaner(schema);
    return validator.parse = (v) => {
      try {
        return validator.Decode(v);
      } catch (error23) {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(v), error: null };
      } catch (error23) {
        let errors6 = [...compiled.Errors(v)].map(mapValueError);
        return { success: false, data: null, error: errors6[0]?.summary, errors: errors6 };
      }
    }, validator;
  }
  let compiled = TypeCompiler.Compile(schema, Object.values(models));
  if (schema.config) {
    if (compiled.config = schema.config, compiled?.schema?.config)
      delete compiled.schema.config;
  }
  if (normalize === true || normalize === "exactMirror")
    try {
      compiled.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
    } catch (error23) {
      console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), compiled.Clean = createCleaner(schema);
    }
  else
    compiled.Clean = createCleaner(schema);
  return compiled.parse = (v) => {
    try {
      return compiled.Decode(v);
    } catch (error23) {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(v), error: null };
    } catch (error23) {
      let errors6 = [...compiled.Errors(v)].map(mapValueError);
      return { success: false, data: null, error: errors6[0]?.summary, errors: errors6 };
    }
  }, Object.assign(compiled, { get hasAdditionalProperties() {
    if ("~hasAdditionalProperties" in this)
      return this["~hasAdditionalProperties"];
    return this["~hasAdditionalProperties"] = hasAdditionalProperties(compiled);
  }, get hasDefault() {
    if ("~hasDefault" in this)
      return this["~hasDefault"];
    return this["~hasDefault"] = hasProperty("default", compiled);
  }, get isOptional() {
    if ("~isOptional" in this)
      return this["~isOptional"];
    return this["~isOptional"] = isOptional(compiled);
  }, get hasTransform() {
    if ("~hasTransform" in this)
      return this["~hasTransform"];
    return this["~hasTransform"] = hasTransform(schema);
  }, get hasRef() {
    if ("~hasRef" in this)
      return this["~hasRef"];
    return this["~hasRef"] = hasRef(schema);
  }, "~hasRef": doesHaveRef }), compiled;
};
var isUnion = (schema) => schema[Kind] === "Union" || !schema.schema && !!schema.anyOf;
var mergeObjectSchemas = (schemas) => {
  if (schemas.length === 0)
    return { schema: undefined, notObjects: [] };
  if (schemas.length === 1)
    return schemas[0].type === "object" ? { schema: schemas[0], notObjects: [] } : { schema: undefined, notObjects: schemas };
  let newSchema, notObjects = [], additionalPropertiesIsTrue = false, additionalPropertiesIsFalse = false;
  for (let schema of schemas) {
    if (schema.type !== "object") {
      notObjects.push(schema);
      continue;
    }
    if ("additionalProperties" in schema) {
      if (schema.additionalProperties === true)
        additionalPropertiesIsTrue = true;
      else if (schema.additionalProperties === false)
        additionalPropertiesIsFalse = true;
    }
    if (!newSchema) {
      newSchema = schema;
      continue;
    }
    newSchema = { ...newSchema, ...schema, properties: { ...newSchema.properties, ...schema.properties }, required: [...newSchema?.required ?? [], ...schema.required] };
  }
  if (newSchema) {
    if (newSchema.required)
      newSchema.required = [...new Set(newSchema.required)];
    if (additionalPropertiesIsFalse)
      newSchema.additionalProperties = false;
    else if (additionalPropertiesIsTrue)
      newSchema.additionalProperties = true;
  }
  return { schema: newSchema, notObjects };
};
var getResponseSchemaValidator = (s, { models = {}, modules, dynamic = false, normalize = false, additionalProperties = false, validators = [], sanitize: sanitize2 }) => {
  if (validators = validators.filter((x) => x), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let maybeSchemaOrRecord;
  if (typeof s !== "string")
    maybeSchemaOrRecord = s;
  else {
    let isArray = s.endsWith("[]"), key = isArray ? s.substring(0, s.length - 2) : s;
    if (maybeSchemaOrRecord = modules.Import(key) ?? models[key], isArray)
      maybeSchemaOrRecord = t.Array(maybeSchemaOrRecord);
  }
  if (!maybeSchemaOrRecord)
    return;
  if (Kind in maybeSchemaOrRecord)
    return { 200: getSchemaValidator(maybeSchemaOrRecord, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x) => x[200]), sanitize: sanitize2 }) };
  let record3 = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status2) => {
    if (isNaN(+status2))
      return;
    let maybeNameOrSchema = maybeSchemaOrRecord[+status2];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        record3[+status2] = Kind in schema ? getSchemaValidator(schema, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x) => x[+status2]), sanitize: sanitize2 }) : schema;
      }
      return;
    }
    record3[+status2] = Kind in maybeNameOrSchema ? getSchemaValidator(maybeNameOrSchema, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x) => x[+status2]), sanitize: sanitize2 }) : maybeNameOrSchema;
  }), record3;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions)
    _stringToStructureCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) }];
  return _stringToStructureCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({ validator, modules, defaultConfig = {}, config, dynamic, models, validators, sanitize: sanitize2 }) => {
  let cookieValidator = getSchemaValidator(validator, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators, sanitize: sanitize2 });
  if (cookieValidator)
    cookieValidator.config = mergeCookie(cookieValidator.config, config);
  else
    cookieValidator = getSchemaValidator(t.Cookie(t.Any()), { modules, dynamic, models, additionalProperties: true, validators, sanitize: sanitize2 }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var unwrapImportSchema = (schema) => schema[Kind] === "Import" && schema.$defs[schema.$ref][Kind] === "Object" ? schema.$defs[schema.$ref] : schema;
var allocateIf = (value26, condition) => condition ? value26 : "";
var defaultParsers = ["json", "text", "urlencoded", "arrayBuffer", "formdata", "application/json", "text/plain", "application/x-www-form-urlencoded", "application/octet-stream", "multipart/form-data"];
var createReport = ({ context = "c", trace = [], addFn }) => {
  if (!trace.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let i = 0;i < trace.length; i++)
    addFn(`let report${i},reportChild${i},reportErr${i},reportErrChild${i};let trace${i}=${context}[ELYSIA_TRACE]?.[${i}]??trace[${i}](${context});
`);
  return (event, { name, total = 0 } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace.length; i++)
      addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return { resolve() {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}${i}.resolve()
`);
    }, resolveChild(name2) {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
      return (binding) => {
        for (let i = 0;i < trace.length; i++)
          if (binding)
            addFn(`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`);
          else
            addFn(`${reporter}Child${i}?.()
`);
      };
    } };
  };
};
var composeCleaner = ({ schema, name, type: type54, typeAlias = type54, normalize, ignoreTryCatch = false }) => {
  if (!normalize || !schema.Clean || schema.hasAdditionalProperties)
    return "";
  if (normalize === true || normalize === "exactMirror") {
    if (ignoreTryCatch)
      return `${name}=validator.${typeAlias}.Clean(${name})
`;
    return `try{${name}=validator.${typeAlias}.Clean(${name})
}catch{}`;
  }
  if (normalize === "typebox")
    return `${name}=validator.${typeAlias}.Clean(${name})
`;
  return "";
};
var composeValidationFactory = ({ injectResponse = "", normalize = false, validator, encodeSchema = false, isStaticResponse = false, hasSanitize = false }) => ({ validate: (type54, value26 = `c.${type54}`) => `c.set.status=422;throw new ValidationError('${type54}',validator.${type54},${value26})`, response: (name = "r") => {
  if (isStaticResponse)
    return "";
  let code = injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}switch(c.set.status){`;
  for (let [status2, value26] of Object.entries(validator.response)) {
    code += `
case ${status2}:if(${name} instanceof Response)break
`;
    let noValidate = value26.schema?.noValidate === true, appliedCleaner = noValidate || hasSanitize, clean3 = ({ ignoreTryCatch = false } = {}) => composeCleaner({ name, schema: value26, type: "response", typeAlias: `response[${status2}]`, normalize, ignoreTryCatch });
    if (appliedCleaner)
      code += clean3();
    let applyErrorCleaner = !appliedCleaner && normalize && !noValidate;
    if (encodeSchema && value26.hasTransform)
      code += `try{${name}=validator.response[${status2}].Encode(${name})
c.set.status=${status2}}catch{` + (applyErrorCleaner ? `try{
` + clean3({ ignoreTryCatch: true }) + `${name}=validator.response[${status2}].Encode(${name})
}catch{throw new ValidationError('response',validator.response[${status2}],${name})}` : `throw new ValidationError('response',validator.response[${status2}],${name})`) + "}";
    else {
      if (!appliedCleaner)
        code += clean3();
      if (!noValidate)
        code += `if(validator.response[${status2}].Check(${name})===false)throw new ValidationError('response',validator.response[${status2}],${name})
c.set.status=${status2}
`;
    }
    code += `break
`;
  }
  return code + "}";
} });
var isAsyncName = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var matchResponseClone = /=>\s?response\.clone\(/;
var matchFnReturn = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/;
var isAsync = (v) => {
  let isObject2 = typeof v === "object";
  if (isObject2 && v.isAsync !== undefined)
    return v.isAsync;
  let fn = isObject2 ? v.fn : v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal13 = fn.toString();
  if (matchResponseClone.test(literal13)) {
    if (isObject2)
      v.isAsync = false;
    return false;
  }
  let result = matchFnReturn.test(literal13);
  if (isObject2)
    v.isAsync = result;
  return result;
};
var hasReturn = (v) => {
  let isObject2 = typeof v === "object";
  if (isObject2 && v.hasReturn !== undefined)
    return v.hasReturn;
  let fnLiteral = isObject2 ? v.fn.toString() : typeof v === "string" ? v.toString() : v, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    if (isObject2)
      v.hasReturn = true;
    return true;
  }
  let result = fnLiteral.includes("return");
  if (isObject2)
    v.hasReturn = result;
  return result;
};
var isGenerator = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var composeHandler = ({ app, path, method, hooks, validator, handler, allowMeta = false, inference }) => {
  let adapter = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    if (handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} }), hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length) {
      if (handler instanceof Response)
        return Function("a", `"use strict";
return function(){return a.clone()}`)(handler);
      return Function("a", `"use strict";
return function(){return a}`)(handler);
    }
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasAfterResponse = !!hooks.afterResponse?.length, hasTrace = !!hooks.trace?.length, fnLiteral = "";
  if (inference = sucrose(hooks, inference), inference = sucrose({ handler }, inference), adapter.declare) {
    let literal13 = adapter.declare(inference);
    if (literal13)
      fnLiteral += literal13;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasValidation = !!validator.body || !!validator.headers || !!validator.params || !!validator.query || !!validator.cookie || !!validator.response, hasQuery = inference.query || !!validator.query, requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none", hasBody = method !== "" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody, defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || !!validator.headers || adapter.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieMeta = validator.cookie?.config ? mergeCookie(validator?.cookie?.config, app.config.cookie) : app.config.cookie, _encodeCookie = "", encodeCookie = () => {
    if (_encodeCookie)
      return _encodeCookie;
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (_encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
        _encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
      else
        for (let name of cookieMeta.sign)
          _encodeCookie += `if(_setCookie['${name}']?.value)c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')
`;
      _encodeCookie += `}
`;
    }
    return _encodeCookie;
  }, normalize = app.config.normalize, encodeSchema = app.config.encodeSchema, validation = composeValidationFactory({ normalize, validator, encodeSchema, isStaticResponse: handler instanceof Response, hasSanitize: !!app.config.sanitize });
  if (hasHeaders)
    fnLiteral += adapter.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += "try{", hasCookie) {
    let get = (name, defaultValue) => {
      let value26 = cookieMeta?.[name] ?? defaultValue;
      if (!value26)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value26 === "string")
        return `${name}:'${value26}',`;
      if (value26 instanceof Date)
        return `${name}: new Date(${value26.getTime()}),`;
      return `${name}:${value26},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      let properties = validator.query.schema.properties;
      if (!validator.query.hasAdditionalProperties)
        for (let [key, _value] of Object.entries(properties)) {
          let value26 = _value, isArray = value26.type === "array" || !!value26.anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
          if (value26 && OptionalKind in value26 && value26.type === "array" && value26.items)
            value26 = value26.items;
          let { type: type54, anyOf } = value26;
          destructured.push({ key, isArray, isNestedObjectArray: isArray && value26.items?.type === "object" || !!value26.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"), isObject: type54 === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"), anyOf: !!anyOf });
        }
    }
    if (!destructured.length)
      fnLiteral += "if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}";
    else {
      fnLiteral += `if(c.qi!==-1){let url='&'+c.url.slice(c.qi+1)
`;
      let index = 0;
      for (let { key, isArray, isObject: isObject2, isNestedObjectArray, anyOf } of destructured) {
        let init2 = (index === 0 ? "let " : "") + `memory=url.indexOf('&${key}=')
let a${index}
`;
        if (isArray)
          if (fnLiteral += init2, isNestedObjectArray)
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+/g,' '))
const charCode=temp.charCodeAt(0)
if(charCode!==91&&charCode !== 123)
temp='"'+temp+'"'
a${index}+=temp
if(memory===-1)break
memory=url.indexOf('&${key}=',memory)
if(memory===-1)break}try{if(a${index}.charCodeAt(0)===91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
`;
          else
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){const temp=decodeURIComponent(url.slice(start)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g,' '))}
break}else{const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(temp)}
}memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`;
        else if (isObject2)
          fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}`;
        else {
          if (fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))`, anyOf)
            fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=url.slice(start).replace(/\\+/g,' ')
else value=url.slice(start, deepMemory).replace(/\\+/g,' ')
value=decodeURIComponent(value)
if(value===null){if(deepMemory===-1){break}else{continue}}
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`;
          fnLiteral += "}}";
        }
        index++, fnLiteral += `
`;
      }
      fnLiteral += "c.query={" + destructured.map(({ key }, index2) => `'${key}':a${index2}`).join(",") + "}", fnLiteral += `} else c.query = {}
`;
    }
  }
  let isAsyncHandler = typeof handler === "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response= " : "", maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync) || !!hooks.beforeHandle?.some(isAsync) || !!hooks.transform?.some(isAsync) || !!hooks.mapResponse?.some(isAsync), maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || !!hooks.beforeHandle?.some(isGenerator) || !!hooks.afterHandle?.some(isGenerator) || !!hooks.transform?.some(isGenerator), responseKeys = Object.keys(validator.response ?? {}), hasMultipleResponses = responseKeys.length > 1, hasSingle200 = responseKeys.length === 0 || responseKeys.length === 1 && responseKeys[0] === "200", hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || hasMultipleResponses || !hasSingle200 || isHandleFn && hasDefaultHeaders || maybeStream, mapResponse2 = (r = "r") => `return ${hasSet ? "mapResponse" : "mapCompactResponse"}(${saveResponse}${r}${hasSet ? ",c.set" : ""}${mapResponseContext})
`, mapResponseContext = maybeStream || adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  if (hasTrace || inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  let parseReporter = report("parse", { total: hooks.parse?.length });
  if (hasBody) {
    let hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
    if (adapter.parser.declare)
      fnLiteral += adapter.parser.declare;
    fnLiteral += `
try{`;
    let parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (!parser && validator.body && !hooks.parse?.length) {
      let schema = validator.body.schema;
      if (schema && schema.anyOf && schema[Kind] === "Union" && schema.anyOf?.length === 2 && schema.anyOf?.find((x) => x[Kind] === "ElysiaForm"))
        parser = "formdata";
    }
    if (parser && defaultParsers.includes(parser)) {
      let reporter = report("parse", { total: hooks.parse?.length }), isOptionalBody = !!validator.body?.isOptional;
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"])
            fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      fnLiteral += `
`;
      let declaration = hooks.parse?.length ? "let" : "const";
      fnLiteral += hasHeaders ? `${declaration} contentType=c.headers['content-type']
` : `${declaration} contentType=c.request.headers.get('content-type')
`;
      let hasDefaultParser = false;
      if (hooks.parse?.length)
        fnLiteral += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
      else {
        hasDefaultParser = true;
        let isOptionalBody = !!validator.body?.isOptional;
        fnLiteral += `if(contentType)switch(contentType.charCodeAt(12)){
case 106:` + adapter.parser.json(isOptionalBody) + `break
case 120:` + adapter.parser.urlencoded(isOptionalBody) + `break
case 111:` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 114:` + adapter.parser.formData(isOptionalBody) + `break
default:if(contentType.charCodeAt(0)===116){` + adapter.parser.text(isOptionalBody) + `}break
}`;
      }
      let reporter = report("parse", { total: hooks.parse?.length });
      if (hooks.parse)
        for (let i = 0;i < hooks.parse.length; i++) {
          let name = `bo${i}`;
          if (i !== 0)
            fnLiteral += `
if(!used){`;
          if (typeof hooks.parse[i].fn === "string") {
            let endUnit = reporter.resolveChild(hooks.parse[i].fn), isOptionalBody = !!validator.body?.isOptional;
            switch (hooks.parse[i].fn) {
              case "json":
              case "application/json":
                hasDefaultParser = true, fnLiteral += adapter.parser.json(isOptionalBody);
                break;
              case "text":
              case "text/plain":
                hasDefaultParser = true, fnLiteral += adapter.parser.text(isOptionalBody);
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                hasDefaultParser = true, fnLiteral += adapter.parser.urlencoded(isOptionalBody);
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                hasDefaultParser = true, fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
                break;
              case "formdata":
              case "multipart/form-data":
                hasDefaultParser = true, fnLiteral += adapter.parser.formData(isOptionalBody);
                break;
              default:
                fnLiteral += `let ${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true;}
`;
            }
            endUnit();
          } else {
            let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
            fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
          }
          if (i !== 0)
            fnLiteral += "}";
          if (hasDefaultParser)
            break;
        }
      if (reporter.resolve(), !hasDefaultParser) {
        let isOptionalBody = !!validator.body?.isOptional;
        if (hooks.parse?.length)
          fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`;
        fnLiteral += "switch(contentType){", fnLiteral += `case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse?.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
      if (hooks.parse?.length)
        fnLiteral += `
delete c.contentType`;
    }
    fnLiteral += "}catch(error){throw new ParseError(error)}";
  }
  if (parseReporter.resolve(), hooks?.transform) {
    let reporter = report("transform", { total: hooks.transform.length });
    if (hooks.transform.length)
      fnLiteral += `let transformed
`;
    for (let i = 0;i < hooks.transform.length; i++) {
      let transform6 = hooks.transform[i], endUnit = reporter.resolveChild(transform6.fn.name);
      if (fnLiteral += isAsync(transform6) ? `transformed=await e.transform[${i}](c)
` : `transformed=e.transform[${i}](c)
`, transform6.subType === "mapDerive")
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
      else
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
      endUnit();
    }
    reporter.resolve();
  }
  let fileUnions = [];
  if (validator) {
    if (validator.headers) {
      if (validator.headers.hasDefault)
        for (let [key, value26] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value26 === "object" ? JSON.stringify(value26) : typeof value26 === "string" ? `'${value26}'` : value26;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.headers", schema: validator.headers, type: "headers", normalize }), validator.headers.isOptional)
        fnLiteral += "if(isNotEmpty(c.headers)){";
      if (validator.body?.schema?.noValidate !== true)
        fnLiteral += "if(validator.headers.Check(c.headers) === false){" + validation.validate("headers") + "}";
      if (validator.headers.hasTransform)
        fnLiteral += `c.headers=validator.headers.Decode(c.headers)
`;
      if (validator.headers.isOptional)
        fnLiteral += "}";
    }
    if (validator.params) {
      if (validator.params.hasDefault)
        for (let [key, value26] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value26 === "object" ? JSON.stringify(value26) : typeof value26 === "string" ? `'${value26}'` : value26;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      if (validator.params?.schema?.noValidate !== true)
        fnLiteral += "if(validator.params.Check(c.params)===false){" + validation.validate("params") + "}";
      if (validator.params.hasTransform)
        fnLiteral += `c.params=validator.params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (validator.query.hasDefault)
        for (let [key, value26] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value26 === "object" ? JSON.stringify(value26) : typeof value26 === "string" ? `'${value26}'` : value26;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
          fnLiteral += composeCleaner({ name: "c.query", schema: validator.query, type: "query", normalize });
        }
      if (validator.query.isOptional)
        fnLiteral += "if(isNotEmpty(c.query)){";
      if (validator.query?.schema?.noValidate !== true)
        fnLiteral += "if(validator.query.Check(c.query)===false){" + validation.validate("query") + "}";
      if (validator.query.hasTransform)
        fnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
      if (validator.query.isOptional)
        fnLiteral += "}";
    }
    if (hasBody && validator.body) {
      if (validator.body.hasTransform || validator.body.isOptional)
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
      let hasUnion = isUnion(validator.body.schema), hasNonUnionFileWithDefault = false;
      if (validator.body.hasDefault) {
        let value26 = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" || validator.body.schema[Kind] === "Import" && validator.body.schema.$defs[validator.body.schema.$ref][Kind] === "Object" ? {} : undefined), schema = unwrapImportSchema(validator.body.schema);
        if (!hasUnion && value26 && typeof value26 === "object" && (hasType("File", schema) || hasType("Files", schema))) {
          hasNonUnionFileWithDefault = true;
          for (let [k2, v] of Object.entries(value26))
            if (v === "File" || v === "Files")
              delete value26[k2];
          if (!isNotEmpty(value26))
            value26 = undefined;
        }
        let parsed = typeof value26 === "object" ? JSON.stringify(value26) : typeof value26 === "string" ? `'${value26}'` : value26;
        if (value26 !== undefined && value26 !== null)
          if (Array.isArray(value26))
            fnLiteral += `if(!c.body)c.body=${parsed}
`;
          else if (typeof value26 === "object")
            fnLiteral += `c.body=Object.assign(${parsed},c.body)
`;
          else
            fnLiteral += `c.body=${parsed}
`;
        if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize }), validator.body?.schema?.noValidate !== true)
          if (validator.body.isOptional)
            fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
          else
            fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      } else if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize }), validator.body?.schema?.noValidate !== true)
        if (validator.body.isOptional)
          fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
        else
          fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      if (validator.body.hasTransform)
        fnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
      if (hasUnion && validator.body.schema.anyOf?.length) {
        let iterator3 = Object.values(validator.body.schema.anyOf);
        for (let i = 0;i < iterator3.length; i++) {
          let type54 = iterator3[i];
          if (hasType("File", type54) || hasType("Files", type54)) {
            let candidate = getSchemaValidator(type54, { modules: app.definitions.typebox, dynamic: !app.config.aot, models: app.definitions.type, normalize: app.config.normalize, additionalCoerce: coercePrimitiveRoot(), sanitize: () => app.config.sanitize });
            if (candidate) {
              let isFirst = fileUnions.length === 0, iterator22 = Object.entries(type54.properties), validator2 = isFirst ? `
` : " else ";
              validator2 += `if(fileUnions[${fileUnions.length}].Check(c.body)){`;
              let validateFile2 = "", validatorLength = 0;
              for (let i2 = 0;i2 < iterator22.length; i2++) {
                let [k2, v] = iterator22[i2];
                if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
                  continue;
                if (validatorLength)
                  validateFile2 += ",";
                validateFile2 += `validateFileExtension(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, validatorLength++;
              }
              if (validateFile2) {
                if (validatorLength === 1)
                  validator2 += `await ${validateFile2}
`;
                else if (validatorLength > 1)
                  validator2 += `await Promise.all([${validateFile2}])
`;
                validator2 += "}", fnLiteral += validator2, fileUnions.push(candidate);
              }
            }
          }
        }
      } else if (hasNonUnionFileWithDefault || !hasUnion && (hasType("File", unwrapImportSchema(validator.body.schema)) || hasType("Files", unwrapImportSchema(validator.body.schema)))) {
        let validateFile2 = "", i = 0;
        for (let [k2, v] of Object.entries(unwrapImportSchema(validator.body.schema).properties)) {
          if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
            continue;
          if (i)
            validateFile2 += ",";
          validateFile2 += `validateFileExtension(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, i++;
        }
        if (i)
          fnLiteral += `
`;
        if (i === 1)
          fnLiteral += `await ${validateFile2}
`;
        else if (i > 1)
          fnLiteral += `await Promise.all([${validateFile2}])
`;
      }
    }
    if (validator.cookie) {
      let cookieValidator = getCookieValidator({ modules: app.definitions.typebox, validator: validator.cookie, defaultConfig: app.config.cookie, dynamic: !!app.config.aot, config: validator.cookie?.config ?? {}, models: app.definitions.type });
      if (fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, cookieValidator.hasDefault)
        for (let [key, value26] of Object.entries(exports_value2.Default(cookieValidator.schema, {})))
          fnLiteral += `cookieValue['${key}'] = ${typeof value26 === "object" ? JSON.stringify(value26) : value26}
`;
      if (cookieValidator.isOptional)
        fnLiteral += "if(isNotEmpty(c.cookie)){";
      if (validator.body?.schema?.noValidate !== true)
        fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + validation.validate("cookie", "cookieValue") + "}";
      if (cookieValidator.hasTransform)
        fnLiteral += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
      if (cookieValidator.isOptional)
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle.length }), hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let beforeHandle = hooks.beforeHandle[i], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
      if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
        if (!hasResolve)
          hasResolve = true, fnLiteral += `
let resolved
`;
        if (fnLiteral += isAsync(beforeHandle) ? `resolved=await e.beforeHandle[${i}](c);
` : `resolved=e.beforeHandle[${i}](c);
`, beforeHandle.subType === "mapResolve")
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}`;
        else
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
      } else if (!returning)
        fnLiteral += isAsync(beforeHandle) ? `await e.beforeHandle[${i}](c)
` : `e.beforeHandle[${i}](c)
`, endUnit();
      else {
        if (fnLiteral += isAsync(beforeHandle) ? `be=await e.beforeHandle[${i}](c)
` : `be=e.beforeHandle[${i}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length) {
          report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
          let reporter2 = report("afterHandle", { total: hooks.afterHandle.length });
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let hook = hooks.afterHandle[i2], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
            if (fnLiteral += `c.response = be
`, !returning2)
              fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i2}](c, be)
` : `e.afterHandle[${i2}](c, be)
`;
            else
              fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i2}](c)
` : `af=e.afterHandle[${i2}](c)
`, fnLiteral += `if(af!==undefined) c.response=be=af
`;
            endUnit2("af");
          }
          reporter2.resolve();
        }
        if (validator.response)
          fnLiteral += validation.response("be");
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
        if (hooks.mapResponse?.length) {
          fnLiteral += `c.response=be
`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse3 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse3.fn.name);
            fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`, endUnit2();
          }
        }
        mapResponseReporter.resolve(), fnLiteral += encodeCookie(), fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks.afterHandle?.length) {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=await ${handle}
` : `let r=c.response=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    handleReporter.resolve();
    let reporter = report("afterHandle", { total: hooks.afterHandle.length });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      let hook = hooks.afterHandle[i], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
      if (!returning)
        fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i}](c)
` : `e.afterHandle[${i}](c)
`, endUnit();
      else if (fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i}](c)
` : `af=e.afterHandle[${i}](c)
`, endUnit("af"), validator.response)
        fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += validation.response("af"), fnLiteral += "c.response=af}";
      else
        fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=af}";
    }
    if (reporter.resolve(), fnLiteral += `r=c.response
`, validator.response)
      fnLiteral += validation.response();
    fnLiteral += encodeCookie();
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
    if (hooks.mapResponse?.length)
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        let mapResponse3 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`, endUnit();
      }
    mapResponseReporter.resolve(), fnLiteral += mapResponse2();
  } else {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (validator.response || hooks.mapResponse?.length) {
      if (fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), validator.response)
        fnLiteral += validation.response();
      report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `
c.response=r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse3 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie(), handler instanceof Response)
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else
        fnLiteral += mapResponse2();
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `c.response= r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse3 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`, endUnit();
        }
      }
      mapResponseReporter.resolve(), fnLiteral += encodeCookie() + mapResponse2();
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (report("afterHandle").resolve(), handler instanceof Response)
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      else
        fnLiteral += mapResponse2(handled);
    }
  }
  if (fnLiteral += `
}catch(error){`, !maybeAsync && hooks.error?.length)
    fnLiteral += "return(async()=>{";
  if (fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasCookie)
    fnLiteral += encodeCookie();
  if (hasTrace && hooks.trace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
  let errorReporter = report("error", { total: hooks.error?.length });
  if (hooks.error?.length) {
    if (fnLiteral += `c.error=error
`, hasValidation)
      fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
    else
      fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
    fnLiteral += `let er
`;
    for (let i = 0;i < hooks.error.length; i++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      if (isAsync(hooks.error[i]))
        fnLiteral += `er=await e.error[${i}](c)
`;
      else
        fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`;
      endUnit();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse3 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse3.fn.name);
          fnLiteral += `c.response=er
er=e.mapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`, endUnit2();
        }
      if (mapResponseReporter.resolve(), fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace && hooks.trace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync && hooks.error?.length)
    fnLiteral += "})()";
  if (fnLiteral += "}", hasAfterResponse || hasTrace) {
    if (fnLiteral += "finally{ ", !maybeAsync)
      fnLiteral += ";(async()=>{";
    let reporter = report("afterResponse", { total: hooks.afterResponse?.length });
    if (hasAfterResponse && hooks.afterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
        fnLiteral += `
await e.afterResponse[${i}](c)
`, endUnit();
      }
    if (reporter.resolve(), !maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
  }
  let adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", init = "const {handler,handleError,hooks:e, " + allocateIf("validator,", hasValidation) + "mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" + allocateIf("parseQuery,", hasBody) + allocateIf("parseQueryFromURL,", hasQuery) + "},error:{" + allocateIf("ValidationError,", hasValidation) + allocateIf("ParseError", hasBody) + "},validateFileExtension,schema,definitions,ERROR_CODE," + allocateIf("parseCookie,", hasCookie) + allocateIf("signCookie,", hasCookie) + allocateIf("decodeURIComponent,", hasQuery) + "ElysiaCustomStatusResponse," + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + allocateIf("parser,", hooks.parse?.length) + allocateIf("getServer,", inference.server) + allocateIf("fileUnions,", fileUnions.length) + adapterVariables + allocateIf("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle?.length)
    init += `let be
`;
  if (hooks.afterHandle?.length)
    init += `let af
`;
  if (hooks.mapResponse?.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema=schema
c.defs=definitions
`;
  fnLiteral = init + fnLiteral + "}", init = "";
  try {
    return Function("hooks", `"use strict";
` + fnLiteral)({ handler, hooks: lifeCycleToFn({ ...hooks }), validator: hasValidation ? validator : undefined, handleError: app.handleError, mapResponse: adapterHandler.mapResponse, mapCompactResponse: adapterHandler.mapCompactResponse, mapEarlyResponse: adapterHandler.mapEarlyResponse, isNotEmpty, utils: { parseQuery: hasBody ? parseQuery : undefined, parseQueryFromURL: hasQuery ? parseQueryFromURL : undefined }, error: { ValidationError: hasValidation ? ValidationError : undefined, ParseError: hasBody ? ParseError2 : undefined }, validateFileExtension, schema: app.router.history, definitions: app.definitions.type, ERROR_CODE, parseCookie: hasCookie ? parseCookie : undefined, signCookie: hasCookie ? signCookie : undefined, decodeURIComponent: hasQuery ? import_fast_decode_uri_component3.default : undefined, ElysiaCustomStatusResponse, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, getServer: () => app.getServer(), fileUnions: fileUnions.length ? fileUnions : undefined, TypeBoxError: hasValidation ? TypeBoxError : undefined, parser: app["~parser"], ...adapter.inject });
  } catch (error23) {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, instruction: fnLiteral, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x) => x.toString()), resolve: debugHooks?.resolve?.map?.((x) => x.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()), parse: debugHooks?.parse?.map?.((x) => x.toString()), error: debugHooks?.error?.map?.((x) => x.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()), stop: debugHooks?.stop?.map?.((x) => x.toString()) }, validator, definitions: app.definitions.type, error: error23 }), console.log("---"), process.exit(1);
  }
};
var createOnRequestHandler = (app, addFn) => {
  let fnLiteral = "", reporter = createReport({ trace: app.event.trace, addFn: addFn ?? ((word) => {
    fnLiteral += word;
  }) })("request", { total: app.event.request?.length });
  if (app.event.request?.length) {
    fnLiteral += "try{";
    for (let i = 0;i < app.event.request.length; i++) {
      let hook = app.event.request[i], withReturn = hasReturn(hook), maybeAsync = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      if (withReturn)
        fnLiteral += `re=mapEarlyResponse(${maybeAsync ? "await " : ""}onRequest[${i}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`;
      else
        fnLiteral += `${maybeAsync ? "await " : ""}onRequest[${i}](c)
`, endUnit();
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  return reporter.resolve(), fnLiteral;
};
var createHoc = (app, fnName = "map") => {
  let hoc = app.extender.higherOrderFunctions;
  if (!hoc.length)
    return "return " + fnName;
  let adapter = app["~adapter"].composeGeneralHandler, handler = fnName;
  for (let i = 0;i < hoc.length; i++)
    handler = `hoc[${i}](${handler},${adapter.parameters})`;
  return `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
};
var composeGeneralHandler = (app) => {
  let adapter = app["~adapter"].composeGeneralHandler;
  app.router.http.build();
  let error404 = adapter.error404(!!app.event.request?.length, !!app.event.error?.length), hasTrace = app.event.trace?.length, fnLiteral = "", router = app.router, findDynamicRoute = router.http.root.WS ? `const route=router.find(r.method === "GET" && r.headers.get('upgrade')==='websocket'?'WS':r.method,p)` : "const route=router.find(r.method,p)";
  findDynamicRoute += router.http.root.ALL ? `??router.find("ALL",p)
` : `
`, findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`;
  let switchMap = "";
  for (let [path, methods] of Object.entries(router.static)) {
    if (switchMap += `case'${path}':`, app.config.strictPath !== true)
      switchMap += `case'${getLoosePath(path)}':`;
    let encoded = encodePath(path);
    if (path !== encoded)
      switchMap += `case'${encoded}':`;
    if (switchMap += "switch(r.method){", "GET" in methods || "WS" in methods) {
      if (switchMap += "case 'GET':", "WS" in methods)
        switchMap += `if(r.headers.get('upgrade')==='websocket')return ht[${methods.WS}].composed(c)
`;
      if ("GET" in methods)
        switchMap += `return ht[${methods.GET}].composed(c)
`;
    }
    for (let [method, index] of Object.entries(methods)) {
      if (method === "ALL" || method === "GET" || method === "WS")
        continue;
      switchMap += `case '${method}':return ht[${index}].composed(c)
`;
    }
    if ("ALL" in methods)
      switchMap += `default:return ht[${methods.ALL}].composed(c)
`;
    else
      switchMap += `default:break map
`;
    switchMap += "}";
  }
  let maybeAsync = !!app.event.request?.some(isAsync), adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  if (fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,` + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (fnLiteral += error404.declare, app.event.trace?.length)
    fnLiteral += "const " + app.event.trace.map((_2, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`;
  if (fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`, app.event.request?.length)
    fnLiteral += `let re
`;
  if (fnLiteral += adapter.createContext(app), app.event.trace?.length)
    fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_2, i) => `tr${i}(c)`).join(",") + `]
`;
  if (fnLiteral += createOnRequestHandler(app), switchMap)
    fnLiteral += `
map: switch(p){
` + switchMap + "}";
  fnLiteral += findDynamicRoute + `}
` + createHoc(app), app.handleError = composeErrorHandler(app);
  let fn = Function("data", `"use strict";
` + fnLiteral)({ app, mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse, NotFoundError, randomId, handleError: app.handleError, status, redirect, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter.inject });
  if (isBun)
    Bun.gc(false);
  return fn;
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "", adapter = app["~adapter"].composeError, adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", hasTrace = !!app.event.trace?.length;
  if (fnLiteral += "const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse," + allocateIf("onError,", app.event.error) + allocateIf("afterResponse,", app.event.afterResponse) + allocateIf("trace,", app.event.trace) + allocateIf("onMapResponse,", app.event.mapResponse) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=inject
`, fnLiteral += `return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`, fnLiteral += "", hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter.declare)
    fnLiteral += adapter.declare;
  let saveResponse = hasTrace || !!hooks.afterResponse?.length || !!hooks.afterResponse?.length ? "context.response = " : "";
  if (app.event.error)
    for (let i = 0;i < app.event.error.length; i++) {
      let handler = app.event.error[i], response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
      if (fnLiteral += "if(skipGlobal!==true){", hasReturn(handler)) {
        fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
        let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
        if (hooks.mapResponse?.length)
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse2 = hooks.mapResponse[i2], endUnit = mapResponseReporter2.resolveChild(mapResponse2.fn.name);
            fnLiteral += `context.response=_r_r=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i2}](context)
`, endUnit();
          }
        mapResponseReporter2.resolve(), fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
      } else
        fnLiteral += response;
      fnLiteral += "}";
    }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){
if(error.error)error=error.error
set.status=error.status??422
` + adapter.validationError + `
}
`, fnLiteral += `if(error instanceof Error){
if(typeof error.toResponse==='function')return context.response=error.toResponse()
` + adapter.unknownError + `
}`;
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
  if (fnLiteral += `
if(!context.response)context.response=error.message??error
`, hooks.mapResponse?.length) {
    fnLiteral += `let mr
`;
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`, endUnit();
    }
  }
  mapResponseReporter.resolve(), fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`;
  let mapFn = (x) => typeof x === "function" ? x : x.fn;
  return Function("inject", `"use strict";
` + fnLiteral)({ mapResponse: app["~adapter"].handler.mapResponse, ERROR_CODE, ElysiaCustomStatusResponse, onError: app.event.error?.map(mapFn), afterResponse: app.event.afterResponse?.map(mapFn), trace: app.event.trace?.map(mapFn), onMapResponse: app.event.mapResponse?.map(mapFn), ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter.inject });
};
var mapResponse2 = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse2(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Error":
        return errorToResponse2(response, set2);
      case "Promise":
        return response.then((x) => mapResponse2(x, set2, request));
      case "Function":
        return mapResponse2(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x) => mapResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse2(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (response instanceof Response && !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
    return handleStream2(streamResponse(response), responseToSetHeaders(response, set2), request);
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream2(response, set2, request);
  return mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Promise":
        return response.then((x) => mapEarlyResponse2(x, set2));
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapEarlyResponse2(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case "ReadableStream":
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
          return handleStream2(streamResponse(response), responseToSetHeaders(response), request);
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse2(x, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapCompactResponse2(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse2 = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleFile(response.value);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, { status: response.code, headers: {} });
    case "ReadableStream":
      return request?.signal?.addEventListener("abort", { handleEvent() {
        if (request?.signal && !request?.signal?.aborted)
          response.cancel();
      } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      if (response.headers.get("transfer-encoding") === "chunked")
        return handleStream2(streamResponse(response), responseToSetHeaders(response), request);
      return response;
    case "Error":
      return errorToResponse2(response);
    case "Promise":
      return response.then((x) => mapCompactResponse2(x, request));
    case "Function":
      return mapCompactResponse2(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse2(x, request));
      if (response instanceof Error)
        return errorToResponse2(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse2(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function")
        return handleStream2(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse2(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse2 = (error23, set2) => new Response(JSON.stringify({ name: error23?.name, message: error23?.message, cause: error23?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return response.clone.bind(response);
};
var handleResponse2 = createResponseHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var handleStream2 = createStreamHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var allocateIf2 = (value26, condition) => condition ? value26 : "";
var createContext = (app, route, inference, isInline = false) => {
  let fnLiteral = "", defaultHeaders = app.setHeaders, hasTrace = !!app.event.trace?.length;
  if (hasTrace)
    fnLiteral += `const id=randomId()
`;
  let isDynamic = /[:*]/.test(route.path), getQi = `const u=request.url,s=u.indexOf('/',${app.config.handler?.standardHostname ?? true ? 11 : 7}),qi=u.indexOf('?', s + 1)
`;
  if (inference.query)
    fnLiteral += getQi;
  let getPath = !inference.path ? "" : !isDynamic ? `path:'${route.path}',` : "get path(){" + (inference.query ? "" : getQi) + `if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},`;
  if (fnLiteral += allocateIf2("const c=", !isInline) + "{request,store," + allocateIf2("qi,", inference.query) + allocateIf2("params:request.params,", isDynamic) + getPath + allocateIf2("url:request.url,", hasTrace || inference.url || inference.query) + "redirect,error:status,status,set:{headers:" + (isNotEmpty(defaultHeaders) ? "Object.assign({},app.setHeaders)" : "Object.create(null)") + ",status:200}", inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  {
    let decoratorsLiteral = "";
    for (let key of Object.keys(app.singleton.decorator))
      decoratorsLiteral += `,'${key}':decorator['${key}']`;
    fnLiteral += decoratorsLiteral;
  }
  return fnLiteral += `}
`, fnLiteral;
};
var createBunRouteHandler = (app, route) => {
  let hasTrace = !!app.event.trace?.length, hasHoc = !!app.extender.higherOrderFunctions.length, inference = sucrose(route.hooks, app.inference);
  inference = sucrose({ handler: route.handler }, inference);
  let fnLiteral = "const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse," + allocateIf2("randomId=data.randomId,", hasTrace) + allocateIf2("ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,", hasTrace) + allocateIf2("ELYSIA_TRACE=data.ELYSIA_TRACE,", hasTrace) + allocateIf2("trace=data.trace,", hasTrace) + allocateIf2("hoc=data.hoc,", hasHoc) + `status=data.status
`;
  if (app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (fnLiteral += `${app.event.request?.find(isAsync) ? "async" : ""} function map(request){`, hasTrace || inference.query || app.event.request?.length)
    fnLiteral += createContext(app, route, inference), fnLiteral += createOnRequestHandler(app), fnLiteral += "return handler(c)}";
  else
    fnLiteral += `return handler(${createContext(app, route, inference, true)})}`;
  return fnLiteral += createHoc(app), Function("data", fnLiteral)({ app, handler: route.compile?.() ?? route.composed, redirect, status, hoc: app.extender.higherOrderFunctions.map((x) => x.fn), store: app.store, decorator: app.decorator, route: route.path, randomId: hasTrace ? randomId : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, trace: hasTrace ? app.event.trace?.map((x) => x?.fn ?? x) : undefined, mapEarlyResponse: mapEarlyResponse2 });
};
var createNativeStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  if (typeof handle === "object" && handle?.toString() === "[object HTMLBundle]")
    return () => handle;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length) {
    if (response instanceof Promise)
      return response.then((response2) => {
        if (!response2)
          return;
        if (!response2.headers.has("content-type"))
          response2.headers.append("content-type", "text/plain");
        return response2.clone();
      });
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain");
    return response.clone.bind(response);
  }
};
var websocket = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS {
  raw;
  data;
  body;
  validator;
  ["~types"];
  get id() {
    return this.data.id;
  }
  constructor(raw, data, body = undefined) {
    this.raw = raw;
    this.data = data;
    this.body = body;
    this.validator = raw.data?.validator, this.sendText = raw.sendText.bind(raw), this.sendBinary = raw.sendBinary.bind(raw), this.close = raw.close.bind(raw), this.terminate = raw.terminate.bind(raw), this.publishText = raw.publishText.bind(raw), this.publishBinary = raw.publishBinary.bind(raw), this.subscribe = raw.subscribe.bind(raw), this.unsubscribe = raw.unsubscribe.bind(raw), this.isSubscribed = raw.isSubscribed.bind(raw), this.cork = raw.cork.bind(raw), this.remoteAddress = raw.remoteAddress, this.binaryType = raw.binaryType, this.data = raw.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  sendText;
  sendBinary;
  close;
  terminate;
  publishText;
  publishBinary;
  subscribe;
  unsubscribe;
  isSubscribed;
  cork;
  remoteAddress;
  binaryType;
  get readyState() {
    return this.raw.readyState;
  }
}
var createWSMessageParser = (parse22) => {
  let parsers = typeof parse22 === "function" ? [parse22] : parse22;
  return async function parseMessage(ws, message) {
    if (typeof message === "string") {
      let start = message?.charCodeAt(0);
      if (start === 34 || start === 47 || start === 91 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {
        }
      else if (isNumericString(message))
        message = +message;
      else if (message === "true")
        message = true;
      else if (message === "false")
        message = false;
      else if (message === "null")
        message = null;
    }
    if (parsers)
      for (let i = 0;i < parsers.length; i++) {
        let temp = parsers[i](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError("message", validateResponse, first).message);
        if (send(first.value), !first.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var optionalParam = /:.+?\?(?=\/|$)/;
var getPossibleParams = (path) => {
  let match = optionalParam.exec(path);
  if (!match)
    return [path];
  let routes = [], head = path.slice(0, match.index), param = match[0].slice(0, -1), tail = path.slice(match.index + match[0].length);
  routes.push(head.slice(0, -1)), routes.push(head + param);
  for (let fragment of getPossibleParams(tail)) {
    if (!fragment)
      continue;
    if (!fragment.startsWith("/:"))
      routes.push(head.slice(0, -1) + fragment);
    routes.push(head + param + fragment);
  }
  return routes;
};
var supportedMethods = { GET: true, HEAD: true, OPTIONS: true, DELETE: true, PATCH: true, POST: true, PUT: true };
var mapRoutes = (app) => {
  if (!app.config.aot || !app.config.systemRouter)
    return;
  let routes = {}, add = (route, handler) => {
    if (routes[route.path]) {
      if (!routes[route.path][route.method])
        routes[route.path][route.method] = handler;
    } else
      routes[route.path] = { [route.method]: handler };
  }, tree = app.routeTree;
  for (let route of app.router.history) {
    if (typeof route.handler !== "function")
      continue;
    let method = route.method;
    if (method === "GET" && `WS_${route.path}` in tree || method === "WS" || route.path.charCodeAt(route.path.length - 1) === 42 || !(method in supportedMethods))
      continue;
    if (method === "ALL") {
      if (!(`WS_${route.path}` in tree))
        routes[route.path] = route.hooks?.config?.mount ? route.hooks.trace || app.event.trace || app.extender.higherOrderFunctions ? createBunRouteHandler(app, route) : route.hooks.mount || route.handler : route.handler;
      continue;
    }
    let compiled, handler = app.config.precompile ? createBunRouteHandler(app, route) : (request) => {
      if (compiled)
        return compiled(request);
      return (compiled = createBunRouteHandler(app, route))(request);
    };
    for (let path of getPossibleParams(route.path))
      add({ method, path }, handler);
  }
  return routes;
};
var mergeRoutes = (r1, r2) => {
  if (!r2)
    return r1;
  for (let key of Object.keys(r2)) {
    if (r1[key] === r2[key])
      continue;
    if (!r1[key]) {
      r1[key] = r2[key];
      continue;
    }
    if (r1[key] && r2[key]) {
      if (typeof r1[key] === "function" || r1[key] instanceof Response) {
        r1[key] = r2[key];
        continue;
      }
      r1[key] = { ...r1[key], ...r2[key] };
    }
  }
  return r1;
};
var BunAdapter = { ...WebStandardAdapter, name: "bun", handler: { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2, mapCompactResponse: mapCompactResponse2, createStaticHandler: createStaticHandler2, createNativeStaticHandler }, composeHandler: { ...WebStandardAdapter.composeHandler, headers: hasHeaderShorthand ? `c.headers=c.request.headers.toJSON()
` : `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
` }, listen(app) {
  return (options, callback) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (app.compile(), typeof options === "string") {
      if (!isNumericString(options))
        throw new Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let createStaticRoute = (iterator3, { withAsync = false } = {}) => {
      let staticRoutes = {}, ops = [];
      for (let [path, route] of Object.entries(iterator3))
        if (supportPerMethodInlineHandler) {
          if (!route)
            continue;
          for (let [method, value26] of Object.entries(route)) {
            if (!value26 || !(method in supportedMethods))
              continue;
            if (value26 instanceof Promise) {
              if (withAsync) {
                if (!staticRoutes[path])
                  staticRoutes[path] = {};
                ops.push(value26.then((awaited2) => {
                  if (awaited2 instanceof Response)
                    staticRoutes[path][method] = awaited2;
                  if (typeof awaited2 === "object" && awaited2?.toString() === "[object HTMLBundle]")
                    staticRoutes[path][method] = awaited2;
                }));
              }
              continue;
            }
            if (!(value26 instanceof Response) && !(typeof value26 === "object" && value26?.toString() === "[object HTMLBundle]"))
              continue;
            if (!staticRoutes[path])
              staticRoutes[path] = {};
            staticRoutes[path][method] = value26;
          }
        } else {
          if (!route)
            continue;
          if (route instanceof Promise) {
            if (withAsync) {
              if (!staticRoutes[path])
                staticRoutes[path] = {};
              ops.push(route.then((awaited2) => {
                if (awaited2 instanceof Response)
                  staticRoutes[path] = awaited2;
              }));
            }
            continue;
          }
          if (!(route instanceof Response))
            continue;
          staticRoutes[path] = route;
        }
      if (withAsync)
        return Promise.all(ops).then(() => staticRoutes);
      return staticRoutes;
    }, serve = typeof options === "object" ? { development: !isProduction, reusePort: true, ...app.config.serve || {}, ...options || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {} }, fetch: app.fetch } : { development: !isProduction, reusePort: true, ...app.config.serve || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {} }, port: options, fetch: app.fetch };
    if (app.server = Bun.serve(serve), app.event.start)
      for (let i = 0;i < app.event.start.length; i++)
        app.event.start[i].fn(app);
    if (callback)
      callback(app.server);
    process.on("beforeExit", () => {
      if (app.server) {
        if (app.server.stop?.(), app.server = null, app.event.stop)
          for (let i = 0;i < app.event.stop.length; i++)
            app.event.stop[i].fn(app);
      }
    }), app.promisedModules.then(async () => {
      app.server?.reload({ ...serve, fetch: app.fetch, routes: mergeRoutes(mergeRoutes(await createStaticRoute(app.router.response, { withAsync: true }), mapRoutes(app)), app.config.serve?.routes) }), Bun?.gc(false);
    });
  };
}, ws(app, path, options) {
  let { parse: parse22, body, response, ...rest } = options, validateMessage = getSchemaValidator(body, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize }), validateResponse = getSchemaValidator(response, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize });
  app.route("WS", path, async (context) => {
    let server = app.getServer(), { set: set2, path: path2, qi, headers, query, params } = context;
    if (context.validator = validateResponse, options.upgrade) {
      if (typeof options.upgrade === "function") {
        let temp = options.upgrade(context);
        if (temp instanceof Promise)
          await temp;
      } else if (options.upgrade)
        Object.assign(set2.headers, options.upgrade);
    }
    if (set2.cookie && isNotEmpty(set2.cookie)) {
      let cookie = serializeCookie(set2.cookie);
      if (cookie)
        set2.headers["set-cookie"] = cookie;
    }
    if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
    let handleResponse3 = createHandleWSResponse(validateResponse), parseMessage = createWSMessageParser(parse22), _id;
    if (typeof options.beforeHandle === "function") {
      let result = options.beforeHandle(context);
      if (result instanceof Promise)
        await result;
    }
    let errorHandlers = [...Array.isArray(options.error) ? options.error : [options.error], ...(app.event.error ?? []).map((x) => typeof x === "function" ? x : x.fn)].filter((x) => x), handleErrors = !errorHandlers.length ? () => {
    } : async (ws, error23) => {
      for (let handleError of errorHandlers) {
        let response2 = handleError(Object.assign(context, { error: error23 }));
        if (response2 instanceof Promise)
          response2 = await response2;
        if (await handleResponse3(ws, response2), response2)
          break;
      }
    };
    if (server?.upgrade(context.request, { headers: isNotEmpty(set2.headers) ? set2.headers : undefined, data: { ...context, get id() {
      if (_id)
        return _id;
      return _id = randomId();
    }, validator: validateResponse, ping(data) {
      options.ping?.(data);
    }, pong(data) {
      options.pong?.(data);
    }, open(ws) {
      try {
        handleResponse3(ws, options.open?.(new ElysiaWS(ws, context)));
      } catch (error23) {
        handleErrors(ws, error23);
      }
    }, message: async (ws, _message) => {
      let message = await parseMessage(ws, _message);
      if (validateMessage?.Check(message) === false)
        return void ws.send(new ValidationError("message", validateMessage, message).message);
      try {
        handleResponse3(ws, options.message?.(new ElysiaWS(ws, context, message), message));
      } catch (error23) {
        handleErrors(ws, error23);
      }
    }, drain(ws) {
      try {
        handleResponse3(ws, options.drain?.(new ElysiaWS(ws, context)));
      } catch (error23) {
        handleErrors(ws, error23);
      }
    }, close(ws, code, reason) {
      try {
        handleResponse3(ws, options.close?.(new ElysiaWS(ws, context), code, reason));
      } catch (error23) {
        handleErrors(ws, error23);
      }
    } } }))
      return;
    return set2.status = 400, "Expected a websocket connection";
  }, { ...rest, websocket: options });
} };
var env2 = isBun ? Bun.env : typeof process !== "undefined" && process?.env ? process.env : {};
var injectDefaultValues = (typeChecker, obj) => {
  for (let [key, keySchema] of Object.entries(typeChecker.schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
  let { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler;
  return async (request) => {
    let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set2 = { cookie: {}, status: 200, headers: {} }, context = Object.assign({}, app.singleton.decorator, { set: set2, store: app.singleton.store, request, path, qi, error: status, status, redirect });
    try {
      if (app.event.request)
        for (let i = 0;i < app.event.request.length; i++) {
          let onRequest = app.event.request[i].fn, response2 = onRequest(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 = mapEarlyResponse3(response2, set2), response2)
            return context.response = response2;
        }
      let methodKey = request.method === "GET" && request.headers.get("upgrade")?.toLowerCase() === "websocket" ? "WS" : request.method, handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find(methodKey, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw new NotFoundError;
      let { handle, hooks, validator, content, route } = handler.store, body;
      if (request.method !== "GET" && request.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value26 = form2.getAll(key);
                if (value26.length === 1)
                  body[key] = value26[0];
                else
                  body[key] = value26;
              }
              break;
          }
        else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            if (context.contentType = contentType, hooks.parse)
              for (let i = 0;i < hooks.parse.length; i++) {
                let hook = hooks.parse[i].fn, temp = hook(context, contentType);
                if (temp instanceof Promise)
                  temp = await temp;
                if (temp) {
                  body = temp;
                  break;
                }
              }
            if (delete context.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value26 = form2.getAll(key);
                    if (value26.length === 1)
                      body[key] = value26[0];
                    else
                      body[key] = value26;
                  }
                  break;
              }
          }
        }
      context.route = route, context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), context.headers = {};
      for (let [key, value26] of request.headers.entries())
        context.headers[key] = value26;
      let cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config), cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? { secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined, sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined } : undefined);
      let headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues(headerValidator, context.headers);
      let paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues(paramsValidator, context.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues(queryValidator, context.query);
      if (hooks.transform)
        for (let i = 0;i < hooks.transform.length; i++) {
          let hook = hooks.transform[i], response2 = hook.fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "derive")
            Object.assign(context, response2);
        }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context.headers);
          for (let [key, value26] of request.headers)
            _header[key] = value26;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context.headers = validator.headers.Decode(context.headers);
        if (paramsValidator?.Check(context.params) === false)
          throw new ValidationError("params", validator.params, context.params);
        else if (validator.params?.Decode)
          context.params = validator.params.Decode(context.params);
        if (queryValidator?.Check(context.query) === false)
          throw new ValidationError("query", validator.query, context.query);
        else if (validator.query?.Decode)
          context.query = validator.query.Decode(context.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value26] of Object.entries(context.cookie))
            cookieValue[key] = value26.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
        else if (validator.body?.Decode)
          context.body = validator.body.Decode(body);
      }
      if (hooks.beforeHandle)
        for (let i = 0;i < hooks.beforeHandle.length; i++) {
          let hook = hooks.beforeHandle[i], response2 = hook.fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "resolve") {
            Object.assign(context, response2);
            continue;
          }
          if (response2 !== undefined) {
            if (context.response = response2, hooks.afterHandle)
              for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
                let newResponse = hooks.afterHandle[i2].fn(context);
                if (newResponse instanceof Promise)
                  newResponse = await newResponse;
                if (newResponse)
                  response2 = newResponse;
              }
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
        }
      let response = typeof handle === "function" ? handle(context) : handle;
      if (response instanceof Promise)
        response = await response;
      if (hooks.afterHandle)
        if (!hooks.afterHandle.length) {
          let status2 = response instanceof ElysiaCustomStatusResponse ? response.code : set2.status ? typeof set2.status === "string" ? StatusMap[set2.status] : set2.status : 200, responseValidator = validator?.createResponse?.()?.[status2];
          if (responseValidator?.Check(response) === false)
            throw new ValidationError("response", responseValidator, response);
          else if (responseValidator?.Decode)
            response = responseValidator.Decode(response);
        } else {
          context.response = response;
          for (let i = 0;i < hooks.afterHandle.length; i++) {
            let newResponse = hooks.afterHandle[i].fn(context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            let result = mapEarlyResponse3(newResponse, context.set);
            if (result !== undefined) {
              let responseValidator = validator?.response?.[result.status];
              if (responseValidator?.Check(result) === false)
                throw new ValidationError("response", responseValidator, result);
              else if (responseValidator?.Decode)
                response = responseValidator.Decode(response);
              return context.response = result;
            }
          }
        }
      if (context.set.cookie && cookieMeta?.sign) {
        let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (let [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
        else {
          let properties = validator?.cookie?.schema?.properties;
          for (let name of cookieMeta.sign) {
            if (!(name in properties))
              continue;
            if (context.set.cookie[name]?.value)
              context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
          }
        }
      }
      return mapResponse3(context.response = response, context.set);
    } catch (error23) {
      let reportedError = error23 instanceof TransformDecodeError && error23.error ? error23.error : error23;
      return app.handleError(context, reportedError);
    } finally {
      if (app.event.afterResponse)
        for (let afterResponse of app.event.afterResponse)
          await afterResponse.fn(context);
    }
  };
};
var createDynamicErrorHandler = (app) => {
  let { mapResponse: mapResponse3 } = app["~adapter"].handler;
  return async (context, error23) => {
    let errorContext = Object.assign(context, { error: error23, code: error23.code });
    if (errorContext.set = context.set, app.event.error)
      for (let i = 0;i < app.event.error.length; i++) {
        let response = app.event.error[i].fn(errorContext);
        if (response instanceof Promise)
          response = await response;
        if (response !== undefined && response !== null)
          return context.response = mapResponse3(response, context.set);
      }
    return new Response(typeof error23.cause === "string" ? error23.cause : error23.message, { headers: context.set.headers, status: error23.status ?? 500 });
  };
};

class Elysia {
  config;
  server = null;
  dependencies = {};
  "~Prefix" = "";
  "~Singleton" = null;
  "~Definitions" = null;
  "~Metadata" = null;
  "~Ephemeral" = null;
  "~Volatile" = null;
  "~Routes" = null;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  definitions = { typebox: t.Module({}), type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    if (!this.global && !this.scoped && !this.local)
      return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
    return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
  } };
  standaloneValidator = { global: null, scoped: null, local: null };
  event = {};
  telemetry;
  router = { "~http": undefined, get http() {
    if (!this["~http"])
      this["~http"] = new _({ lazy: true });
    return this["~http"];
  }, "~dynamic": undefined, get dynamic() {
    if (!this["~dynamic"])
      this["~dynamic"] = new _;
    return this["~dynamic"];
  }, static: {}, response: {}, history: [] };
  routeTree = {};
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getGlobalDefinitions() {
    return this.definitions;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false, path: false, route: false, url: false };
  getServer() {
    return this.server;
  }
  getParent() {
    return null;
  }
  "~parser" = {};
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup(console.error, () => {
      });
    return this._promisedModules;
  }
  constructor(config = {}) {
    if (config.tags)
      if (!config.detail)
        config.detail = { tags: config.tags };
      else
        config.detail.tags = config.tags;
    if (this.config = { prefix: "", aot: env2.ELYSIA_AOT !== "false", nativeStaticResponse: true, systemRouter: true, encodeSchema: true, normalize: true, ...config, cookie: { path: "/", ...config?.cookie }, experimental: config?.experimental ?? {}, seed: config?.seed === undefined ? "" : config?.seed }, this["~adapter"] = config.adapter ?? (typeof Bun !== "undefined" ? BunAdapter : WebStandardAdapter), config?.analytic && (config?.name || config?.seed !== undefined))
      this.telemetry = { stack: new Error().stack };
  }
  "~adapter";
  env(model, _env = env2) {
    if (getSchemaValidator(model, { modules: this.definitions.typebox, dynamic: true, additionalProperties: true, coerce: true, sanitize: () => this.config.sanitize }).Check(_env) === false) {
      let error23 = new ValidationError("env", model, _env);
      throw new Error(error23.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn.toString() })), fn }), this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      let manage = createMacroManager({ globalHook: this.event, localHook }), manager = { events: { global: this.event, local: localHook }, get onParse() {
        return manage("parse");
      }, get onTransform() {
        return manage("transform");
      }, get onBeforeHandle() {
        return manage("beforeHandle");
      }, get onAfterHandle() {
        return manage("afterHandle");
      }, get mapResponse() {
        return manage("mapResponse");
      }, get onAfterResponse() {
        return manage("afterResponse");
      }, get onError() {
        return manage("error");
      } };
      for (let macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook, manage);
    }
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, options, standaloneValidators) {
    let skipPrefix = options?.skipPrefix ?? false, allowMeta = options?.allowMeta ?? false;
    if (localHook ??= {}, standaloneValidators === undefined) {
      if (standaloneValidators = [], this.standaloneValidator.local)
        standaloneValidators = standaloneValidators.concat(this.standaloneValidator.local);
      if (this.standaloneValidator.scoped)
        standaloneValidators = standaloneValidators.concat(this.standaloneValidator.scoped);
      if (this.standaloneValidator.global)
        standaloneValidators = standaloneValidators.concat(this.standaloneValidator.global);
    }
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let instanceValidator = this.validator.getCandidate(), cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, createValidator = () => {
      let models = this.definitions.type, dynamic = !this.config.aot, normalize = this.config.normalize, modules = this.definitions.typebox, sanitize2 = () => this.config.sanitize, cookieValidator = () => {
        if (cloned.cookie || standaloneValidators.find((x) => x.cookie))
          return getCookieValidator({ modules, validator: cloned.cookie, defaultConfig: this.config.cookie, config: cloned.cookie?.config ?? {}, dynamic, models, validators: standaloneValidators.map((x) => x.cookie), sanitize: sanitize2 });
      };
      return shouldPrecompile ? { body: getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x) => x.body), sanitize: sanitize2 }), headers: getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.headers), sanitize: sanitize2 }), params: getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.params), sanitize: sanitize2 }), query: getSchemaValidator(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.query), sanitize: sanitize2 }), cookie: cookieValidator(), response: getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize, validators: standaloneValidators.map((x) => x.response), sanitize: sanitize2 }) } : { createBody() {
        if (this.body)
          return this.body;
        return this.body = getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x) => x.body), sanitize: sanitize2 });
      }, createHeaders() {
        if (this.headers)
          return this.headers;
        return this.headers = getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: !normalize, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.headers), sanitize: sanitize2 });
      }, createParams() {
        if (this.params)
          return this.params;
        return this.params = getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.params), sanitize: sanitize2 });
      }, createQuery() {
        if (this.query)
          return this.query;
        return this.query = getSchemaValidator(cloned.query, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.query), sanitize: sanitize2 });
      }, createCookie() {
        if (this.cookie)
          return this.cookie;
        return this.cookie = cookieValidator();
      }, createResponse() {
        if (this.response)
          return this.response;
        return this.response = getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize, validators: standaloneValidators.map((x) => x.response), sanitize: sanitize2 });
      } };
    };
    if (instanceValidator.body || instanceValidator.cookie || instanceValidator.headers || instanceValidator.params || instanceValidator.query || instanceValidator.response)
      localHook = mergeHook(localHook, instanceValidator);
    if (localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    let hooks = isNotEmpty(this.event) ? mergeHook(this.event, localHookToLifeCycleStore(localHook)) : lifeCycleToArray(localHookToLifeCycleStore(localHook));
    if (this.config.aot === false) {
      let validator = createValidator();
      this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle, route: path });
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.dynamic.add(method, encoded, { validator, hooks, content: localHook?.type, handle, route: path });
      if (this.config.strictPath === false) {
        let loosePath = getLoosePath(path);
        this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
        let encoded2 = encodePath(loosePath);
        if (loosePath !== encoded2)
          this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
      }
      this.router.history.push({ method, path, composed: null, handler: handle, compile: undefined, hooks, standaloneValidators });
      return;
    }
    let adapter = this["~adapter"].handler, nativeStaticHandler = typeof handle !== "function" ? () => {
      let fn = adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders);
      return fn instanceof Promise ? fn.then((fn2) => {
        if (fn2)
          return fn2;
      }) : fn?.();
    } : undefined, useNativeStaticResponse = this.config.nativeStaticResponse === true, addResponsePath = (path2) => {
      if (!useNativeStaticResponse || !nativeStaticHandler)
        return;
      if (supportPerMethodInlineHandler)
        if (this.router.response[path2])
          this.router.response[path2][method] = nativeStaticHandler();
        else
          this.router.response[path2] = { [method]: nativeStaticHandler() };
      else
        this.router.response[path2] = nativeStaticHandler();
    };
    addResponsePath(path);
    let _compiled, compile2 = () => {
      if (_compiled)
        return _compiled;
      return _compiled = composeHandler({ app: this, path, method, hooks, validator: createValidator(), handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle, allowMeta, inference: this.inference });
    }, oldIndex;
    if (`${method}_${path}` in this.routeTree)
      for (let i = 0;i < this.router.history.length; i++) {
        let route = this.router.history[i];
        if (route.path === path && route.method === method) {
          oldIndex = i;
          break;
        }
      }
    else
      this.routeTree[`${method}_${path}`] = this.router.history.length;
    let index = oldIndex ?? this.router.history.length, mainHandler = shouldPrecompile ? compile2() : (ctx) => (this.router.history[index].composed = compile2())(ctx);
    if (oldIndex !== undefined)
      this.router.history[oldIndex] = Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, standaloneValidators.length ? { standaloneValidators } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined);
    else
      this.router.history.push(Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, standaloneValidators.length ? { standaloneValidators } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined));
    let handler = { handler: shouldPrecompile ? mainHandler : undefined, compile() {
      return this.handler = compile2();
    } }, staticRouter = this.router.static, isStaticPath = path.indexOf(":") === -1 && path.indexOf("*") === -1;
    if (method === "WS") {
      if (isStaticPath) {
        if (path in staticRouter)
          staticRouter[path][method] = index;
        else
          staticRouter[path] = { [method]: index };
        return;
      }
      if (this.router.http.add("WS", path, handler), !this.config.strictPath)
        this.router.http.add("WS", getLoosePath(path), handler);
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add("WS", encoded, handler);
      return;
    }
    if (isStaticPath) {
      if (path in staticRouter)
        staticRouter[path][method] = index;
      else
        staticRouter[path] = { [method]: index };
      if (!this.config.strictPath)
        addResponsePath(getLoosePath(path));
    } else {
      if (this.router.http.add(method, path, handler), !this.config.strictPath) {
        let loosePath = getLoosePath(path);
        addResponsePath(loosePath), this.router.http.add(method, loosePath, handler);
      }
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add(method, encoded, handler), addResponsePath(encoded);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error23) {
    switch (typeof name) {
      case "string":
        return error23.prototype[ERROR_CODE] = name, this.definitions.error[name] = error23, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error32] of Object.entries(name))
      error32.prototype[ERROR_CODE] = code, this.definitions.error[code] = error32;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type54;
    switch (typeof optionsOrType) {
      case "string":
        type54 = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type54 = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      if (handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local", type54 === "resolve" || type54 === "derive")
        handle.subType = type54;
    if (type54 !== "trace")
      this.inference = sucrose({ [type54]: handles.map((x) => x.fn) }, this.inference);
    for (let handle of handles) {
      let fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type54) {
        case "start":
          this.event.start ??= [], this.event.start.push(fn);
          break;
        case "request":
          this.event.request ??= [], this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse ??= [], this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform ??= [], this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform ??= [], this.event.transform.push(fnToContainer(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle ??= [], this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse ??= [], this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse ??= [], this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace ??= [], this.event.trace.push(fn);
          break;
        case "error":
          this.event.error ??= [], this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop ??= [], this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  as(type54) {
    if (promoteEvent(this.event.parse, type54), promoteEvent(this.event.transform, type54), promoteEvent(this.event.beforeHandle, type54), promoteEvent(this.event.afterHandle, type54), promoteEvent(this.event.mapResponse, type54), promoteEvent(this.event.afterResponse, type54), promoteEvent(this.event.trace, type54), promoteEvent(this.event.error, type54), type54 === "scoped") {
      if (this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
    } else if (type54 === "global") {
      if (this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
      if (this.standaloneValidator.scoped !== null)
        this.standaloneValidator.global ||= [], this.standaloneValidator.global.push(...this.standaloneValidator.scoped), this.standaloneValidator.scoped = null;
    }
    return this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance["~parser"] = this["~parser"], instance.standaloneValidator = { local: [...this.standaloneValidator.local ?? []], scoped: [...this.standaloneValidator.scoped ?? []], global: [...this.standaloneValidator.global ?? []] };
    let isSchema = typeof schemaOrRun === "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks, standaloneValidators }) => {
      if (path = (isSchema ? "" : this.config.prefix) + prefix + path, isSchema) {
        let hook = schemaOrRun, localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox.event.error ?? []] : [localHook.error, ...sandbox.event.error ?? []] }), undefined, standaloneValidators);
      } else
        this.add(method, path, handler, mergeHook(hooks, { error: sandbox.event.error }), { skipPrefix: true }, standaloneValidators);
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        if (this.applyMacro(hook), hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        let type54 = hook.as ?? "local";
        if (hook.schema === "standalone") {
          if (!this.standaloneValidator[type54])
            this.standaloneValidator[type54] = [];
          let response = hook?.response || typeof hook?.response === "string" || hook?.response && Kind in hook.response ? { 200: hook.response } : hook?.response;
          this.standaloneValidator[type54].push({ body: hook.body, headers: hook.headers, params: hook.params, query: hook.query, response, cookie: hook.cookie });
        } else
          this.validator[type54] = { body: hook.body ?? this.validator[type54]?.body, headers: hook.headers ?? this.validator[type54]?.headers, params: hook.params ?? this.validator[type54]?.params, query: hook.query ?? this.validator[type54]?.query, response: hook.response ?? this.validator[type54]?.response, cookie: hook.cookie ?? this.validator[type54]?.cookie };
        if (hook.parse)
          this.on({ as: type54 }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type54 }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type54 }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type54 }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type54 }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type54 }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type54 }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type54 }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type54 }, "error", hook.error);
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender };
    let sandbox = run(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox.event.error ?? []] : [localHook.error, ...sandbox.event.error ?? []] }));
    }), this;
  }
  use(plugin) {
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2.default);
        if (plugin2.constructor.name === "_Elysia")
          return this._use(plugin2.default);
        try {
          return this._use(plugin2.default);
        } catch (error23) {
          throw console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'), error23;
        }
      }).then((v) => {
        if (v && typeof v.compile === "function")
          v.compile();
        return v;
      })), this;
    return this._use(plugin);
  }
  propagatePromiseModules(plugin) {
    if (plugin.promisedModules.size <= 0)
      return this;
    for (let promise2 of plugin.promisedModules.promises)
      this.promisedModules.add(promise2.then((v) => {
        if (!v)
          return;
        let t2 = this._use(v);
        if (t2 instanceof Promise)
          return t2.then((v2) => {
            if (v2)
              v2.compile();
            else
              v.compile();
          });
        return v.compile();
      }));
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks, standaloneValidators } of Object.values(plugin2.router.history))
              this.add(method, path, handler, isNotEmpty(plugin2.event.error) ? mergeHook(hooks, { error: plugin2.event.error }) : hooks, undefined, standaloneValidators);
            if (plugin2 === this)
              return;
            return this.propagatePromiseModules(plugin2), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((v) => {
          if (v && typeof v.compile === "function")
            v.compile();
          return v;
        })), this;
      return instance;
    }
    this.propagatePromiseModules(plugin);
    let name = plugin.config.name, seed = plugin.config.seed;
    if (plugin.getParent = () => this, plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin.standaloneValidator?.scoped)
      if (this.standaloneValidator.local)
        this.standaloneValidator.local = this.standaloneValidator.local.concat(plugin.standaloneValidator.scoped);
      else
        this.standaloneValidator.local = plugin.standaloneValidator.scoped;
    if (plugin.standaloneValidator?.global)
      if (this.standaloneValidator.global)
        this.standaloneValidator.global = this.standaloneValidator.global.concat(plugin.standaloneValidator.global);
      else
        this.standaloneValidator.global = plugin.standaloneValidator.global;
    if (isNotEmpty(plugin["~parser"]))
      this["~parser"] = { ...plugin["~parser"], ...this["~parser"] };
    if (plugin.setHeaders)
      this.headers(plugin.setHeaders);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    } else {
      if (plugin.extender.macros.length)
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      if (plugin.extender.higherOrderFunctions.length)
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    }
    if (deduplicateChecksum(this.extender.macros), plugin.extender.higherOrderFunctions.length) {
      deduplicateChecksum(this.extender.higherOrderFunctions);
      let hofHashes = [];
      for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
        let hof = this.extender.higherOrderFunctions[i];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum))
            this.extender.higherOrderFunctions.splice(i, 1), i--;
          hofHashes.push(hof.checksum);
        }
      }
      hofHashes.length = 0;
    }
    if (this.inference = mergeInference(this.inference, plugin.inference), isNotEmpty(plugin.singleton.decorator))
      this.decorate(plugin.singleton.decorator);
    if (isNotEmpty(plugin.singleton.store))
      this.state(plugin.singleton.store);
    if (isNotEmpty(plugin.definitions.type))
      this.model(plugin.definitions.type);
    if (isNotEmpty(plugin.definitions.error))
      this.error(plugin.definitions.error);
    if (isNotEmpty(plugin.definitions.error))
      plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
    for (let { method, path, handler, hooks, standaloneValidators } of Object.values(plugin.router.history))
      this.add(method, path, handler, isNotEmpty(plugin.event.error) ? mergeHook(hooks, { error: plugin.event.error }) : hooks, undefined, standaloneValidators);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        return this;
      if (this.dependencies[name].push(this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry?.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, error: plugin.definitions.error, derive: plugin.event.transform?.filter((x) => x?.subType === "derive").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })), resolve: plugin.event.transform?.filter((x) => x?.subType === "resolve").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })) } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies }), isNotEmpty(plugin.event))
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
    } else if (isNotEmpty(plugin.event))
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    if (plugin.validator.global)
      this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global });
    if (plugin.validator.scoped)
      this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped });
    return this;
  }
  macro(macro) {
    if (typeof macro === "function") {
      let hook = { checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: macro.toString() })), fn: macro };
      this.extender.macros.push(hook);
    } else if (typeof macro === "object") {
      for (let name of Object.keys(macro))
        if (typeof macro[name] === "object") {
          let actualValue = { ...macro[name] };
          macro[name] = (v) => {
            if (v === true)
              return actualValue;
          };
        }
      let hook = { checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: Object.entries(macro).map(([k2, v]) => `${k2}+${v}`).join(",") })), fn: () => macro };
      this.extender.macros.push(hook);
    }
    return this;
  }
  mount(path, handleOrConfig, config) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      let run = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
        throw new Error("Invalid handler");
      })(), handler2 = ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2), { method: request.method, headers: request.headers, signal: request.signal, credentials: request.credentials, referrerPolicy: request.referrerPolicy, duplex: request.duplex, redirect: request.redirect, mode: request.mode, keepalive: request.keepalive, integrity: request.integrity, body: request.body }));
      return this.route("ALL", "/*", handler2, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: run } }), this;
    }
    let handle = handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
      throw new Error("Invalid handler");
    })(), length = path.length - (path.endsWith("*") ? 1 : 0), handler = ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), { method: request.method, headers: request.headers, signal: request.signal, credentials: request.credentials, referrerPolicy: request.referrerPolicy, duplex: request.duplex, redirect: request.redirect, mode: request.mode, keepalive: request.keepalive, integrity: request.integrity, body: request.body }));
    return this.route("ALL", path, handler, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: handle } }), this.route("ALL", path + (path.endsWith("/") ? "*" : "/*"), handler, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: handle } }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn("Current adapter doesn't support WebSocket");
    return this;
  }
  state(options, name, value26) {
    if (name === undefined)
      value26 = options, options = { as: "append" }, name = "";
    else if (value26 === undefined) {
      if (typeof options === "string")
        value26 = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value26 = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value26) {
      case "object":
        if (!value26 || !isNotEmpty(value26))
          return this;
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value26, { override: as === "override" });
          else
            this.singleton.store[name] = value26;
          return this;
        }
        if (value26 === null)
          return this;
        return this.singleton.store = mergeDeep(this.singleton.store, value26, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value26;
        } else
          this.singleton.store = value26(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value26;
        return this;
    }
  }
  decorate(options, name, value26) {
    if (name === undefined)
      value26 = options, options = { as: "append" }, name = "";
    else if (value26 === undefined) {
      if (typeof options === "string")
        value26 = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value26 = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value26) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value26, { override: as === "override" });
          else
            this.singleton.decorator[name] = value26;
          return this;
        }
        if (value26 === null)
          return this;
        return this.singleton.decorator = mergeDeep(this.singleton.decorator, value26, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value26;
        } else
          this.singleton.decorator = value26(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value26;
        return this;
    }
  }
  derive(optionsOrTransform, transform6) {
    if (!transform6)
      transform6 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform6 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        let parsedSchemas = {}, kvs = Object.entries(name);
        if (!kvs.length)
          return this;
        for (let [key, value26] of kvs) {
          if (key in this.definitions.type)
            continue;
          parsedSchemas[key] = this.definitions.type[key] = value26, parsedSchemas[key].$id ??= `#/components/schemas/${key}`;
        }
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...parsedSchemas }), this;
      case "function":
        let result = name(this.definitions.type);
        return this.definitions.type = result, this.definitions.typebox = t.Module(result), this;
      case "string":
        if (!model)
          break;
        let newModel = { ...model, id: model.$id ?? `#/components/schemas/${name}` };
        return this.definitions.type[name] = model, this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...newModel }), this;
    }
    return this.definitions.type[name] = model, this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, [name]: model }), this;
  }
  Ref(key) {
    return t.Ref(key);
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type54, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix), remap = (type210) => {
      let store = {};
      switch (type210) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type54) ? type54 : [type54];
    for (let type210 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type210);
    return this;
  }
  prefix(type54, word) {
    return this.affix("prefix", type54, word);
  }
  suffix(type54, word) {
    return this.affix("suffix", type54, word);
  }
  compile() {
    if (this["~adapter"].isWebStandard) {
      if (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload === "function")
        this.server.reload({ ...this.server || {}, fetch: this.fetch });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    return this._handle = composeGeneralHandler(this), this;
  }
  handle = async (request) => this.fetch(request);
  fetch = (request) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
  };
  handleError = async (context, error23) => {
    return (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error23);
  };
  listen = (options, callback) => {
    if (this["~adapter"].listen(this)(options, callback), this.promisedModules.size)
      clearSucroseCache(5000);
    return this.promisedModules.then(() => {
      clearSucroseCache(1000);
    }), this;
  };
  stop = async (closeActiveConnections) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop(closeActiveConnections), this.server = null, this.event.stop?.length)
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i].fn(this);
    }
  };
  get modules() {
    return this.promisedModules;
  }
}

// node_modules/@elysiajs/static/dist/index.mjs
var import_node_cache = __toESM(require_node_cache2(), 1);
import {readdir, stat as stat2} from "fs/promises";
import {resolve, resolve as resolveFn, join, sep} from "path";
import {stat as stat3} from "fs/promises";
async function isCached(headers, etag, filePath) {
  if (headers["cache-control"] && headers["cache-control"].indexOf("no-cache") !== -1)
    return false;
  if ("if-none-match" in headers) {
    const ifNoneMatch = headers["if-none-match"];
    if (ifNoneMatch === "*")
      return true;
    if (ifNoneMatch === null)
      return false;
    if (typeof etag !== "string")
      return false;
    const isMatching = ifNoneMatch === etag;
    if (isMatching)
      return true;
    return false;
  }
  if (headers["if-modified-since"]) {
    const ifModifiedSince = headers["if-modified-since"];
    let lastModified;
    try {
      lastModified = (await stat3(filePath)).mtime;
    } catch {
    }
    if (lastModified !== undefined && lastModified.getTime() <= Date.parse(ifModifiedSince))
      return true;
  }
  return false;
}
async function generateETag(file) {
  const hash5 = new Bun.CryptoHasher("md5");
  hash5.update(await file.arrayBuffer());
  return hash5.digest("base64");
}
var URL_PATH_SEP = "/";
var fileExists = (path) => stat2(path).then(() => true, () => false);
var statCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var fileCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var htmlCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var listFiles = async (dir) => {
  const files = await readdir(dir);
  const all = await Promise.all(files.map(async (name) => {
    const file = dir + sep + name;
    const stats = await stat2(file);
    return stats && stats.isDirectory() ? await listFiles(file) : [resolve(dir, file)];
  }));
  return all.flat();
};
var staticPlugin = async ({
  assets = "public",
  prefix = "/public",
  staticLimit = 1024,
  alwaysStatic = false,
  ignorePatterns = [".DS_Store", ".git", ".env"],
  noExtension = false,
  enableDecodeURI = false,
  resolve: resolve2 = resolveFn,
  headers = {},
  noCache = false,
  maxAge = 86400,
  directive = "public",
  indexHTML = true
} = {
  assets: "public",
  prefix: "/public",
  staticLimit: 1024,
  alwaysStatic: false,
  ignorePatterns: [],
  noExtension: false,
  enableDecodeURI: false,
  resolve: resolveFn,
  headers: {},
  noCache: false,
  indexHTML: true
}) => {
  const files = await listFiles(resolveFn(assets));
  const isFSSepUnsafe = sep !== URL_PATH_SEP;
  if (prefix === URL_PATH_SEP)
    prefix = "";
  const shouldIgnore = (file) => {
    if (!ignorePatterns.length)
      return false;
    return ignorePatterns.find((pattern2) => {
      if (typeof pattern2 === "string")
        return pattern2.includes(file);
      else
        return pattern2.test(file);
    });
  };
  const app = new Elysia({
    name: "static",
    seed: {
      assets,
      prefix,
      staticLimit,
      alwaysStatic,
      ignorePatterns,
      noExtension,
      enableDecodeURI,
      resolve: resolve2.toString(),
      headers,
      noCache,
      maxAge,
      directive,
      indexHTML
    }
  });
  const assetsDir = assets[0] === sep ? assets : resolve2() + sep + assets;
  if (alwaysStatic || process.env.ENV === "production" && files.length <= staticLimit)
    for (const absolutePath of files) {
      if (!absolutePath || shouldIgnore(absolutePath))
        continue;
      let relativePath = absolutePath.replace(assetsDir, "");
      if (noExtension) {
        const temp = relativePath.split(".");
        temp.splice(-1);
        relativePath = temp.join(".");
      }
      const file = Bun.file(absolutePath);
      const etag = await generateETag(file);
      const pathName = isFSSepUnsafe ? prefix + relativePath.split(sep).join(URL_PATH_SEP) : join(prefix, relativePath);
      app.get(pathName, noCache ? new Response(file, {
        headers
      }) : async ({ headers: reqHeaders }) => {
        if (await isCached(reqHeaders, etag, absolutePath)) {
          return new Response(null, {
            status: 304,
            headers
          });
        }
        headers["Etag"] = etag;
        headers["Cache-Control"] = directive;
        if (maxAge !== null)
          headers["Cache-Control"] += `, max-age=${maxAge}`;
        return new Response(file, {
          headers
        });
      });
      if (indexHTML && pathName.endsWith("/index.html"))
        app.get(pathName.replace("/index.html", ""), noCache ? new Response(file, {
          headers
        }) : async ({ headers: reqHeaders }) => {
          if (await isCached(reqHeaders, etag, pathName)) {
            return new Response(null, {
              status: 304,
              headers
            });
          }
          headers["Etag"] = etag;
          headers["Cache-Control"] = directive;
          if (maxAge !== null)
            headers["Cache-Control"] += `, max-age=${maxAge}`;
          return new Response(file, {
            headers
          });
        });
    }
  else {
    if (!app.router.history.find(({ method, path }) => path === `${prefix}/*` && method === "GET"))
      app.onError(() => {
      }).get(`${prefix}/*`, async ({ params, headers: reqHeaders }) => {
        let path = enableDecodeURI ? decodeURI(`${assets}/${decodeURI(params["*"])}`) : `${assets}/${params["*"]}`;
        if (isFSSepUnsafe) {
          path = path.replace(URL_PATH_SEP, sep);
        }
        if (shouldIgnore(path))
          throw new NotFoundError;
        try {
          let status2 = statCache.get(path);
          if (!status2) {
            status2 = await stat2(path);
            statCache.set(path, status2);
          }
          if (!indexHTML && status2.isDirectory())
            throw new NotFoundError;
          let file = fileCache.get(path);
          if (!file) {
            if (status2.isDirectory()) {
              let hasCache = false;
              if (indexHTML && (hasCache = htmlCache.get(`${path}${sep}index.html`) ?? await fileExists(`${path}${sep}index.html`))) {
                if (hasCache === undefined)
                  htmlCache.set(`${path}${sep}index.html`, true);
                file = Bun.file(`${path}${sep}index.html`);
              } else {
                if (indexHTML && hasCache === undefined)
                  htmlCache.set(`${path}${sep}index.html`, false);
                throw new NotFoundError;
              }
            }
            file ??= Bun.file(path);
            fileCache.set(path, file);
          }
          if (noCache)
            return new Response(file, {
              headers
            });
          const etag = await generateETag(file);
          if (await isCached(reqHeaders, etag, path))
            return new Response(null, {
              status: 304,
              headers
            });
          headers["Etag"] = etag;
          headers["Cache-Control"] = directive;
          if (maxAge !== null)
            headers["Cache-Control"] += `, max-age=${maxAge}`;
          return new Response(file, {
            headers
          });
        } catch (error23) {
          throw new NotFoundError;
        }
      });
  }
  return app;
};

// src/index.ts
init_logger();

// src/utils/metrics.ts
var import_prom_client = __toESM(require_prom_client(), 1);
import_prom_client.collectDefaultMetrics();
var wsConnections = new import_prom_client.Gauge({
  name: "websocket_connections_total",
  help: "Total number of active WebSocket connections"
});
var wsMessages = new import_prom_client.Counter({
  name: "websocket_messages_total",
  help: "Total number of WebSocket messages processed",
  labelNames: ["type", "status"]
});
var wsConnectionDuration = new import_prom_client.Histogram({
  name: "websocket_connection_duration_seconds",
  help: "Duration of WebSocket connections in seconds",
  buckets: [0.1, 0.5, 1, 5, 10, 30, 60, 300, 600, 1800, 3600]
});
var wsMessageLatency = new import_prom_client.Histogram({
  name: "websocket_message_latency_seconds",
  help: "WebSocket message processing latency in seconds",
  buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5]
});
var wsErrors = new import_prom_client.Counter({
  name: "websocket_errors_total",
  help: "Total number of WebSocket errors",
  labelNames: ["type"]
});
var appShutdownTime = new import_prom_client.Gauge({
  name: "websocket_shutdown_time_seconds",
  help: "Time taken to shutdown the application in seconds"
});
var httpRequests = new import_prom_client.Counter({
  name: "http_requests_total",
  help: "Total number of HTTP requests",
  labelNames: ["method", "endpoint", "status_code"]
});
var incrementConnection = () => wsConnections.inc();
var decrementConnection = () => wsConnections.dec();
var setConnectionCount = (count) => wsConnections.set(count);
var incrementMessage = (type54, status2) => wsMessages.inc({ type: type54, status: status2 });
var incrementHttpRequest = (method, endpoint, statusCode) => httpRequests.inc({ method, endpoint, status_code: statusCode });
var recordShutdownTime = (duration) => appShutdownTime.set(duration);
var getMetrics = async () => import_prom_client.register.metrics();
var getContentType = () => import_prom_client.register.contentType;

// src/utils/websocket.ts
init_logger();
init_redis();
async function gracefullyCloseConnection(ws, reason) {
  const connectionId = ws.data?.params?.connectionId;
  if (!connectionId) {
    logError("Cannot gracefully close connection: missing connectionId");
    return;
  }
  const total = connectionCounts.get(connectionId) || 0;
  logInfo("Gracefully closing connection", { connectionId, total, reason });
  try {
    await storeConnectionState(connectionId, total, {
      disconnectedAt: new Date().toISOString(),
      reason
    });
    ws.send({
      type: "shutdown",
      total,
      reason,
      bye: true,
      timestamp: new Date().toISOString()
    });
    setTimeout(() => {
      logInfo("Closing connection after delay", { connectionId });
      ws.raw.close(1001, "Normal closure");
    }, 100);
  } catch (error23) {
    logError("Error during graceful connection close", { connectionId, error: error23 });
    try {
      ws.raw.close(1001, "Server error");
    } catch (closeError) {
      logError("Error force closing connection", { connectionId, error: closeError });
    }
  }
}
function startHeartbeat(ws) {
  const intervalId = setInterval(() => {
    try {
      ws.send({ type: "heartbeat", timestamp: new Date().toISOString() });
    } catch (error23) {
      clearInterval(intervalId);
    }
  }, 30000);
  return intervalId;
}
var connectionCounts = new Map;
var heartbeatIntervals = new Map;
var activeConnections = new Map;
var handleWebSocketOpen = async (ws) => {
  const { connectionId } = ws.data.params;
  let messageCount = 0;
  let isReconnection = false;
  try {
    const storedState = await getConnectionState(connectionId);
    if (storedState && isRedisAvailable()) {
      messageCount = storedState.messageCount;
      isReconnection = true;
      logInfo("Connection reconnected", {
        connectionId,
        previousMessageCount: messageCount,
        lastActivity: new Date(storedState.lastActivity).toISOString()
      });
      try {
        ws.send({
          type: "reconnection",
          message: "Connection re-established",
          previousCount: messageCount,
          timestamp: new Date().toISOString()
        });
      } catch (sendError) {
        logError("Failed to send reconnection message", { connectionId, error: sendError });
      }
    } else {
      messageCount = 0;
      logInfo("New connection established", { connectionId });
      try {
        ws.send({
          type: "welcome",
          message: "Connection established",
          count: messageCount,
          timestamp: new Date().toISOString()
        });
      } catch (sendError) {
        logError("Failed to send welcome message", { connectionId, error: sendError });
      }
    }
    connectionCounts.set(connectionId, messageCount);
    await storeConnectionState(connectionId, messageCount, {
      connectedAt: new Date().toISOString(),
      isReconnection
    });
  } catch (error23) {
    logError("Error during connection open handling", { connectionId, error: error23 });
    messageCount = 0;
    connectionCounts.set(connectionId, messageCount);
  }
  const intervalId = startHeartbeat(ws);
  heartbeatIntervals.set(connectionId, intervalId);
  activeConnections.set(connectionId, ws);
  incrementConnection();
  logInfo("Connection opened successfully", {
    connectionId,
    messageCount,
    isReconnection,
    activeConnections: activeConnections.size
  });
};
var handleWebSocketMessage = async (ws, message) => {
  const { connectionId } = ws.data.params;
  if (typeof message === "object" && message !== null && "disconnect" in message) {
    const total = connectionCounts.get(connectionId) || 0;
    try {
      ws.send({
        type: "disconnect_ack",
        total,
        reason: "client_requested_disconnect",
        timestamp: new Date().toISOString()
      });
    } catch (sendError) {
      logError("Failed to send disconnect acknowledgment", { connectionId, error: sendError });
    }
    return;
  }
  const currentCount = (connectionCounts.get(connectionId) || 0) + 1;
  connectionCounts.set(connectionId, currentCount);
  updateConnectionState(connectionId, currentCount, {
    lastMessage: message,
    lastMessageAt: new Date().toISOString()
  }).catch((error23) => {
    logWarn("Failed to update connection state in Redis", { connectionId, error: error23 });
  });
  try {
    ws.send({
      type: "message_response",
      count: currentCount,
      timestamp: new Date().toISOString()
    });
  } catch (sendError) {
    logError("Failed to send message response", { connectionId, error: sendError });
  }
  incrementMessage("message", "processed");
  logInfo("Message processed", {
    connectionId,
    messageCount: currentCount,
    messageType: typeof message
  });
};
var handleWebSocketClose = async (ws) => {
  const { connectionId } = ws.data.params;
  const finalCount = connectionCounts.get(connectionId) || 0;
  try {
    await storeConnectionState(connectionId, finalCount, {
      disconnectedAt: new Date().toISOString(),
      reason: "connection_closed"
    });
    logInfo("Connection state saved for potential reconnection", {
      connectionId,
      finalCount
    });
  } catch (error23) {
    logWarn("Failed to store connection state on close", { connectionId, error: error23 });
  }
  clearInterval(heartbeatIntervals.get(connectionId));
  heartbeatIntervals.delete(connectionId);
  connectionCounts.delete(connectionId);
  activeConnections.delete(connectionId);
  decrementConnection();
  logInfo("Connection closed", {
    connectionId,
    finalCount,
    activeConnections: activeConnections.size
  });
};
var cleanupAllConnections = () => {
  logInfo("Cleaning up all WebSocket connections...");
  for (const [connectionId, ws] of activeConnections.entries()) {
    console.log("Closing connection:", connectionId);
    try {
      gracefullyCloseConnection(ws, "server_shutdown");
    } catch (error23) {
      console.error("Error during connection cleanup:", connectionId, error23);
      try {
        ws.raw.close(1001, "Server shutting down");
      } catch (closeError) {
        logError("Error force closing connection", { connectionId, error: closeError });
      }
    } finally {
      const intervalId = heartbeatIntervals.get(connectionId);
      if (intervalId) {
        clearInterval(intervalId);
      }
    }
  }
  activeConnections.clear();
  heartbeatIntervals.clear();
  connectionCounts.clear();
};

// src/utils/health.ts
init_redis();
var isReady = false;
var isShuttingDown = false;
var startupTime = Date.now();
var setReady = (ready) => {
  isReady = ready;
};
var setShuttingDown = (shutting) => {
  isShuttingDown = shutting;
};
var handleLivenessCheck = (requestLogger, requestId) => {
  requestLogger.debug("Liveness check requested");
  incrementHttpRequest("GET", "/healthz", "200");
  return {
    status: "ok",
    timestamp: new Date().toISOString(),
    request_id: requestId,
    uptime: process.uptime(),
    check_type: "liveness"
  };
};
var handleReadinessCheck = (requestLogger, requestId) => {
  requestLogger.debug("Readiness check requested");
  if (isShuttingDown) {
    incrementHttpRequest("GET", "/readyz", "503");
    return {
      response: new Response(JSON.stringify({
        status: "not_ready",
        reason: "shutting_down",
        timestamp: new Date().toISOString(),
        request_id: requestId,
        check_type: "readiness"
      }), {
        status: 503,
        headers: { "Content-Type": "application/json" }
      }),
      isError: true
    };
  }
  if (!isReady) {
    incrementHttpRequest("GET", "/readyz", "503");
    return {
      response: new Response(JSON.stringify({
        status: "not_ready",
        reason: "starting_up",
        timestamp: new Date().toISOString(),
        request_id: requestId,
        startup_time_ms: Date.now() - startupTime,
        check_type: "readiness"
      }), {
        status: 503,
        headers: { "Content-Type": "application/json" }
      }),
      isError: true
    };
  }
  incrementHttpRequest("GET", "/readyz", "200");
  return {
    response: {
      status: "ready",
      timestamp: new Date().toISOString(),
      request_id: requestId,
      connections: activeConnections.size,
      uptime: process.uptime(),
      startup_time_ms: Date.now() - startupTime,
      check_type: "readiness"
    },
    isError: false
  };
};
var handleHealthCheck = async (requestLogger, requestId) => {
  requestLogger.debug("Health check requested");
  incrementHttpRequest("GET", "/health", "200");
  setConnectionCount(activeConnections.size);
  let redisInfo = {
    available: false,
    status: "unavailable"
  };
  try {
    if (isRedisAvailable()) {
      const redisHealth = await redisHealthCheck();
      redisInfo = {
        available: true,
        status: redisHealth.status,
        latency: redisHealth.latency
      };
    }
  } catch (error23) {
    redisInfo = {
      available: false,
      status: "error"
    };
  }
  return {
    status: "ok",
    timestamp: new Date().toISOString(),
    request_id: requestId,
    connections: activeConnections.size,
    uptime: process.uptime(),
    redis: redisInfo
  };
};
var handleMetricsEndpoint = async (requestLogger, requestId) => {
  requestLogger.debug("Metrics requested");
  setConnectionCount(activeConnections.size);
  const metrics3 = await getMetrics();
  incrementHttpRequest("GET", "/metrics", "200");
  return new Response(metrics3, {
    headers: { "Content-Type": getContentType() }
  });
};

// src/utils/shutdown.ts
init_logger();
init_redis();
async function gracefulShutdown(signal) {
  const shutdownStartTime = Date.now();
  const shutdownRequestId = generateRequestId();
  const shutdownLogger = createRequestLogger(shutdownRequestId);
  shutdownLogger.info(`Received ${signal}, starting graceful shutdown...`, {
    event_type: "shutdown_start",
    signal
  });
  setShuttingDown(true);
  setReady(false);
  try {
    cleanupAllConnections();
    await closeRedis();
    const shutdownDuration = (Date.now() - shutdownStartTime) / 1000;
    recordShutdownTime(shutdownDuration);
    shutdownLogger.info("Graceful shutdown completed", {
      event_type: "shutdown_complete",
      shutdown_duration_seconds: shutdownDuration
    });
    setTimeout(() => {
      console.log("Exiting process...");
      process.exit(0);
    }, 1e4);
  } catch (error23) {
    shutdownLogger.error("Error during graceful shutdown", {
      error: error23,
      event_type: "shutdown_error"
    });
    process.exit(1);
  }
}
function setupSignalHandlers() {
  process.on("SIGTERM", () => {
    console.log("SIGTERM received");
    gracefulShutdown("SIGTERM");
  });
  process.on("SIGINT", () => {
    console.log("SIGINT received");
    gracefulShutdown("SIGINT");
  });
  process.on("unhandledRejection", (reason, promise2) => {
    logger.error("Unhandled Rejection", {
      reason,
      promise: promise2,
      event_type: "unhandled_rejection"
    });
  });
  process.on("uncaughtException", (error23) => {
    logger.error("Uncaught Exception", {
      error: error23,
      event_type: "uncaught_exception"
    });
    process.exit(1);
  });
}

// src/index.ts
var app = new Elysia().use(staticPlugin({
  assets: "./public",
  prefix: "/static"
})).derive(({ headers }) => {
  const requestId = headers["x-request-id"] || generateRequestId();
  return { requestId, requestLogger: createRequestLogger(requestId) };
}).ws("/ws/chat/:connectionId", {
  async open(ws) {
    await handleWebSocketOpen(ws);
  },
  async message(ws, message) {
    await handleWebSocketMessage(ws, message);
  },
  async close(ws) {
    await handleWebSocketClose(ws);
  }
}).get("/healthz", ({ requestLogger, requestId }) => {
  return handleLivenessCheck(requestLogger, requestId);
}).get("/readyz", ({ requestLogger, requestId }) => {
  const result = handleReadinessCheck(requestLogger, requestId);
  return result.isError ? result.response : result.response;
}).get("/health", async ({ requestLogger, requestId }) => {
  return await handleHealthCheck(requestLogger, requestId);
}).get("/metrics", async ({ requestLogger, requestId }) => {
  return await handleMetricsEndpoint(requestLogger, requestId);
}).get("/", () => Bun.file("./public/index.html")).listen({
  port: parseInt(process.env.PORT || "3001"),
  hostname: process.env.HOST || "0.0.0.0"
});
var initializeRedisConnection = async () => {
  try {
    const redisModule = await Promise.resolve().then(() => (init_redis(), exports_redis));
    await redisModule.initializeRedis();
    logInfo("Redis initialized successfully for reconnection support");
  } catch (error23) {
    logError("Failed to initialize Redis, continuing without reconnection support", {
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
  }
};
setTimeout(() => {
  initializeRedisConnection().catch((error23) => {
    logError("Redis initialization failed during delayed startup", { error: error23 });
  });
}, 1000);
setTimeout(() => {
  setReady(true);
  logInfo("Application ready to serve traffic", {
    event_type: "application_ready",
    startup_time_ms: Date.now() - startupTime,
    port: parseInt(process.env.PORT || "3001"),
    host: process.env.HOST || "0.0.0.0"
  });
}, 2000);
logInfo("WebSocket server started", {
  port: parseInt(process.env.PORT || "3001"),
  host: process.env.HOST || "0.0.0.0",
  event_type: "application_start",
  startup_time: new Date().toISOString()
});
setupSignalHandlers();
